diff -ruN orig/gromacs-2022/src/gromacs/ewald/pme_spread.cpp gromacs-2022/src/gromacs/ewald/pme_spread.cpp
--- orig/gromacs-2022/src/gromacs/ewald/pme_spread.cpp	2022-02-23 01:05:08.000000000 +0900
+++ gromacs-2022/src/gromacs/ewald/pme_spread.cpp	2022-03-31 11:59:54.704649402 +0900
@@ -213,6 +213,115 @@
 /* Macro to force loop unrolling by fixing order.
  * This gives a significant performance gain.
  */
+#define CALC_SPLINE4                                                                                     \
+    {                                                                                                    \
+        for (int j = 0; (j < DIM); j++)                                                                  \
+        {                                                                                                \
+            real dr, div;                                                                                \
+            real data0, data1, data2;                                                                    \
+                                                                                                         \
+            dr = xptr[j];                                                                                \
+                                                                                                         \
+            /* dr is relative offset from lower cell limit */                                            \
+                                                                                                         \
+            div = 1.0 / 2.0;                                                                             \
+            data2 = div * dr * dr;                                                                       \
+            data1 = div * ((dr + 1.0) * (1.0 - dr) + (2.0 - dr) * dr);                                   \
+            data0 = div *                            (1.0 - dr) * (1.0 - dr);                            \
+            /* differentiate */                                                                          \
+            dtheta[j][i * 4    ] =       - data0;                                                        \
+            dtheta[j][i * 4 + 1] = data0 - data1;                                                        \
+            dtheta[j][i * 4 + 2] = data1 - data2;                                                        \
+            dtheta[j][i * 4 + 3] = data2;                                                                \
+                                                                                                         \
+            div = 1.0 / 3.0;                                                                             \
+            theta[j][i * 4    ] = div *                       (1.0 - dr) * data0;                        \
+            theta[j][i * 4 + 1] = div * ((dr + 2.0) * data0 + (2.0 - dr) * data1);                       \
+            theta[j][i * 4 + 2] = div * ((dr + 1.0) * data1 + (3.0 - dr) * data2);                       \
+            theta[j][i * 4 + 3] = div * dr * data2;                                                      \
+        }                                                                                                \
+    }
+
+#define CALC_SPLINE5                                                                                     \
+    {                                                                                                    \
+        for (int j = 0; (j < DIM); j++)                                                                  \
+        {                                                                                                \
+            real dr, div;                                                                                \
+            real data0, data1, data2, data3;                                                             \
+                                                                                                         \
+            dr = xptr[j];                                                                                \
+                                                                                                         \
+            /* dr is relative offset from lower cell limit */                                            \
+                                                                                                         \
+            div         = 1.0 / 2.0;                                                                     \
+            data2 = div * dr * dr;                                                                       \
+            data1 = div * ((dr + 1.0) * (1.0 - dr) + (2.0 - dr) * dr);                                   \
+            data0 = div *                            (1.0 - dr) * (1.0 - dr);                            \
+            div         = 1.0 / 3.0;                                                                     \
+            data3 = div * dr * data2;                                                                    \
+            data2 = div * ((dr + 1.0) * data1 + (3.0 - dr) * data2);                                     \
+            data1 = div * ((dr + 2.0) * data0 + (2.0 - dr) * data1);                                     \
+            data0 = div *                       (1.0 - dr) * data0;                                      \
+            /* differentiate */                                                                          \
+            dtheta[j][i * 5    ] =       - data0;                                                        \
+            dtheta[j][i * 5 + 1] = data0 - data1;                                                        \
+            dtheta[j][i * 5 + 2] = data1 - data2;                                                        \
+            dtheta[j][i * 5 + 3] = data2 - data3;                                                        \
+            dtheta[j][i * 5 + 4] = data3;                                                                \
+                                                                                                         \
+            div             = 1.0 / 4.0;                                                                 \
+            theta[j][i * 5    ] = div *                       (1.0 - dr) * data0;                        \
+            theta[j][i * 5 + 1] = div * ((dr + 3.0) * data0 + (2.0 - dr) * data1);                       \
+            theta[j][i * 5 + 2] = div * ((dr + 2.0) * data1 + (3.0 - dr) * data2);                       \
+            theta[j][i * 5 + 3] = div * ((dr + 1.0) * data2 + (4.0 - dr) * data3);                       \
+            theta[j][i * 5 + 4] = div *   dr        * data3;                                             \
+        }                                                                                                \
+    }
+
+#define CALC_SPLINE6                                                                                     \
+    {                                                                                                    \
+        for (int j = 0; (j < DIM); j++)                                                                  \
+        {                                                                                                \
+            real dr, div;                                                                                \
+            real data0, data1, data2, data3, data4;                                                      \
+                                                                                                         \
+            dr = xptr[j];                                                                                \
+                                                                                                         \
+            /* dr is relative offset from lower cell limit */                                            \
+                                                                                                         \
+            div         = 1.0 / 2.0;                                                                     \
+            data2 = div * dr * dr;                                                                       \
+            data1 = div * ((dr + 1.0) * (1.0 - dr) + (2.0 - dr) * dr);                                   \
+            data0 = div *                            (1.0 - dr) * (1.0 - dr);                            \
+            div         = 1.0 / 3.0;                                                                     \
+            data3 = div * dr * data2;                                                                    \
+            data2 = div * ((dr + 1.0) * data1 + (3.0 - dr) * data2);                                     \
+            data1 = div * ((dr + 2.0) * data0 + (2.0 - dr) * data1);                                     \
+            data0 = div *                       (1.0 - dr) * data0;                                      \
+            div         = 1.0 / 4.0;                                                                     \
+            data4 = div * dr * data3;                                                                    \
+            data3 = div * ((dr + 1.0) * data2 + (4.0 - dr) * data3);                                     \
+            data2 = div * ((dr + 2.0) * data1 + (3.0 - dr) * data2);                                     \
+            data1 = div * ((dr + 3.0) * data0 + (2.0 - dr) * data1);                                     \
+            data0 = div *                       (1.0 - dr) * data0;                                      \
+            /* differentiate */                                                                          \
+            dtheta[j][i * 6    ] =       - data0;                                                        \
+            dtheta[j][i * 6 + 1] = data0 - data1;                                                        \
+            dtheta[j][i * 6 + 2] = data1 - data2;                                                        \
+            dtheta[j][i * 6 + 3] = data2 - data3;                                                        \
+            dtheta[j][i * 6 + 4] = data3 - data4;                                                        \
+            dtheta[j][i * 6 + 5] = data4;                                                                \
+                                                                                                         \
+            div         = 1.0 / 5.0;                                                                     \
+            theta[j][i * 6    ] = div *                       (1.0 - dr) * data0;                        \
+            theta[j][i * 6 + 1] = div * ((dr + 4.0) * data0 + (2.0 - dr) * data1);                       \
+            theta[j][i * 6 + 2] = div * ((dr + 3.0) * data1 + (3.0 - dr) * data2);                       \
+            theta[j][i * 6 + 3] = div * ((dr + 2.0) * data2 + (4.0 - dr) * data3);                       \
+            theta[j][i * 6 + 4] = div * ((dr + 1.0) * data3 + (5.0 - dr) * data4);                       \
+            theta[j][i * 6 + 5] = div *   dr        * data4;                                             \
+        }                                                                                                \
+    }
+
 #define CALC_SPLINE(order)                                                                               \
     {                                                                                                    \
         for (int j = 0; (j < DIM); j++)                                                                  \
@@ -287,8 +396,9 @@
             assert(order >= 3 && order <= PME_ORDER_MAX);
             switch (order)
             {
-                case 4: CALC_SPLINE(4) break;
-                case 5: CALC_SPLINE(5) break;
+                case 4: CALC_SPLINE4 break;
+                case 5: CALC_SPLINE5 break;
+                case 6: CALC_SPLINE6 break;
                 default: CALC_SPLINE(order) break;
             }
         }
