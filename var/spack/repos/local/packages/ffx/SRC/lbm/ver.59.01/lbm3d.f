CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C                                                                        C
C     FLOW SOLVER BASED ON LATTICE BOLTZMAN METHOD                       C
C                                                                        C
C            2016.11.29 WRITTEN BY Y.YAMADE                              C
C                                                                        C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      PROGRAM LBM3D
      IMPLICIT NONE
C
      CHARACTER*30 DATE
      DATA DATE     / 'LBM3D:VER.59.01:2022.11.24' /
C
      CHARACTER* 8 MODE(0:1)
      DATA MODE     / 'SERIAL  ', 'PARALLEL' /
C
C
C [01] CONTROALL PARAMETER
      INTEGER*4 NC,NG,ISTART,NTIME,NTIME0,NSTEP
      INTEGER*4 MC,MRESV
      DATA MC /300000/
      DATA MRESV /6/
C
      INTEGER*4 IPART,NPART
      INTEGER*4 IINLTV
      REAL*4    TIME4
      REAL*8    DSCALE,VSCALE,TIME
      REAL*8    VISCM,RHO0
      REAL*8    UINLT,VINLT,WINLT,UWALL,VWALL,WWALL,DBLAS
      REAL*8    TAU0,TAUMIN
      REAL*8    EPSTRG
      DATA IINLTV /0/
      DATA TAU0   /0.5D0/
      DATA TAUMIN /0.5D0/
      DATA UWALL /0.0D0/
      DATA VWALL /0.0D0/
      DATA WWALL /0.0D0/
      DATA UINLT /0.0D0/
      DATA VINLT /0.0D0/
      DATA WINLT /0.0D0/
      DATA DBLAS /1.0D0/
      DATA EPSTRG /0.2D0/
      INTEGER*4  IOUT,IWMODE,IWFUNC,INTFSV,JCHGEO,IRFNF,IMODQ
      DATA JCHGEO /0/
      DATA IWMODE /1/
      DATA IWFUNC /1/
      DATA IRFNF  /0/
      DATA IMODQ  /0/
C
C
C IINLTV      :CONTROL PARAMETER FOR INLET VELOCITY PROFILE
C IINLTV=0    :CONSTANT
C IINLTV=1    :BLASIUS IN X-DIRECTION
C IINLTV=2    :BLASIUS IN Y-DIRECTION
C IINLTV=3    :BLASIUS IN Z-DIRECTION
C DBLAS       :DISTANCE BETWEEN LEADING EDGHE OF BOUNDARY LAYER AND INLET BOUNDARY 
C
C    IRFNF : FLAG FOR REFINE OF INITIAL DISTRIBUTION FUNCTION (0:OFF, 1:ON)
C 
C     
C [02] PARTICLE MODEL
      INTEGER*4 NP
      DATA NP /15/
      INTEGER*4, ALLOCATABLE:: LVEL(:,:),LREV(:,:)
      REAL*8,    ALLOCATABLE:: CVEL(:,:),WF(:)
C      INTEGER*4 LVEL(3,NP),LREV(NP)
C      REAL*8    CVEL(3,NP),WF(NP)
C
C [03] VARIABLE DEFINED AT CUBES
      INTEGER*4, ALLOCATABLE:: LLEVEL(:),LPOSI(:,:),LCBOUN(:,:)
C
C [04] VARIABLE REGARDING GEOMETRY
      INTEGER*4, ALLOCATABLE:: NPBOUN(:),LPBOUN(:,:,:)
      REAL*4   , ALLOCATABLE:: QBOUN(:,:)
C
C [05] VARIABLE DEFINED AT GRIDS
      INTEGER*4, ALLOCATABLE:: MASK(:,:,:,:)
      REAL*8,    ALLOCATABLE:: F   (:,:,:,:,:),TAU(:,:,:,:)
      REAL*8,    ALLOCATABLE:: FWRK(:,:,:,:),FWRK2(:,:,:,:),V3D(:,:,:,:)
      REAL*8,    ALLOCATABLE:: V1(:,:,:),V2(:,:,:),
     *                         V3(:,:,:),V4(:,:,:)
      REAL*4,    ALLOCATABLE:: WRK1(:),WRK2(:),WRK3(:),WRK4(:)
C
C [06] VARIABLES FOR INTER CUBE COMMUNICATION
      INTEGER*4 MBC,MBC1,MBC2,MBC3
      PARAMETER (MBC=152,MBC1=24,MBC2=72,MBC3=56)
      INTEGER*4, ALLOCATABLE:: NBC(:),LBC(:,:,:)
      REAL*8,    ALLOCATABLE:: FBC1(:,:,:,:,:),FBC1W(:,:,:,:,:),
     *                         FBC2(:,:,:,:  ),FBC2W(:,:,:,:  ),
     *                         FBC3(:,:,:    ),FBC3W(:,:,:    ) 
C
C [07] VARIABLES FOR BOUNDARY CONDITIONS
      INTEGER*4  JBOUN,JGEOM,LBTYPE(6)
      INTEGER*4  MPBOUN,MPG,NPG,MPBOUN0,MPBR
      INTEGER*4  NPTRG 
      DATA JBOUN   /1/
      DATA JGEOM   /0/
      DATA LBTYPE  /2,4,1,1,1,1/
      DATA MPBOUN0 / 1000000/
      DATA MPBR    / -1 /
      DATA MPG     / 1000000/
      DATA NPG     /0/
      REAL*8     HBOUN, DGEOM
      DATA HBOUN /1.0D0/
      DATA DGEOM /1.0D-2/
      INTEGER*4, ALLOCATABLE:: LWORK1(:,:,:),LWORK2(:,:,:),
     *                         LWORK(:,:,:,:)
      INTEGER*4 M1CELL
      DATA M1CELL /7/
C
C   MPBOUN : MAX. NUMBER OF BOUNDARY GRID IN A CUBE
C   MPG    : MAX. NUMBER OF GEOMETRY POINTS
C   NPG    : NUMBER OF GEOMETRY DATA (CAN BE CHENGED BY OPTION)    
C   MPBOUN0: DEFULAT VALUE OF MPBOUN (CAN BE CHENGED BY OPTION)    
C   JBOUN  : FLAG TO SPECITY BOUNDARY CONDITION MODE
C            1 READ GF-BOUN
C            2 MAKE BOUN DATA BY LBM3D
C   JGEOM  : FLAG TO USE GEOMETRY (GEOM) OR TRIANGLE (TRIG) DATA MODE
C            0 NOT READ DATA
C            1     READ GF-GEOM DATA
C            2     READ GF-TRIG DATA
C   LBTYPE : BOUNDARY TYPE AT -X,+X,-Y,+Y,-Z,+Z BOUNDARY FACE
C            FOLLOWING BOUNDARY TYPES ARE SET AS DEFAULT
C            INLET FOR -X (TYPE=2)
C            FREE  FOR +X (TYPE=4)
C            WALL  FOR THE OTHERS (-Y, +Y, -Z, +Z, TYPE=1) 
C   HBOUN  : CRITERIA TO JUDGE INTERSECTING 
C            NOTE THAT IT IS NORMALIZED BY THE CUBE SIZE 
C   XP(IPG): X-COORD. OF GEOMETRY POINTS
C   YP(IPG): Y-COORD. OF GEOMETRY POINTS
C   ZP(IPG): Z-COORD. OF GEOMETRY POINTS
C   XTRG(IPG): X-COORD. OF TRIG. DATA
C   YTRG(IPG): Y-COORD. OF TRIG. DATA
C   ZTRG(IPG): Z-COORD. OF TRIG. DATA 
C
C   M1CELL   :NUMBER OF EDGHES IN A CELL
C             M1CELL= 7 (FOR NP=15)
C             M1CELL=13 (FOR NP=27)
C            
C
C [08] VARIABLES FOR INTER DOMAIN COMMUNICATION
      INTEGER*4 MDOM,MPB,NDOM
      INTEGER*4, ALLOCATABLE:: LDOM(:),NBPRCV(:),NBPSND(:)
      REAL*8,    ALLOCATABLE:: BUFRCV(:,:),BUFSND(:,:)
      DATA MDOM /200/
      DATA MPB  /0/
C
C [09] VARIABLES FOR HISTORY
      INTEGER*4 MSAMPL
      PARAMETER(MSAMPL=1000)
      INTEGER*4 NSAMPL,NHIST
      DATA NSAMPL /0/
      INTEGER*4  LSAMPL(5,MSAMPL),LHIST(MSAMPL)
      REAL*8     XSAMPL(MSAMPL),YSAMPL(MSAMPL),ZSAMPL(MSAMPL)
      REAL*8     CSAMPL(3,MSAMPL)
      REAL*4,    ALLOCATABLE:: HIST(:,:)
      CHARACTER*60 COMHST(MSAMPL)
      DATA COMHST( 1) / ' TIME                                 '/
      DATA COMHST( 2) / ' MAX. RHO                             '/
      DATA COMHST( 3) / ' MAX. VELOCITY                        '/
      DATA COMHST( 4) / ' FLUID FORCE IN X-DIRECTION           '/
      DATA COMHST( 5) / ' FLUID FORCE IN Y-DIRECTION           '/
      DATA COMHST( 6) / ' FLUID FORCE IN Z-DIRECTION           '/
C
C [10] VARIABLES FOR BLOCK
      INTEGER*4 MBLK,NBLK,MPBLK
      PARAMETER(MBLK=200)
      INTEGER*4    NUMBLK(3,MBLK),INTBLK(MBLK),NPBLK(MBLK),NPBLK3
      REAL*8       CORBLK(6,MBLK)
      CHARACTER*60 FILBLK(MBLK)
      INTEGER*4,ALLOCATABLE:: LCBLK(:,:),LPBLK1(:,:,:),LPBLK2(:,:,:)
      REAL*8,ALLOCATABLE::COEBLK(:,:,:)
      REAL*4,ALLOCATABLE::RHOBLK(:),UBLK(:),VBLK(:),WBLK(:)
C
C MBLK        : MAX. NUM. NUM OF BLOCK DATA (=200)
C NBLK        : NUM OF BLOCK DATA
C NUMBLK(:,:) : NUM OF POINTS IN EACH DIR. OF BLOCKS
C IANGLE(:)   : FLAG FOR ROTAING BLOCKS (NOT SUPPORTED IN THIS VERSION)
C               0: NOT RORATE (DEFUALT)
C               1: ROTATE BLOCKS ALONG Y=YROT, Z=ZROT
C               2: ROTATE BLOCKS ALONG Z=ZROT, X=XROT
C               3: ROTATE BLOCKS ALONG X=XROT, T=YROT
C ISTRAIN(:)  : FLAG FOR WTIRINT STRAIN TENSOR  (NOT SUPPORTED IN THIS VERSION)
C               0: NOT-WRITE (DEFUALT)
C               1: WRITE
C INTBLK(:)   : TIME INTERVAL FOR WRITING BLOCK DATA
C               0: OUTPUT ONLY FINALE FLOW FIELD
C               LARGER THAN 1:OUTPUT FLOW FIELD AT EVERY INTBLK STEP
C
C CORBLK(:,:) : BOUNDING BOX OF BLOCKS   
C               CORBLK([1,2,3],:) --> Xmin, Ymin, Zmin 
C               CORBLK([4,5,6],:) --> Xmax, Ymax, Zmax 
C ANGLE(:)    : ANGLE FOR ROTAING BLOCKS  (NOT SUPPORTED IN THIS VERSION)
C ROTCNT(:,:) : COORD. OF RORATION AXIS   (NOT SUPPORTED IN THIS VERSION)
C FILBLK(:)   : FILE NAME OF BLOCK DATA
C
C
C [11] VARIABLES FOR SURFACE
      INTEGER*4 IWRTSF,INTSRF,IMVTRG,NPSURF(2),JSURF
      INTEGER*4,ALLOCATABLE:: LSURF(:,:,:),LPSURF(:,:)
      REAL*4,   ALLOCATABLE:: XP(:),YP(:),ZP(:),QCELL(:,:,:,:),
     *                        XTRG(:,:),YTRG(:,:),ZTRG(:,:),RHOSRF(:)
      REAL*8    DTRG 
      REAL*8,   ALLOCATABLE:: CSURF(:,:,:)
C
      DATA IWRTSF /0/
      DATA INTSRF /0/
      DATA IMVTRG /0/
      DATA NPSURF /0,0/
C 
      DATA DTRG /0.1D0/
C
C     IWRTSRF    : FLAG FOR WRITING GF-SURF FILE
C               0: NOT WRITE GF-SURF FILE (DEFAULT)
C               1:     WRITE GF-SURF FILE
C     INTSRF     : INTERVAL FOR WRITING GF-SURF FILE
C               0: WRITE GF-SURF FILE AT ONLY FINAL   STEP  
C     INTSRF.GT.0: WRITE GF-SURF FILE AT EVERY INTSRF STEP  
C     IMVTRG     : FLAG FOR MOVING TRIG-DATA
C               0: NOT MOVE TRID-DATA (DEFAULT)
C               1:     MOVE TRID-DATA
C                 
C     NPSURF : NUMBER OF SURFPOINT FOUND IN THE SUB-DOMAIN
C     DTRG   : MOVING LENGTH NORMALIZED BY MINIMUM GRID LENGTH
C
C
C [12] VARIABLES FOR DUMPING REGION 
C
      INTEGER*4 JDUMP
      REAL*8    PARDMP(12)
      REAL*8,ALLOCATABLE:: CDUMP(:,:,:),FDUMP(:)
C
      DATA JDUMP /0/
C 
C JDUMP       : TYPE OF DUMPING REGION
C             : 0: NO DUMPING REGION
C             : 1: SPHERE
C             : 2: CYLINDER ALONG X-DIRECTION
C             : 3: CYLINDER ALONG Y-DIRECTION
C             : 4: CYLINDER ALONG Z-DIRECTION
C             :11: ELLIPSOID  
C
C
C IF JDUMP = 1,2,3 OR 4
C PARDMP( 1)  : X CORDINATE OF CENTER OF DUMPING REGION 
C PARDMP( 2)  : Y CORDINATE OF CENTER OF DUMPING REGION 
C PARDMP( 3)  : Z CORDINATE OF CENTER OF DUMPING REGION 
C PARDMP( 4)  : R1 OF DOUMPING REGION
C PARDMP( 5)  : R2 OF DOUMPING REGION
C PARDMP( 6)  : COEFICIENT OF DUMPING TERM (=ALPHA)
C PARDMP( 7)  : TARGET DENSITY  
C PARDMP( 8)  : TARGET VELOCITY-U
C PARDMP( 9)  : TARGET VELOCITY-V 
C PARDMP(10)  : TARGET VELOCITY-W
C
C IF JDUMP = 11
C PARDMP( 1)  : X CORDINATE OF CENTER OF DUMPING REGION 
C PARDMP( 2)  : Y CORDINATE OF CENTER OF DUMPING REGION 
C PARDMP( 3)  : Z CORDINATE OF CENTER OF DUMPING REGION 
C PARDMP( 4)  : RX    OF DOUMPING REGION
C PARDMP( 5)  : RY    OF DOUMPING REGION
C PARDMP( 6)  : RZ    OF DOUMPING REGION
C PARDMP( 7)  : RATIO OF DOUMPING REGION
C PARDMP( 8)  : COEFICIENT OF DUMPING TERM (=ALPHA)
C PARDMP( 9)  : TARGET DENSITY  
C PARDMP(10)  : TARGET VELOCITY-U
C PARDMP(11)  : TARGET VELOCITY-V 
C PARDMP(12)  : TARGET VELOCITY-W
C
C CDUMP(:,:,:): WORK REFION FOR COEF. OF DUMPING TERM 
C FDUMP (NP)  : EQUIBRIUM DISTRIBUTION FUNCTION  CALCULATED BY TARGET
C
C
C
CC [13] RELAXATION CONTROLL
CC
      INTEGER*4 MTFIX,NTFIX
      PARAMETER (MTFIX=100)
      INTEGER*4 LTFIX (2,MTFIX) 
      REAL*8    TAUFIX(MTFIX) ,TAINLT,TAFREE
C
      INTEGER*4 JVISC
      REAL*8               PARVIS(8),TAUTGT
      REAL*8,ALLOCATABLE:: CVISC(:,:,:)
C
      DATA NTFIX /0/
      DATA TAINLT /-1.0/
      DATA TAFREE /-1.0/
      DATA JVISC /0/
C
C
C  MTFIX       :MAX. NUMBER OF TAU-FIX INPUT
C  NTFIX       :     NUMBER OF TAU-FIX INPUT
C  LTFIX(1,I)  :SPECIFY DIRECTION OF TAU-FIX (1:X, 2:Y, 3:Z)
C  LTFIX(2,I)  :POSITION OF TAU-FIX CELL (1--> NC[X,Y,Z])
C  TAUFIX(I)   :RELAXATION COEF. TAU OF TAU-FIX CELL 
C 
C JVISC       : TYPE OF DUMPING REGION
C             : 0: NO DUMPING REGION
C             : 1: SPHERE
C             : 2: CYLINDER ALONG X-DIRECTION
C             : 3: CYLINDER ALONG Y-DIRECTION
C             : 4: CYLINDER ALONG Z-DIRECTION
C             :11: ELLIPSOID  
C
C TAUTGT      : RELAXTION TIME AT VISCOUS REGION
C
C IF JVISC = 1,2,3 OR 4
C PARVIS( 1)  : X CORDINATE OF CENTER OF VISCOUS REGION 
C PARVIS( 2)  : Y CORDINATE OF CENTER OF VISCOUS REGION 
C PARVIS( 3)  : Z CORDINATE OF CENTER OF VISCOUS REGION 
C PARVIS( 4)  : R1 OF DOUMPING REGION
C PARVIS( 5)  : R2 OF DOUMPING REGION
C PARVIS( 6)  : ALPHA (=1.0)
C
C IF JVISC = 11
C PARVIS( 1)  : X CORDINATE OF CENTER OF VISCOUS REGION 
C PARVIS( 2)  : Y CORDINATE OF CENTER OF VISCOUS REGION 
C PARVIS( 3)  : Z CORDINATE OF CENTER OF VISCOUS REGION 
C PARVIS( 4)  : RX    OF DOUMPING REGION
C PARVIS( 5)  : RY    OF DOUMPING REGION
C PARVIS( 6)  : RZ    OF DOUMPING REGION
C PARVIS( 7)  : RATIO OF DOUMPING REGION
C PARVIS( 8)  : ALPHA (=1.0)
C
C CVISC(:,:,:): WORK REFION FOR COEF. OF VISCOUS TERM 
C
C [14] VARIABLES FOR TURBULENCR MODEL
      INTEGER*4 IMODEL,ICALSS,ICNSTD
      REAL*8    CS
      DATA IMODEL /0/
      DATA ICALSS /2/
      DATA CS     /0.1/
      DATA ICNSTD /0/
C
C IMODEL=0: NON-SGS MODEL 
C IMODEL=1: STANDARD SMAGORINSKY MODEL
C ICALSS=0: CAL. STRAIN BY MACRO VARIAVLES
C ICALSS=1: CAL. STRAIN BY DISRIBUTION FUNCTAION (EXPLICIT)
C ICALSS=2: CAL. STRAIN BY DISRIBUTION FUNCTAION (IMPLICIT)
C
C ICNSTD=0: USE LOCAL   GRID SCALE FOR COMPUTING TURBULENT VISCOCITY  
C ICNSTD=1: USE MINIMUM GRID SCALE FOR COMPUTING TURBULENT VISCOCITY  
C
C [15] VARIABLES FOR COLLISION MODEL
      INTEGER*4 ICOLLI
      DATA ICOLLI /1/
C
C ICOLLI=1 :SRT
C ICOLLI=2 :MRT
C
C
C [16] VARIABLES FOR FLUID FORCES
      REAL*8,     ALLOCATABLE:: FXC(:),FYC(:),FZC(:)
      REAL*8,     ALLOCATABLE:: FXWRK(:),FYWRK(:),FZWRK(:)
      REAL*4 FX,FY,FZ,COEFF
C
C
C [17] VARIABLES FOR FILE ACCESS
      CHARACTER*60 FILEIN,FILECB,FILEBC,FILEIF,
     *             FILEFF,FILEVF,FILEAV,FILERM,
     *             FILEFS,FILEHS,FILELG,FILEGM,
     *             FILETR,FILESF,FILE
      DATA FILELG / 'lbm3d.log' /
      DATA FILEIN / 'PARMLBM3D' /
      DATA FILEGM / 'GEOM'      /
      DATA FILETR / 'TRIG'      /
      INTEGER*4    IUT0,IUT6,IUTIN,IUTLG,
     *             IUTCB,IUTBC,IUTIF,IUTFF,
     *             IUTVF,IUTAV,IUTRM,IUTFS,IUTHS,
     *             IUTGM,IUTST,IUTSF,IUTBL0,IUTBLK
      DATA IUT0  / 0/
      DATA IUT6  / 6/
      DATA IUTIN /11/
      DATA IUTCB /12/
      DATA IUTBC /13/ 
      DATA IUTIF /14/
      DATA IUTFF /15/
      DATA IUTVF /16/
      DATA IUTAV /17/
      DATA IUTRM /18/
      DATA IUTFS /19/
      DATA IUTHS /19/
      DATA IUTGM /20/
      DATA IUTST /21/
      DATA IUTSF /22/
      DATA IUTBL0 /300/
      DATA IUTLG /60/
      INTEGER*4 MCOM,NCOMFL,NCOMST
      PARAMETER (MCOM=100)
      CHARACTER*60 COMFLE(MCOM),COMSET(MCOM)
CC
CC [18] CONSTANTS REGARDING PARAMETER FOR CALLING GFALL
CC
      INTEGER*4 IACT,IRESV,IWRITE,INAME,
     *          ICAST,ICAST1,IDATA0,IALL,IALLM,ISKIP,ISKIP1,ICHECK,
     *          JGRID 
      CHARACTER*30 NAME
      DATA IWRITE / 2 /
      DATA INAME  / 1 /
      DATA ICAST  /0/
      DATA ICAST1 /1/
      DATA IDATA0 /0/
      DATA IALL   /0/
      DATA IALLM  /-1/
      DATA ISKIP  /0/
      DATA ISKIP1 /1/
      DATA ICHECK /999999/
      DATA JGRID  /1/
C
C [19] MESSAGE
      INTEGER*4 INTPRN,MAXPRN
      DATA MAXPRN / 200 /
      CHARACTER*10 BLANK / ' ' /
C
C          MAXPRN      ; MAXIMUM TIME STEPS TO BE PRINTED OUT
C
C [20] CPU TIME
C
      INTEGER*4 IWRTIM
      DATA IWRTIM /0/
#ifdef cputime
      include 'mpif.h'
#endif
C
C
CC [21] CHECK FLOW
CC
      INTEGER*4  NCHKFL,JSTOP
      REAL*8     RHOSTP
      DATA JSTOP  /  0/ 
      DATA NCHKFL /  1/ 
      DATA RHOSTP /1.0D1/ 
      REAL*8     RHOMAX,VELMAX,BUF1,BUF2
C
C   NCHKFL   :INTERVAL TO CHECK FLOW
C             NOTE THAT THE COMPUTATIONAL TIME TO CHECK FLOW IS ABOUT 100 
C             LONGER THAN FLOW COMPUTAITON. THERFORE, RECOMMENDED VALUE 
C             FOR NCHKFL IS LARGER THAN 100
C   RHOSTP   :COMPUTATION WILL BE STOPPED WHEN RHO IS LARGER THAN RHOSTP   
C
CC [22] FLOW OUTPUT CONTROLL
CC
      INTEGER*4 NFLINT
      DATA NFLINT /1/ 
C     NFLINT :GRID INTERVAL TO WRITE FLOW
C    
C   
C
      INTEGER*4 ID,IP,I,J,K,NG3,IBLK,IPB,LDUM
      REAL*8    BUF,DUM
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C CONSTANT PARAMETER
C     NP     :NUMBER OF PARTICLES (=15)
C     ISTART :RESTART FLAG (0:OFF, 1or2:ON)
C       1: SET ZERO VELOCITY 
C       2: READ GF-FUNC FILE
C       3: READ GF-FLOW FILE AND CAL DISRIBUTION FUNCTAION 
C     NTIME  :NUMBER OF TIME STEPS 
C   LVEL(NP) :NORMALIZED VELOCITY OF PARTCLES (INTEGER)
C   CVEL(NP) :NORMALIZED VELOCITY OF PARTCLES (FLOAT)
C   LREV(NP) :INVERSE LIST OF PARTICLES
C   WF  (NP) :COEEFICIENTS TO CALCULATE PARTICLE DISTRIBUTION FUNCTION
C   IPART    :DOMAIN NUMBER THAT THIS TASK SHOULD COMPUTE/IS COMPUTING. 
C             IPART BEING SET ZERO MEANS THAT THE PROGRAM SHOULD RUN/IS 
C             RUNNING IN SERIAL MODE.
C
C CONTROL   VARIABLES
C    IPART       ; DOMAIN NUMBER THAT THIS TASK SHOULD COMPUTE/IS
C                  COMPUTING. IPART BEING SET ZERO MEANS THAT
C                  THE PROGRAM SHOULD RUN/IS RUNNING IN SERIAL
C                  MODE.
C     MC    MAX NUMBER OF CUBES IN SUB-DOMAIN
C     MRESV DEFAULT NUMBER OF HISTORY SAVING DATA (=6)
C     NC    NUMBER OF CUBES IN SUB-DOMAIN
C     NG    CUBE SIZE
C     DSCALE LENGTH OF MINIMUMU CUBE
C     VSCALE VELOCITY RATIO BETWEEN CHARACTEERICTIC AND PARTICLE VELOCITY 
C     VISCM  NORMALIZED VISCOCITY BY DSCALE AND VSCALE
C     RHO0   INITIAL DENSITY
C     UINLT  U-VELOCITY AT INLET B.C.       (NORMALIZED BY VSCALE)
C     VINLT  V-VELOCITY AT INLET B.C.       (NORMALIZED BY VSCALE)
C     WINLT  W-VELOCITY AT INLET B.C.       (NORMALIZED BY VSCALE) 
C     UWALL  U-VELOCITY AT MOVING WALL B.C. (NORMALIZED BY VSCALE)
C     VWALL  V-VELOCITY AT MOVING WALL B.C. (NORMALIZED BY VSCALE)
C     WWALL  W-VELOCITY AT MOVING WALL B.C. (NORMALIZED BY VSCALE)
C
C     IOUT  CONTROLS OPTIONAL OUTPUT FILES
C            0 --- OUTPUT NO OPTIONAL FILES
C            1 --- OUTPUT AVERAGE         FLOW FIELD FILE 
C            2 --- OUTPUT AVERAGE AND RMS FLOW FIELD FILES
C
C     INTFSV      ; FIELD DATA SAMPLING INTERVAL
C           NOTES ; INSTANTANEOUS VELOCITY COMPONENTS AT ALL THE MODES
C                  AND STATIC PRESSURE AT ALL THE ELEMENTS WILL BE
C                  OUTPUT TO THE SPECIFIED FILE AT EVERY 'INTFSV' TIME
C                  STEPS. NO DATA WILL BE OUTPUT WHEN 'INTFSV' IS SET
C                  TO 0.
C
C     EPSTRG :TOLERANCE OF ERROR FOR MAKING INTERSECTDATA
C     IMODQ  : FLAG FOR SETTING Q (DISTANCE BETWEEN THE GRID AND INTERSETC)
C             0:USE CALCULATED VALUE
C             1:ALL THE DISTANCE ARE SET TO ONE.
C
C
C A. VARIABLE DEFINED AT CUBES
C    LLEVEL(IC)    LEVEL OF CUBES, WHICH INDICATE THE GRID RESOLUTION. 
C                  LEVEL=1 CORRESPONTDS THE FINEST GRID SIZE. A GRID SIZE
C                  WILL BE TWICE WITH ONE INCREMENT OF THE LEVEL.
C    LPOSI(3,IC)   INDICATES THE POSITIONS OF CUBES, WHICH ARE NORMALIZED 
C                  BY THE MINIMUM CUBE SIZE.
C    NPBOUN(IC)    NUMBER OF BOUNDARY GRID    
C    LPBOUN(I,IPB,IC) BOUNDARY GRID LIST
C                     1: POSITION OF BOUNDRY GRID IN I-DIRECTION 
C                     2: POSITION OF BOUNDRY GRID IN J-DIRECTION 
C                     3: POSITION OF BOUNDRY GRID IN K-DIRECTION 
C                     4: DIRECTION TO INNER GRID (2-15)
C                     5: BOUNDARY TYPE (ITYPE)
C                        ITYPE=1: WALL
C                        ITYPE=2: INLET
C                        ITYPE=3: MOVING-WALL
C                        ITYPE=4: FREE
C                        ITYPE=5: SYMMETRIC 
C    QBOUN(IPB,IC) NON-DIMENSIONAL DISTANCE TO INNER GRIDS 
C    LCBOUN(4,IC)  SET TO 1 IF OUTER-BOUNDARY (WALL, INLET, MOVING-WALL
C                  OR FREE) IS INCLUDED IN THE CUBE
C                  LCBOUN(1,IC): WALL 
C                  LCBOUN(2,IC): INLET 
C                  LCBOUN(3,IC): MOVING-WALL 
C                  LCBOUN(4,IC): FREE 
C
C B. VARIABLE DEFINED AT GRIDS
C    F     (I,J,K,IP,IC) DISTRIBUTION FUNCTION
C    TAU   (I,J,K,   IC) RELAXATION TIME
C
C C. VARIABLES FOR INTER CUBE COMMUNICATION
C    MBC              MAX. NUMBER OF B.C GROUPS IN CUBES (=152)
C    NBC(IC)          NUMBER OF B.C. GROUPS IN CUBES
C    LBC(II,IBC,IC)   ATTRIBUTE DATA OF B.C. GROUPS
C                     II=1 B.C. GROUP ID (1-26) IN AN ADJACENT CUBE
C                     II=2 SUB-DOMAIN NUMBER OF AN ADJACENT CUBE
C                     II=3 CUBE NUMBER OF AN ADJACENT CUBE IN A DOMAIN
C                     II=4 RELATIVE LEVEL OF AN ADJACENT CUBE
C                      (-1: FINE, 0:SAME, 1:COARSE)
C                     II=5 POSITION IN COARSER CUBE
C    MBC1             MAX. NUMBER OF FACE-TYPE  B.C. GROUPS (=24)
C    MBC2             MAX. NUMBER OF EDGE-TYPE  B.C. GROUPS (=24)
C    MBC3             MAX. NUMBER OF POINT-TYPE B.C. GROUPS (= 8)
C    FBC1 (II,I,J,IB,IC) WORK REGION FOR FACE-TYPE  B.C. GROUPS
C    FBC2 (II,I,  IB,IC) WORK REGION FOR EDGE-TYPE  B.C. GROUPS
C    FBC3 (II,    IB,IC) WORK REGION FOR POINT-TYPE B.C. GROUPS
C    FBC1W(II,I,J,IB,IC) WORK REGION FOR FACE-TYPE  B.C. GROUPS
C    FBC2W(II,I,J IB,IC) WORK REGION FOR EDGE-TYPE  B.C. GROUPS
C    FBC3W(II,    IB,IC) WORK REGION FOR POINT-TYPE B.C. GROUPS
C
C D. VARIABLES FOR INTER DOMAIN COMMUNICATION
C    MDOM             MAX. NUMBER OF THE NEIGHBORING SUB-DOMAINS
C    MPB              NUMBER OF DATA TO BE RECEIVED FROM THE NEIGHBORING 
C                     SUB-DOMAINS
C    NDOM             NUMBER OF THE NEIGHBORING SUB-DOMAINS
C    LDOM(IDOM)       NEIGHBORING SUB-DOMAIN NUMBER
C    NBPRCV(IDOM)     NUMBER OF DATA TO BE RECEIVED FROM THE NEIGHBORING 
C                     SUB-DOMAINS
C    NBPSND(IDOM)     NUMBER OF DATA TO BE RECEIVED FROM THE NEIGHBORING 
C                     SUB-DOMAINS
C    BUFRCV(MPB,MDOM) WORK REGION FOR RECEIVING THE PARTICLE DISTRIBUTION FUNCTION
C    BUFSND(MPB,MDOM) WORK REGION FOR RECEIVING THE PARTICLE DISTRIBUTION FUNCTION
C
C E. VARIABLES FOR HISTORY
C     NSAMPL         NUMBER OF SANPLING DATA
C     LSAMPL(II,ISMPL) PARAMETERS TO CONTROL HISTORY DATA THE 1ST VALUE SPECIFY 
C                      KIND OF VARIABLES(1->DENSITY,2,3,4->VELOCITY), 2ND VALUSE
C                      SPECIFY CUBE NUMBER , AND 3RD, 4TH, 5TH VALUES SPECIFY
C                      POSITION (I,J,K) IN CUBE 
C     HST(II,ITIME)  HISTORY DATA
C
C F. VARIABLES FOR FILE ACCESS
C     FILEIN   :FILE NAME OF PARAMETER   FILE ( INPUT) (=PARAMLBM3D)
C     FILECB   :FILE NAME OF GF-CUBE     FILE ( INPUT)
C     FILEBC   :FILE NAME OF GF-BOUNDARY FILE ( INPUT)
C     FILEIF   :FILE NAME OF GF-FUNC     FILE ( INPUT)
C     FILEFF   :FILE NAME OF GF-FLOW     FILE (OUTPUT)
C     FILEVF   :FILE NAME OF GF-FUNC     FILE (OUTPUT)
C     FILESF   :FILE NAME OF GF-SURF     FILE (OUTPUT)
C    
C G. VARABLES FOR ERROR TRAPS
      INTEGER*4 IERR,IERRA,JESC,LERR(200)
C
      CHARACTER*60 ERRMSG
     * / ' ## PROGRAM    LBM3D: FATAL      ERROR OCCURENCE; STOPPED ' /
      CHARACTER*60 EREXP1
     * / ' ALLOCATING FAILED                                        ' /
      CHARACTER*60 EREXP2
     * / ' MAX DENSITY EXCEEDS LIMIT                                ' /
      CHARACTER*60 EREXP3
     * / ' INSUFFICINT MEMORY, SET LARGER MDOM                      ' /
      CHARACTER*60 EREXP4
     * / ' MAKING B.C. FAILED                                       ' /
C
C
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C
      INTEGER*4 IMODE,ITIME,IC,IBC,II,IDOM,NINT
      REAL*8    SIZEAL,SIZE,WORD
      DATA WORD   / 8.0D-6  /
C
      IERR=0
      NDOM = 0
      CALL DDINIT(NPART,IPART)
      IF(IPART.GE.1) NDOM = 1
C
      IERR =0
      IERRA=0
      SIZEAL = 0.D0
C
C     SPECIFY OPERATION TYPE IN HSMRGX
C     LHIST( 1): TIME      :-1:USE VALUSE IN *.P0001 
C     LHIST( 2): MAX. RHO  :-4:CAL. MAX.
C     LHIST( 3): MAX. VEL. :-4:CAL. MAX.
C     LHIST( 4): FX        :-2:CAL. SUM. 
C     LHIST( 5): FY        :-2:CAL. SUM. 
C     LHIST( 6): FZ        :-2:CAL. SUM. 
      LHIST( 1)=-1
      LHIST( 2)=-4
      LHIST( 3)=-4
      LHIST( 4)=-2
      LHIST( 5)=-2
      LHIST( 6)=-2
C
#ifdef cputime
C      CALL SYSTEM_CLOCK(TCNT0)
C      TSYS0 = MPI_WTIME() 
#endif
      CALL USTINI()
      CALL USTPUT(01,"USRT:TIME-LOOP                ")
      CALL USTPUT(02,"USRT:SRTQxx:                  ")
      CALL USTPUT(03,"USRT:SRTQxx: MACRO VARIABLE   ")
      CALL USTPUT(04,"USRT:SRTQxx: E.-FUNCTION      ")
      CALL USTPUT(05,"USRT:SRTQxx: B.C. -1          ")
      CALL USTPUT(06,"USRT:SRTQxx: COLLISION        ")
      CALL USTPUT(07,"USRT:SRTQxx: TRANSLATION      ")
      CALL USTPUT(08,"USRT:SRTQxx: B.C. -2          ")
      CALL USTPUT(11,"USRT:SETBND                   ")
      CALL USTPUT(12,"USRT:SETBND-01                ")
      CALL USTPUT(13,"USRT:SETBND-02                ")
      CALL USTPUT(14,"USRT:SETBND-03                ")
      CALL USTPUT(15,"USRT:SETBND-04                ")
      CALL USTPUT(21,"USRT:CHKFLW                   ")
      CALL USTPUT(22,"USRT:SETDIF                   ")
      CALL USTPUT(23,"USRT:MAKEBC                   ")
      CALL USTPUT(24,"USRT:MKINTR                   ")
      CALL USTPUT(25,"USRT:MKINTR:01                ")
      CALL USTPUT(26,"USRT:MKINTR:02                ")
      CALL USTPUT(27,"USRT:MKINTR:03                ")
      CALL USTPUT(28,"USRT:MKINTR:04                ")
      CALL USTPUT(29,"USRT:MKINTR:05                ")
      CALL USTPUT(32,"USRT:MRTLBM:                  ")
      CALL USTPUT(33,"USRT:MRTLBM: MACRO VARIABLE   ")
      CALL USTPUT(34,"USRT:MRTLBM: E.-FUNCTION      ")
      CALL USTPUT(35,"USRT:MRTLBM: B.C. -1          ")
      CALL USTPUT(36,"USRT:MRTLBM: COLLISION        ")
      CALL USTPUT(37,"USRT:MRTLBM: TRANSLATION      ")
      CALL USTPUT(38,"USRT:MRTLBM: B.C. -2          ")
C
      IF(IPART.GE.1) THEN
          IUT6 = IUTLG
          CALL MFNAME(FILELG,FILE,IPART,IUT0,IERR)
          OPEN(IUT6,FILE=FILE,FORM='FORMATTED')
      ENDIF
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) DATE
      WRITE(IUT6,*) '          ** RUNNING IN ', MODE(NDOM), ' MODE'
C
      WRITE(IUT6,*) 'IPART',IPART
      WRITE(IUT6,*) 'NPART',NPART
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: READING PARAMETER FILE ** '
      OPEN(IUTIN,FILE=FILEIN,FORM='FORMATTED')
      CALL LBMPRM(IUTIN,IUT6,IPART,ISTART,NTIME,
     *            DSCALE,VSCALE,VISCM,RHO0,IOUT,INTFSV,
     *            MSAMPL,NSAMPL,LSAMPL,
     *            XSAMPL,YSAMPL,ZSAMPL,
     *            FILECB,FILEBC,FILEIF,FILEFF,FILEVF,
     *            FILEAV,FILERM,FILEFS,FILEHS,IUT0,IERR)
      IF(IERR.NE.0) GOTO 9999
      IF(INTFSV.LE.0) INTFSV = NTIME+1
      INTPRN = MAX(1,NTIME/MAXPRN)
      WRITE(IUT6,*) ' DONE!'
C     
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: READING OPTION PARAMETER ** '
      CALL LBMROP(IUT0,IUTIN,IUT6,IERR,VSCALE,
     *            UINLT,VINLT,WINLT,UWALL,VWALL,WWALL,
     *            JCHGEO,MTFIX,NTFIX,LTFIX,TAUFIX,
     *            NCHKFL,RHOSTP,NFLINT,JBOUN,LBTYPE,
     *            JGEOM,FILEGM,MPG,HBOUN,IMODEL,CS,TAUMIN,
     *            IWMODE,TAINLT,TAFREE,ICOLLI,FILETR,
     *            DGEOM,IRFNF,MPBR,IWFUNC,IMODQ,EPSTRG,NP,ICALSS,
     *            IINLTV,DBLAS,ICNSTD,
     *            IWRTSF,INTSRF,IMVTRG,DTRG,FILESF,
     *            MBLK,NBLK,NUMBLK,INTBLK,CORBLK,FILBLK,
     *            JDUMP,PARDMP,JVISC,PARVIS,TAUTGT)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          GO TO 9999
      ENDIF
      CLOSE(IUTIN)
C
      IF(ICOLLI.EQ.2 .AND. NP.EQ.27) THEN
          WRITE(IUT6,*) 'MRT DO NOT SUPPORT NP=27 MODE: STOP' 
          GOTO 9999
      ENDIF
C
      IF(IINLTV.NE.0 .AND. NP.NE.27) THEN
          WRITE(IUT6,*) 'BLASIUS IS AVALABLE ONLY FOR SRT-D3Q27: STOP' 
          GOTO 9999
      ENDIF
C
      ALLOCATE(LVEL(3,NP),STAT=LERR(01))
      ALLOCATE(LREV(3,NP),STAT=LERR(02))
      ALLOCATE(CVEL(3,NP),STAT=LERR(03))
      ALLOCATE(WF  (  NP),STAT=LERR(04))
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: SET VELOCITY PARTICLES ** '
      CALL PARTCL(NP,LVEL,CVEL,LREV,WF)
      WRITE(IUT6,*) ' DONE!'
C
C
C
C
      ALLOCATE(LLEVEL(      MC),STAT=LERR(01))
      ALLOCATE(LPOSI (    3,MC),STAT=LERR(02))
      ALLOCATE(NBC   (      MC),STAT=LERR(03))
      ALLOCATE(LBC   (5,MBC,MC),STAT=LERR(04))
      ALLOCATE(LCBOUN(    4,MC),STAT=LERR(05))
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: CHECKING CUBE SIZE ** '
      IMODE=0
      CALL GFCUBE(IMODE,MC,MBC,FILECB,
     *            NG,NC,LLEVEL,LPOSI,NBC,LBC,
     *            MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *            IUT6,IUT0,IUTCB,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          GO TO 9999
      ENDIF
      DEALLOCATE(LLEVEL)
      DEALLOCATE(LPOSI )
      DEALLOCATE(NBC   )
      DEALLOCATE(LBC   )
      WRITE(IUT6,*) 'NUMBER OF CUBES SIZE :NC', NC
      WRITE(IUT6,*) 'CUBE SIZE            :NG', NG
      TAU0= 0.5D0+3.0D0*VISCM*(VSCALE/DSCALE)*DBLE(NG)
      MPBOUN0=6*NP*(NG+1)*(NG+1)
      WRITE(IUT6,*) 'TAU0                 :  ',TAU0
      IF(IERR.NE.0) GOTO 9999
      WRITE(IUT6,*) ' DONE!'
C
      IF(JBOUN.EQ.1) THEN
          MPBOUN=1
          ALLOCATE(NPBOUN(         NC),STAT=IERR)
          ALLOCATE(LPBOUN(5,MPBOUN,NC),STAT=IERR)
          ALLOCATE( QBOUN(  MPBOUN,NC),STAT=IERR)
          IMODE=0
          CALL GFBOUN(IMODE,MC,MPBOUN,FILEBC,
     *                NG,NC,NPBOUN,LPBOUN,QBOUN,
     *                MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *                IUT6,IUT0,IUTBC,IERR)
          WRITE(IUT6,*) 'NUMBER OF MAX. B.P. : MPBOUN', MPBOUN
          IF(MPBOUN.EQ.0) MPBOUN=1
          DEALLOCATE(NPBOUN)
          DEALLOCATE(LPBOUN)
          DEALLOCATE( QBOUN)
      ELSE IF(JBOUN.EQ.2) THEN
          MPBOUN=MPBOUN0
          IF(MPBR.GT.0) MPBOUN=MPBR
      ENDIF
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: ALLOCATING VARIABLES ** '
      SIZEAL = 0.E0
C
C A. VARIABLE DEFINED AT CUBES
      ALLOCATE(LLEVEL(   NC),STAT=LERR(01))
      ALLOCATE(LPOSI ( 3,NC),STAT=LERR(02))
      SIZE   = 4*NC*0.5*WORD
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " CUBE      :",SIZE
C
C B. VARIABLE REGARDING GEOMETRY
      ALLOCATE(NPBOUN(         NC),STAT=LERR(03))
      ALLOCATE(LPBOUN(5,MPBOUN,NC),STAT=LERR(04))
      ALLOCATE( QBOUN(  MPBOUN,NC),STAT=LERR(05))
      SIZE   = (1+5*MPBOUN)*NC*0.5*WORD+MPBOUN*NC*WORD
      SIZEAL = SIZEAL+SIZE
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " INTERSETC :",SIZE
C
C C. VARIABLE DEFINED AT GRIDS
      ALLOCATE(MASK(   0:NG+2,0:NG+2,0:NG+2   ,2 ),STAT=LERR(06))
      ALLOCATE(F   (   0:NG+2,0:NG+2,0:NG+2,NP,NC),STAT=LERR(07))
      ALLOCATE(CDUMP(  0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(07))
      ALLOCATE(FDUMP(                       NP   ),STAT=LERR(07))
      ALLOCATE(CVISC(  0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(07))
      ALLOCATE(TAU (   0:NG+2,0:NG+2,0:NG+2   ,NC),STAT=LERR(08))
      ALLOCATE(FWRK(   0:NG+2,0:NG+2,0:NG+2,NP   ),STAT=LERR(09))
      ALLOCATE(FWRK2(  0:NG+2,0:NG+2,0:NG+2,NP   ),STAT=LERR(10))
      ALLOCATE(V3D ( 4,0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(11))
      ALLOCATE(V1  (   0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(12))
      ALLOCATE(V2  (   0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(13))
      ALLOCATE(V3  (   0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(14))
      ALLOCATE(V4  (   0:NG+2,0:NG+2,0:NG+2      ),STAT=LERR(15))
      NG3=(NG+3)*(NG+3)*(NG+3)
      ALLOCATE(WRK1(NG3),STAT=LERR(16))
      ALLOCATE(WRK2(NG3),STAT=LERR(17))
      ALLOCATE(WRK3(NG3),STAT=LERR(18))
      ALLOCATE(WRK4(NG3),STAT=LERR(19))
      SIZE =        (NP+2)*NG3*NC*WORD
      SIZE = SIZE + (NP+8)*NG3   *WORD
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " GRIDS     :",SIZE
C
C D. VARIABLE FOR BOUNDARY 
      ALLOCATE(LWORK1(0:NG+2,0:NG+2,0:NG+2)   ,STAT=LERR(20))
      ALLOCATE(LWORK2(  NG+1,  NG+1,  NG+1)   ,STAT=LERR(21))
      ALLOCATE(LWORK(NP,NG+1,NG+1,NG+1)       ,STAT=LERR(22))
      IF(NP.EQ.15) THEN
          M1CELL=7
      ELSE IF(NP.EQ.27) THEN
          M1CELL=13
      ENDIF
      IF(JGEOM.EQ.0) THEN
          ALLOCATE(XP(1)                     ,STAT=LERR(23))
          ALLOCATE(YP(1)                     ,STAT=LERR(24))
          ALLOCATE(ZP(1)                     ,STAT=LERR(25))
          ALLOCATE(XTRG(1,1)                 ,STAT=LERR(26))
          ALLOCATE(YTRG(1,1)                 ,STAT=LERR(27))
          ALLOCATE(ZTRG(1,1)                 ,STAT=LERR(28))
          ALLOCATE(QCELL(M1CELL,0:1,0:1,0:1) ,STAT=LERR(29))
          ALLOCATE(LSURF(1,1,1)              ,STAT=LERR(31))
          ALLOCATE(LPSURF(1,1)               ,STAT=LERR(32))
          ALLOCATE(CSURF(1,1,1)              ,STAT=LERR(33))
          ALLOCATE(RHOSRF(1)                 ,STAT=LERR(34))
      ELSE IF(JGEOM.EQ.1) THEN
          ALLOCATE(XP(MPG)                            ,STAT=LERR(23))
          ALLOCATE(YP(MPG)                            ,STAT=LERR(24))
          ALLOCATE(ZP(MPG)                            ,STAT=LERR(25))
          ALLOCATE(XTRG(1,1)                          ,STAT=LERR(26))
          ALLOCATE(YTRG(1,1)                          ,STAT=LERR(27))
          ALLOCATE(ZTRG(1,1)                          ,STAT=LERR(28))
          ALLOCATE(QCELL (M1CELL,0:NG+1,0:NG+1,0:NG+1),STAT=LERR(29))
          ALLOCATE(LSURF(1,1,1)                       ,STAT=LERR(31))
          ALLOCATE(LPSURF(1,1)                        ,STAT=LERR(32))
          ALLOCATE(CSURF(1,1,1)                       ,STAT=LERR(33))
          ALLOCATE(RHOSRF(1)                          ,STAT=LERR(34))
      ELSE IF(JGEOM.EQ.2) THEN
          ALLOCATE(XP(1)                              ,STAT=LERR(23))
          ALLOCATE(YP(1)                              ,STAT=LERR(24))
          ALLOCATE(ZP(1)                              ,STAT=LERR(25))
          ALLOCATE(XTRG(MPG,3)                        ,STAT=LERR(26))
          ALLOCATE(YTRG(MPG,3)                        ,STAT=LERR(27))
          ALLOCATE(ZTRG(MPG,3)                        ,STAT=LERR(28))
          ALLOCATE(QCELL (M1CELL,0:NG+1,0:NG+1,0:NG+1),STAT=LERR(29))
          ALLOCATE(LSURF(4,MPG,2)                     ,STAT=LERR(31))
          ALLOCATE(LPSURF(MPG,2)                      ,STAT=LERR(32))
          ALLOCATE(CSURF(3,MPG,2)                     ,STAT=LERR(33))
          ALLOCATE(RHOSRF(MPG)                        ,STAT=LERR(34))
      ENDIF
      SIZE =        (2+NP)*NG3*WORD
      SIZE = SIZE +     12*MPG*WORD
      SIZE = SIZE +     14*NG3*WORD
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " BOUN.     :",SIZE
C
C D. VARIABLES FOR INTER CUBE COMMUNICATION
      ALLOCATE(NBC  (                  NC),STAT=LERR(35))
      ALLOCATE(LBC  (5,MBC            ,NC),STAT=LERR(36))
      ALLOCATE(FBC1 (NP,NG+1,NG+1,MBC1,NC),STAT=LERR(37))
      ALLOCATE(FBC2 (NP,NG+1,     MBC2,NC),STAT=LERR(38))
      ALLOCATE(FBC3 (NP,          MBC3,NC),STAT=LERR(39))
      ALLOCATE(FBC1W(NP,NG+1,NG+1,MBC1,NC),STAT=LERR(40))
      ALLOCATE(FBC2W(NP,NG+1,     MBC2,NC),STAT=LERR(41))
      ALLOCATE(FBC3W(NP,          MBC3,NC),STAT=LERR(42))
      SIZE = (1+5*MBC)*NC*0.5*WORD
      SIZE = SIZE + 2*NP*(NG+1)*(NG+1)*MBC1*NC*0.2*WORD
      SIZE = SIZE + 2*NP*(NG+1)       *MBC2*NC*0.2*WORD
      SIZE = SIZE + 2*NP              *MBC3*NC*0.2*WORD
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " CUBE COMM.:",SIZE
C
C E. VARIABLES FOR FLUID FORCES
C
      ALLOCATE(FXC  (    NC),STAT=LERR(43))
      ALLOCATE(FYC  (    NC),STAT=LERR(44))
      ALLOCATE(FZC  (    NC),STAT=LERR(45))
      ALLOCATE(FXWRK(MPBOUN),STAT=LERR(46))
      ALLOCATE(FYWRK(MPBOUN),STAT=LERR(47))
      ALLOCATE(FZWRK(MPBOUN),STAT=LERR(48))
      DO IC=1,NC
          FXC(IC)=0.0D0
          FYC(IC)=0.0D0
          FZC(IC)=0.0D0
      ENDDO
C
      CALL ERRCHK(IUT6,IPART,48,LERR,IERR)
      IF(IERR.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          WRITE(IUT6,*) EREXP1
          GO TO 9999
      ENDIF
      WRITE(IUT6,*) ' DONE!'
C
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: READING CUBE FILE ** '
      IMODE=1
      CALL GFCUBE(IMODE,MC,MBC,FILECB,
     *            NG,NC,LLEVEL,LPOSI,NBC,LBC,
     *            MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *            IUT6,IUT0,IUTCB,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          GO TO 9999
      ENDIF
      WRITE(IUT6,*) ' DONE!'
C
      DO 100 IC=1, NC
          WRITE(IUT6,*) 
          WRITE(IUT6,'(A24,12I6)') 
     *     'CUBE-ID              :',IC
          WRITE(IUT6,'(A24,12I6)') 
     *     'LLEVEL               :',LLEVEL(IC)
          WRITE(IUT6,'(A24,12I6)')
     *     'LPOSI                :',LPOSI(1,IC),LPOSI(2,IC),LPOSI(3,IC)
          WRITE(IUT6,'(A24,12I6)') 
     *     'NBC                 :',NBC(IC)
          DO 110 IBC=1, NBC(IC)
              WRITE(IUT6,'(A24,12I6)') 
     *         'LBC                 :',IBC,(LBC(II,IBC,IC),II=1,5)
  110     CONTINUE
  100 CONTINUE
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: FINDING SAMPLING POINT ** '
      CALL FNDCUB(NG,NC,LLEVEL,LPOSI,DSCALE,
     *            MSAMPL,NSAMPL,XSAMPL,YSAMPL,ZSAMPL,LSAMPL,CSAMPL,
     *            MRESV,LHIST,COMHST,IUT6)
      WRITE(IUT6,*) '  NUM OF FOUND SAMPLING POINTS :: ', NSAMPL
      WRITE(IUT6,*) ' DONE!'
C
      NHIST=MRESV+NSAMPL
      ALLOCATE( HIST(MSAMPL,NTIME),STAT=LERR(1))
      SIZE = MSAMPL*NTIME*0.5*WORD
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " HISTORY    :",SIZE
      DO J=1,NTIME 
      DO I=1,MSAMPL
          HIST(I,J)=0.0E0
      ENDDO
      ENDDO
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: SET INITIAL CONDITION ** '
      CALL LBMINI(ISTART,ICOLLI,IRFNF,
     *            NC,NG,NG3,RHO0,VSCALE,FILEIF,
     *            NP,CVEL,WF,NTIME0,TIME,F,FWRK,V3D,
     *            MPBOUN,NPBOUN,LPBOUN,
     *            MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *            WRK1,WRK2,WRK3,WRK4,
     *            IUT6,IUT0,IUTFF,IERR)
      WRITE(IUT6,*) ' DONE!'
C
      IF(JBOUN.EQ.1) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: READING B.C. FILE ** '
          IMODE=1
          CALL GFBOUN(IMODE,MC,MPBOUN,FILEBC,
     *                NG,NC,NPBOUN,LPBOUN,QBOUN,
     *                MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *                IUT6,IUT0,IUTBC,IERR)
          CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
          IF(IERRA.NE.0) THEN
              WRITE(IUT6,*) BLANK
              WRITE(IUT6,*) ERRMSG
              GO TO 9999
          ENDIF
          WRITE(IUT6,*) ' DONE!'
      ELSE IF(JBOUN.EQ.2) THEN
          IACT=1
          IF(JGEOM.EQ.1) THEN
              WRITE(IUT6,*) BLANK
              WRITE(IUT6,*) ' ** LBM3D: READING GEOM FILE ** '
              CALL GFALL(IUT0,IUT6,IUTGM,FILEGM,
     *                   MCOM,NCOMFL,COMFLE,
     *                   MCOM,NCOMST,COMSET,
     *                   IACT,IWRITE,INAME,IRESV,
     *                   ICAST,IDATA0,IALL,ISKIP,IERR,
     *                   '*GRID_3D  !',
     *                   NAME,MPG,NPG,XP,YP,ZP,ICHECK)
              IF(IERR.NE.0) GOTO 9999
              WRITE(IUT6,*) ' DONE!'
          ELSE IF(JGEOM.EQ.2) THEN
              IF(IPART.GE.1) THEN
                  CALL MFNAME(FILETR,FILE,IPART,IUT0,IERR)
                  FILETR=FILE
              ENDIF
              WRITE(IUT6,*) BLANK
              WRITE(IUT6,*) ' ** LBM3D: READING TRG FILE ** '
              CALL GFALL(IUT0,IUT6,IUTST,FILETR,
     *                   MCOM,NCOMFL,COMFLE,
     *                   MCOM,NCOMST,COMSET,
     *                   IACT,IWRITE,INAME,IRESV,
     *                   ICAST,IDATA0,IALL,ISKIP,IERR,
     *                   '*GRID_3D  !',
     *                   NAME,MPG,NPTRG,XTRG,YTRG,ZTRG,ICHECK)
              IF(IERR.NE.0) GOTO 9999
              WRITE(IUT6,*) ' DONE!'
          ENDIF
C
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: MAKING B.C. DATA ** '
          CALL USTSTA(23)
          CALL MAKEBC(JGEOM,NP,NG,NC,M1CELL,LBTYPE,LVEL,LREV,
     *                MBC,LLEVEL,LPOSI,NBC,LBC,
     *                MPBOUN,NPBOUN,LPBOUN,QBOUN,
     *                LWORK1,LWORK2,LWORK,
     *                NPG,DSCALE,XP,YP,ZP,QCELL,
     *                NPTRG,XTRG,YTRG,ZTRG,IMODQ,EPSTRG,
     *                IUT6,IUT0,IERR)
          CALL USTEND(23)
          CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
          IF(IERRA.NE.0) THEN
              WRITE(IUT6,*) BLANK
              WRITE(IUT6,*) ERRMSG
              WRITE(IUT6,*) EREXP4
              GO TO 9999
          ENDIF
          WRITE(IUT6,*) ' DONE!'
C
          IF(IWRTSF.EQ.1) THEN
              WRITE(IUT6,*) BLANK
              WRITE(IUT6,*) ' ** LBM3D: FINDING SURFACE POINT ** '
C
              DO IP=1,NPTRG
                  XTRG(IP,2)=XTRG(IP,1) 
                  YTRG(IP,2)=YTRG(IP,1) 
                  ZTRG(IP,2)=ZTRG(IP,1) 
                  XTRG(IP,3)=XTRG(IP,1) 
                  YTRG(IP,3)=YTRG(IP,1) 
                  ZTRG(IP,3)=ZTRG(IP,1) 
              ENDDO
C
              BUF=DTRG
              CALL MVTRIG(NG,NPTRG,DSCALE,BUF,
     *                    XTRG(1,2),YTRG(1,2),ZTRG(1,2))
              CALL FNDSRF(NG,NC,LLEVEL,LPOSI,DSCALE,
     *                    NPTRG,XTRG(1,2),YTRG(1,2),ZTRG(1,2),
     *                    MPG,NPSURF(1),LSURF(1,1,1),LPSURF(1,1),
     *                    CSURF(1,1,1),IUT6)
C
              BUF=-DTRG
              CALL MVTRIG(NG,NPTRG,DSCALE,BUF,
     *                    XTRG(1,3),YTRG(1,3),ZTRG(1,3))
              CALL FNDSRF(NG,NC,LLEVEL,LPOSI,DSCALE,
     *                    NPTRG,XTRG(1,3),YTRG(1,3),ZTRG(1,3),
     *                    MPG,NPSURF(2),LSURF(1,1,2),LPSURF(1,2),
     *                    CSURF(1,1,2),IUT6)
C
              CALL CHKSRF(MPG,NPSURF,LSURF,LPSURF,CSURF,JSURF)
C
          WRITE(IUT6,*) ' JSURF                        :: ', JSURF
          WRITE(IUT6,*) ' NUM OF FOUND SURFACE POINTS-1:: ', NPSURF(1)
          WRITE(IUT6,*) ' NUM OF FOUND SURFACE POINTS-2:: ', NPSURF(2)
          WRITE(IUT6,*) ' DONE!'
          ENDIF
C
      ENDIF
C
      IF(NBLK.GT.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: FINDING BLOCK POINT ** '
          IMODE=0
          MPBLK=1
          DO IBLK=1,NBLK
              CALL FNDBLK(IMODE,NG,NC,LLEVEL,LPOSI,DSCALE,
     *                    NPBLK(IBLK),NUMBLK(1,IBLK),CORBLK(1,IBLK),
     *                    MPBLK,LDUM,LDUM,LDUM,DUM,IUT6)
              MPBLK=MAX(MPBLK,NPBLK(IBLK))
              WRITE(IUT6,'(A35,2I8)') 
     *        ' NUM OF FOUND BLOCK POINTS  :: ',IBLK,NPBLK(IBLK)
          ENDDO
C
          ALLOCATE(LCBLK (  MPBLK,MBLK))
          ALLOCATE(LPBLK1(3,MPBLK,MBLK))
          ALLOCATE(LPBLK2(3,MPBLK,MBLK))
          ALLOCATE(COEBLK(3,MPBLK,MBLK))
          ALLOCATE(RHOBLK(  MPBLK))
          ALLOCATE(  UBLK(  MPBLK))
          ALLOCATE(  VBLK(  MPBLK))
          ALLOCATE(  WBLK(  MPBLK))
C
          IMODE=1
          DO IBLK=1,NBLK
              CALL FNDBLK(IMODE,NG,NC,LLEVEL,LPOSI,DSCALE,
     *                    NPBLK(IBLK),NUMBLK(1,IBLK),CORBLK(1,IBLK),
     *                    MPBLK,LCBLK(1,IBLK),LPBLK1(1,1,IBLK),
     *                    LPBLK2(1,1,IBLK),COEBLK(1,1,IBLK),DUM,IUT6)
          ENDDO
C
          WRITE(IUT6,*) ' DONE!'
      ENDIF
C
      CALL CHKCBC(NC,MPBOUN,NPBOUN,LPBOUN,LCBOUN)
C
      IF(JCHGEO.EQ.1) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: GEOM. CHECK MODE ** '
          IMODE=2
          CALL GFFLW3(IMODE,FILEFF,
     *                NG,NC,NP,NTIME,CVEL,VSCALE,TIME,V3D,
     *                MPBOUN,NPBOUN,LPBOUN,
     *                MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *                IUT6,IUT0,IUTFF,IERR,
     *                NG3,WRK1,WRK2,WRK3,WRK4)
          GOTO 8888
      ENDIF
C
C
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: MAKE ADJACENT DOMAIN LIST  ** '
C
      ALLOCATE(LDOM  (MDOM),STAT=LERR(1))
      ALLOCATE(NBPRCV(MDOM),STAT=LERR(2))
      ALLOCATE(NBPSND(MDOM),STAT=LERR(3))
      CALL ERRCHK(IUT6,IPART,3,LERR,IERR)
      IF(IERR.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          WRITE(IUT6,*) EREXP1
          GO TO 9999
      ENDIF
C
      LERR(1)=0
      CALL DDCOM0(IPART,MBC,MDOM,NC,NBC,LBC,NDOM,LDOM,LERR)
      WRITE(IUT6,*) 'NDOM',NDOM
      CALL ERRCHK(IUT6,IPART,1,LERR,IERR)
      IF(IERR.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          WRITE(IUT6,*) EREXP3
          GO TO 9999
      ENDIF
      IF(NDOM.GT.0) THEN
          WRITE(IUT6,*) 'LDOM'
          WRITE(IUT6,'(5I8)') (LDOM(IDOM),IDOM=1,NDOM)
      ENDIF
C
      CALL CNTCOM(IPART,NG,NP,NC,MBC,NBC,LBC,
     *            MPB,NDOM,LDOM,NBPSND,NBPRCV,IUT6)
      WRITE(IUT6,*) 'MPB',MPB
      WRITE(IUT6,*) 'MDOM',MDOM
C
      IF(IPART.EQ.0) THEN
          ALLOCATE(BUFRCV(MPB,1),STAT=LERR(1))
          ALLOCATE(BUFSND(MPB,1),STAT=LERR(2))
          SIZE = 2*MPB*WORD
      ELSE
          ALLOCATE(BUFRCV(MPB,NDOM),STAT=LERR(1))
          ALLOCATE(BUFSND(MPB,NDOM),STAT=LERR(2))
          SIZE = 2*MPB*NDOM*WORD
      ENDIF  
      SIZEAL = SIZEAL+SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " COM. BUF.  :",SIZE
      WRITE(IUT6,'(A12,F8.2," MB ALLOCATED")') " TOTAL      :",SIZEAL
      CALL ERRCHK(IUT6,IPART,2,LERR,IERR)
      IF(IERR.NE.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ERRMSG
          WRITE(IUT6,*) EREXP1
          GO TO 9999
      ENDIF
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: SET B.C.  ** '
      ITIME=0
      CALL SETBND(ITIME,IPART,NP,LVEL,NG,NC,MBC,MBC1,MBC2,MBC3,
     *            NBC,LLEVEL,LBC,MPBOUN,NPBOUN,LPBOUN,F,FWRK,
     *            VISCM,DSCALE,VSCALE,CVEL,WF,
     *            MDOM,MPB,NDOM,LDOM,NBPSND,NBPRCV,
     *            BUFSND,BUFRCV,
     *            FBC1,FBC1W,FBC2,FBC2W,FBC3,FBC3W,
     *            IUT6,IUT0,IERR)
      IF(IERR.NE.0) GOTO 9999
C
      IF(INTFSV.LE.NTIME) THEN
          IMODE=4
          CALL GFFLW2(IMODE,FILEFS,
     *                NG,NC,NP,NSTEP,CVEL,VSCALE,TIME,V3D,F,
     *                MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *                IUT6,IUT0,IUTFS,IERR,
     *                NG3,WRK1,WRK2,WRK3,WRK4)
      ENDIF
C
      IF(IWRTSF.EQ.1 .AND. NPSURF(1).GT.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: WRITING GF-SURF FILE  ** '
          IF(IPART.GE.1) THEN
              CALL MFNAME(FILESF,FILE,IPART,IUT0,IERR)
              FILESF=FILE
          ENDIF
C
          IACT=4            
          CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *               MCOM,NCOMFL,COMFLE,
     *               MCOM,NCOMST,COMSET,
     *               IACT,IWRITE,INAME,IRESV,  
     *               ICAST,IDATA0,IALL,ISKIP,IERR,
     *               '  !',
     *               ICHECK)     
C
          IACT=6            
          CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *               MCOM,NCOMFL,COMFLE,
     *               MCOM,NCOMST,COMSET,
     *               IACT,IWRITE,INAME,IRESV,  
     *               ICAST,IDATA0,IALL,ISKIP,IERR,
     *               '*PT_NODE !',
     *               NAME,MPG,NPSURF(1),LPSURF(1,1),
     *               ICHECK)     
          CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *               MCOM,NCOMFL,COMFLE,
     *               MCOM,NCOMST,COMSET,
     *               IACT,IWRITE,INAME,IRESV,  
     *               ICAST,IDATA0,IALL,ISKIP,IERR,
     *               '*PT_NODE !',
     *               NAME,MPG,NPSURF(2),LPSURF(1,2),
     *               ICHECK)     
          WRITE(IUT6,*) ' DONE!'
C
      ENDIF
C
      IF(NBLK.GT.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: WRITING GF-BLOCK FILE  ** '
C
          DO IBLK=1,NBLK 
              IF(NPBLK(IBLK).GT.0) THEN
                  IF(IPART.GE.1) THEN
                      CALL MFNAME(FILBLK(IBLK),FILE,IPART,IUT0,IERR)
                      FILBLK(IBLK)=FILE
                  ENDIF
C
                  IACT=4
                  IUTBLK=IUTBL0+IBLK
                  CALL GFALL(IUT0,IUT6,IUTBLK,FILBLK(IBLK),
     *                       MCOM,NCOMFL,COMFLE,
     *                       MCOM,NCOMST,COMSET,
     *                       IACT,IWRITE,INAME,IRESV,  
     *                       ICAST,IDATA0,IALL,ISKIP,IERR,
     *                       '  !', ICHECK)     
C
                  IACT=6
                  NPBLK3=NPBLK(IBLK)*3
                  IF(IPART.GT.0) THEN
                  CALL GFALL(IUT0,IUT6,IUTBLK,FILBLK(IBLK),
     *                       MCOM,NCOMFL,COMFLE,
     *                       MCOM,NCOMST,COMSET,
     *                       IACT,IWRITE,INAME,IRESV,  
     *                       ICAST,IDATA0,IALL,ISKIP,IERR,
     *                       '*PT_NODE !',
     *                       NAME,NPBLK3,NPBLK3,LPBLK2(1,1,IBLK),
     *                       ICHECK)     
                  ENDIF 
              ENDIF   
          ENDDO
          WRITE(IUT6,*) ' DONE!'
      ENDIF
C
      IF(JDUMP.EQ.0) CDUMP=0.0D0
      IF(JVISC.EQ.0) CVISC=0.0D0
      IF(JDUMP.NE.0) CALL TGTTAU(JDUMP,NP,WF,CVEL,PARDMP,FDUMP)    
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: TIME-LOOP START ** '
      CALL USTSTA(01)
      DO 1000 ITIME=1,NTIME
          TIME=TIME+(VSCALE*DSCALE)/DBLE(NG)
          IF(MOD(ITIME,NCHKFL).EQ.0) THEN
              RHOMAX=0.0D0
              VELMAX=0.0D0
          ENDIF
          IERR=0
          DO 1100 IC=1,NC  
              NINT=2**(LLEVEL(IC)-1)
              IF(MOD(ITIME-1,NINT).NE.0) GOTO 1110     
C
              CALL SETMSK(NG,MASK,MBC,NBC(IC),LBC(1,1,IC))
C
C
              IF(JVISC.GE.1) THEN
                  CALL SETRGN(JVISC,NG,NP,LPOSI(1,IC),LLEVEL(IC),
     *                        DSCALE,PARVIS,CVISC)
              ENDIF
C
              CALL SETDIF(IMODEL,ICALSS,NG,NP,LLEVEL(IC),VISCM,
     *                    CS,TAUMIN,WF,CVEL,
     *                    DSCALE,VSCALE,F(0,0,0,1,IC),TAU(0,0,0,IC),
     *                    LPOSI(1,IC),NTFIX,LTFIX,TAUFIX,
     *                    LCBOUN(1,IC),TAINLT,TAFREE,V3D,FWRK,
     *                    CVISC,TAUTGT)
C
              IF(JDUMP.GE.1) THEN
                  CALL SETRGN(JDUMP,NG,NP,LPOSI(1,IC),LLEVEL(IC),
     *                        DSCALE,PARDMP,CDUMP)
              ENDIF
C
              IF(ICOLLI.EQ.1 .AND. NP.EQ.15) THEN  
                  CALL SRTQ15(NG,NG3,NP,LVEL,WF,CVEL,LREV,LLEVEL(IC),
     *                        F(0,0,0,1,IC),TAU(0,0,0,IC),FWRK,
     *                        MPBOUN,NPBOUN(IC),
     *                        LPBOUN(1,1,IC),QBOUN(1,IC),
     *                        UINLT,VINLT,WINLT,UWALL,VWALL,WWALL,
     *                        V1,V2,V3,V4,MASK,
     *                        FXC(IC),FYC(IC),FZC(IC),FXWRK,FYWRK,FZWRK,
     *                        JDUMP,FDUMP,CDUMP)
              ELSE IF(ICOLLI.EQ.1 .AND. NP.EQ.27) THEN  
                  CALL SRTQ27(NG,NG3,NP,LVEL,WF,CVEL,LREV,LLEVEL(IC),
     *                        LPOSI(1,IC),IINLTV,DSCALE,DBLAS,VISCM,
     *                        F(0,0,0,1,IC),TAU(0,0,0,IC),FWRK,
     *                        MPBOUN,NPBOUN(IC),
     *                        LPBOUN(1,1,IC),QBOUN(1,IC),
     *                        UINLT,VINLT,WINLT,UWALL,VWALL,WWALL,
     *                        V1,V2,V3,V4,MASK,
     *                        FXC(IC),FYC(IC),FZC(IC),FXWRK,FYWRK,FZWRK,
     *                        JDUMP,FDUMP,CDUMP)
              ELSE IF(ICOLLI.EQ.2) THEN
                  CALL MRTLBM(NG,NG3,NP,LVEL,WF,CVEL,LREV,LLEVEL(IC),
     *                        F(0,0,0,1,IC),TAU(0,0,0,IC),FWRK,FWRK2,
     *                        MPBOUN,NPBOUN(IC),
     *                        LPBOUN(1,1,IC),QBOUN(1,IC),
     *                        UINLT,VINLT,WINLT,UWALL,VWALL,WWALL,
     *                        V1,V2,V3,V4,MASK,
     *                        FXC(IC),FYC(IC),FZC(IC),FXWRK,FYWRK,FZWRK)
              ENDIF
 1110         CONTINUE   
              IF(MOD(ITIME,NCHKFL).EQ.0) THEN
                  CALL CHKFLW(NG,NG3,NP,CVEL,F(0,0,0,1,IC),BUF1,BUF2)
                  RHOMAX=MAX(RHOMAX,BUF1)
                  VELMAX=MAX(VELMAX,BUF2)
                  IF(RHOMAX.GT.RHOSTP) THEN
                      WRITE(IUT6,*) EREXP2 
                      IERR=1
                  ENDIF
              ENDIF 
C
 1100     CONTINUE   
C
          IF(MOD(ITIME,NCHKFL).EQ.0) THEN
              CALL ERCHK2(IUT6,IPART,1,IERR,IERRA)
              IF(IERRA.NE.0) THEN
                  WRITE(IUT6,*) BLANK
                  WRITE(IUT6,*) ERRMSG
                  JSTOP=1
                  GO TO 1010
              ENDIF
          ENDIF
C
          CALL SETBND(ITIME,IPART,NP,LVEL,NG,NC,MBC,MBC1,MBC2,MBC3,
     *                NBC,LLEVEL,LBC,MPBOUN,NPBOUN,LPBOUN,F,FWRK,
     *                VISCM,DSCALE,VSCALE,CVEL,WF,
     *                MDOM,MPB,NDOM,LDOM,NBPSND,NBPRCV,
     *                BUFSND,BUFRCV,
     *                FBC1,FBC1W,FBC2,FBC2W,FBC3,FBC3W,
     *                IUT6,IUT0,IERR)
C
          CALL FORCE3(NC,LLEVEL,FXC,FYC,FZC,FX,FY,FZ) 
C
          CALL SETHST(MSAMPL,MRESV,NSAMPL,LSAMPL,CSAMPL,NG,NC,NP,CVEL,F,
     *                TIME,RHOMAX,VELMAX,VSCALE,DSCALE,HIST(1,ITIME),
     *                FX,FY,FZ)
C
          IF(ITIME.GE.1 .AND. MOD(ITIME,INTPRN).EQ.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,9000) NTIME0+ITIME,TIME
          IF(MOD(ITIME,NCHKFL).EQ.0)
     *    WRITE(IUT6,9050) RHOMAX,VELMAX/VSCALE
C
          IF(JGEOM.GE.1) THEN
          COEFF = REAL(DSCALE)/(REAL(VSCALE)*REAL(NG))
          COEFF = COEFF*COEFF
          WRITE(IUT6,9060) FX*COEFF,FY*COEFF,FZ*COEFF
          ENDIF
C
          IF(NSAMPL.GE.1 .AND. NSAMPL.LE.3) THEN 
          WRITE(IUT6,9100)
     *    HIST(MRESV+1,ITIME),HIST(MRESV+2,ITIME),HIST(MRESV+3,ITIME)
          ENDIF 

          IF(NSAMPL.GE.4 .AND. NSAMPL.LE.6) THEN
          WRITE(IUT6,9100)
     *    HIST(MRESV+1,ITIME),HIST(MRESV+2,ITIME),HIST(MRESV+3,ITIME)
          WRITE(IUT6,9200)
     *    HIST(MRESV+4,ITIME),HIST(MRESV+5,ITIME),HIST(MRESV+6,ITIME)
          ENDIF 
C
          IF(NSAMPL.GE.7 ) THEN
          WRITE(IUT6,9100)
     *    HIST(MRESV+1,ITIME),HIST(MRESV+2,ITIME),HIST(MRESV+3,ITIME)
          WRITE(IUT6,9200)
     *    HIST(MRESV+4,ITIME),HIST(MRESV+5,ITIME),HIST(MRESV+6,ITIME)
          WRITE(IUT6,9300)
     *    HIST(MRESV+7,ITIME),HIST(MRESV+8,ITIME),HIST(MRESV+9,ITIME)
          ENDIF 
C
          ENDIF
C
          IF(ITIME.GE.1 .AND. MOD(ITIME,INTFSV).EQ.0) THEN
              DO 1200 IC=1,NC
              CALL EXTFNC(NG,NP,MBC,NBC(IC),LBC(1,1,IC),F(0,0,0,1,IC))
 1200         CONTINUE
              IMODE=6
              CALL GFFLW2(IMODE,FILEFS,
     *                    NG,NC,NP,ITIME,CVEL,VSCALE,TIME,V3D,F,
     *                    MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *                    IUT6,IUT0,IUTFS,IERR,
     *                    NG3,WRK1,WRK2,WRK3,WRK4)
          ENDIF
C
      IF(IWRTSF.EQ.1 .AND. NPSURF(1).GT.0 .AND. INTSRF.GT.0) THEN
      IF(MOD(ITIME,INTSRF).EQ.0) THEN
C
          DO 1210 IC=1,NC
          CALL EXTFNC(NG,NP,MBC,NBC(IC),LBC(1,1,IC),F(0,0,0,1,IC))
 1210     CONTINUE
C
          IACT=6            
          TIME4=REAL(TIME) 
C
          CALL SETSRF(NPSURF(1),LSURF(1,1,1),CSURF(1,1,1),
     *                NG,NC,NP,RHO0,VSCALE,F,RHOSRF)
          CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *               MCOM,NCOMFL,COMFLE,
     *               MCOM,NCOMST,COMSET,
     *               IACT,IWRITE,INAME,IRESV,  
     *               ICAST,IDATA0,IALL,ISKIP,IERR,
     *               '*TIME_PS *STEP_PS *LBM_RHO !',
     *               NAME,TIME4,
     *               NAME,ITIME,
     *               NAME,MPG,NPSURF(1),RHOSRF,
     *               ICHECK)     
C
          CALL SETSRF(NPSURF(2),LSURF(1,1,2),CSURF(1,1,2),
     *                NG,NC,NP,RHO0,VSCALE,F,RHOSRF)
          CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *               MCOM,NCOMFL,COMFLE,
     *               MCOM,NCOMST,COMSET,
     *               IACT,IWRITE,INAME,IRESV,  
     *               ICAST,IDATA0,IALL,ISKIP,IERR,
     *               '*TIME_PS *STEP_PS *LBM_RHO !',
     *               NAME,TIME4,
     *               NAME,ITIME,
     *               NAME,MPG,NPSURF(2),RHOSRF,
     *               ICHECK)     
C
      ENDIF
      ENDIF
C
      IF(NBLK.GT.0) THEN
          DO 1220 IC=1,NC
          CALL EXTFNC(NG,NP,MBC,NBC(IC),LBC(1,1,IC),F(0,0,0,1,IC))
 1220     CONTINUE
C
          DO IBLK=1,NBLK 
              IF(NPBLK(IBLK).GT.0) THEN
              IF(INTBLK(IBLK).NE.0) THEN
              IF(MOD(ITIME,INTBLK(IBLK)).EQ.0) THEN
C
                  CALL SETBLK(NP,NG,NC,CVEL,RHO0,VSCALE,F,NPBLK(IBLK),
     *                        LCBLK(1,IBLK),LPBLK1(1,1,IBLK),
     *                        COEBLK(1,1,IBLK),RHOBLK,UBLK,VBLK,WBLK)
C
                  IACT=6
                  IUTBLK=IUTBL0+IBLK
                  TIME4=REAL(TIME) 
                  CALL GFALL(IUT0,IUT6,IUTBLK,FILBLK(IBLK),
     *                   MCOM,NCOMFL,COMFLE,
     *                   MCOM,NCOMST,COMSET,
     *                   IACT,IWRITE,INAME,IRESV,  
     *                   ICAST,IDATA0,IALL,ISKIP,IERR,
     *                   ' *TIME_PS *STEP_PS *LBM_RHO *LBM_VEL !',
     *                   NAME,TIME4,
     *                   NAME,ITIME,
     *                   NAME,NPBLK(IBLK),NPBLK(IBLK),RHOBLK,
     *                   NAME,NPBLK(IBLK),NPBLK(IBLK),UBLK,VBLK,WBLK,
     *                   ICHECK)
              ENDIF
              ENDIF
              ENDIF
C
          ENDDO
      ENDIF
C
 1000 CONTINUE   
 1010 CONTINUE   
      CALL USTEND(01)
C
      WRITE(IUT6,*) ' ** LBM3D: TIME-LOOP END   ** '
C
      DO 1300 IC=1,NC
          CALL EXTFNC(NG,NP,MBC,NBC(IC),LBC(1,1,IC),F(0,0,0,1,IC))
 1300 CONTINUE
C
      IF(IWMODE.EQ.0) GOTO 2000
C     
      IF(INTFSV.LE.NTIME) THEN
          IMODE=8
          CALL GFFLW2(IMODE,FILEFS,
     *                NG,NC,NP,NSTEP,CVEL,VSCALE,TIME,V3D,F,
     *                MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *                IUT6,IUT0,IUTFS,IERR,
     *                NG3,WRK1,WRK2,WRK3,WRK4)
      ENDIF
C
      IF(IWFUNC.EQ.1) THEN
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: WRITING GF-FUNC FILE ** '
      IMODE=2
      NSTEP=NTIME0+NTIME
      CALL GFFUNC(IMODE,IRFNF,NC,FILEVF,
     *            NG,NC,NP,NSTEP,TIME,F,FWRK,
     *            MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *            IUT6,IUT0,IUTFF,IERR)
      WRITE(IUT6,*) ' DONE!'
      ENDIF
C
      WRITE(IUT6,*) ' ** LBM3D: WRITING GF-FLOW FILE ** '
      IMODE=2
      NSTEP=NTIME0+NTIME
      CALL GFFLW4(IMODE,FILEFF,
     *            NG,NC,NP,NSTEP,NFLINT,CVEL,VSCALE,TIME,V3D,F,
     *            MCOM,NCOMFL,NCOMST,COMFLE,COMSET,
     *            IUT6,IUT0,IUTFF,IERR,
     *            NG3,WRK1,WRK2,WRK3,WRK4)
      WRITE(IUT6,*) ' DONE!'
C
      WRITE(IUT6,*) ' ** LBM3D: WRITING GF-HIST FILE ** '
      IACT     = 2
      CALL GFALL(IUT0,IUT6,IUTHS,FILEHS,
     *           MCOM,0,COMFLE,
     *           MCOM,NHIST,COMHST,
     *           IACT,IWRITE,INAME,IRESV,  
     *           ICAST,IDATA0,IALL,ISKIP,IERR,
     *           '*HSTLIST *HISTORY  !',
     *           NAME,      MSAMPL,      NHIST,LHIST,
     *           NAME,NTIME,MSAMPL,NTIME,NHIST, HIST,
     *           ICHECK)     
      WRITE(IUT6,*) ' DONE!'
C
      IF(IWRTSF.EQ.1 .AND. NPSURF(1).GT.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: WRITING GF-SURF FILE  ** '
C
          IF(INTSRF.EQ.0) THEN 
              IACT=6            
              TIME4=REAL(TIME) 
              CALL SETSRF(NPSURF(1),LSURF(1,1,1),CSURF(1,1,1),
     *                    NG,NC,NP,RHO0,VSCALE,F,RHOSRF)
              CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *                   MCOM,NCOMFL,COMFLE,
     *                   MCOM,NCOMST,COMSET,
     *                   IACT,IWRITE,INAME,IRESV,  
     *                   ICAST,IDATA0,IALL,ISKIP,IERR,
     *                   '*TIME_PS *STEP_PS *LBM_RHO !',
     *                   NAME,TIME4,
     *                   NAME,NSTEP,
     *                   NAME,MPG,NPSURF(1),RHOSRF,
     *                   ICHECK)     
C
              CALL SETSRF(NPSURF(2),LSURF(1,1,2),CSURF(1,1,2),
     *                    NG,NC,NP,RHO0,VSCALE,F,RHOSRF)
              CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *                   MCOM,NCOMFL,COMFLE,
     *                   MCOM,NCOMST,COMSET,
     *                   IACT,IWRITE,INAME,IRESV,  
     *                   ICAST,IDATA0,IALL,ISKIP,IERR,
     *                   '*TIME_PS *STEP_PS *LBM_RHO !',
     *                   NAME,TIME4,
     *                   NAME,NSTEP,
     *                   NAME,MPG,NPSURF(2),RHOSRF,
     *                   ICHECK)     
          ENDIF  
C
          IACT=8            
          CALL GFALL(IUT0,IUT6,IUTSF,FILESF,
     *               MCOM,NCOMFL,COMFLE,
     *               MCOM,NCOMST,COMSET,
     *               IACT,IWRITE,INAME,IRESV,  
     *               ICAST,IDATA0,IALL,ISKIP,IERR,
     *               '  !',
     *               ICHECK)     
      ENDIF
C
      IF(NBLK.GT.0) THEN
          WRITE(IUT6,*) BLANK
          WRITE(IUT6,*) ' ** LBM3D: WRITING GF-BLOCK FILE  ** '
          DO IBLK=1,NBLK 
              IF(NPBLK(IBLK).GT.0) THEN
C
                  IF(INTBLK(IBLK).EQ.0) THEN 
                  CALL SETBLK(NP,NG,NC,CVEL,RHO0,VSCALE,F,NPBLK(IBLK),
     *                        LCBLK(1,IBLK),LPBLK1(1,1,IBLK),
     *                        COEBLK(1,1,IBLK),RHOBLK,UBLK,VBLK,WBLK)
C
                  IACT=6
                  IUTBLK=IUTBL0+IBLK
                  TIME4=REAL(TIME) 
                  CALL GFALL(IUT0,IUT6,IUTBLK,FILBLK(IBLK),
     *                   MCOM,NCOMFL,COMFLE,
     *                   MCOM,NCOMST,COMSET,
     *                   IACT,IWRITE,INAME,IRESV,  
     *                   ICAST,IDATA0,IALL,ISKIP,IERR,
     *                   ' *TIME_PS *STEP_PS *LBM_RHO *LBM_VEL !',
     *                   NAME,TIME4,
     *                   NAME,NSTEP,
     *                   NAME,NPBLK(IBLK),NPBLK(IBLK),RHOBLK,
     *                   NAME,NPBLK(IBLK),NPBLK(IBLK),UBLK,VBLK,WBLK,
     *                   ICHECK)
                  ENDIF 
C
                  IACT=8
                  IUTBLK=IUTBL0+IBLK
                  CALL GFALL(IUT0,IUT6,IUTBLK,FILBLK(IBLK),
     *                       MCOM,NCOMFL,COMFLE,
     *                       MCOM,NCOMST,COMSET,
     *                       IACT,IWRITE,INAME,IRESV,  
     *                       ICAST,IDATA0,IALL,ISKIP,IERR,
     *                       '  !', ICHECK)     
              ENDIF   
          ENDDO
          WRITE(IUT6,*) ' DONE!'
      ENDIF
C
 2000 CONTINUE
C     
#ifdef cputime
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) BLANK
      CALL USTWRT(IUT6)
#endif
C
 8888 CONTINUE
C
      WRITE(IUT6,*) BLANK
      IF(JSTOP.EQ.0) THEN
          WRITE(IUT6,*) ' ** LBM3D: SUCCESSFULLY TERMINATED **'
      ELSE
          WRITE(IUT6,*) ' ** LBM3D: TERMINATED **'
      ENDIF
C
      IF(IPART.GE.2) CLOSE(IUT6)
      CALL DDEXIT
      STOP
C
 9999 CONTINUE
C
      WRITE(IUT6,*) BLANK
      WRITE(IUT6,*) ' ** LBM3D: TERMINATED **' 
C
      IF(IPART.GE.1) CLOSE(IUT6)
      CALL DDEXIT
      STOP
C
 9000 FORMAT('  STEP=', I12     , ' TIME=', 1PE12.5)
 9050 FORMAT('  RMAX=', 1PE12.5 , ' VMAX=', 1PE12.5)
 9060 FORMAT('  FX  =', 1PE12.5 , ' FY  =', 1PE12.5 , ' FZ  =', 1PE12.5)
 9100 FORMAT('  HST1=', 1PE12.5 , ' HST2=', 1PE12.5 , ' HST3=', 1PE12.5)
 9200 FORMAT('  HST4=', 1PE12.5 , ' HST5=', 1PE12.5 , ' HST6=', 1PE12.5)
 9300 FORMAT('  HST7=', 1PE12.5 , ' HST8=', 1PE12.5 , ' HST9=', 1PE12.5)
C
      END
