C======================================================================C
C                                                                      C
C SOFTWARE NAME : FRONTFLOW_BLUE.1.0                                   C
C                                                                      C
C  SUB ROUTINE    DD_MPI                                               C
C                                                                      C
C                                       WRITTEN BY C.KATO              C
C                                                                      C
C                                                                      C
C Contact address: The University of Tokyo, FSIS project               C  
C                                                                      C
C======================================================================C
C
C      GENERIC TO MPI FORTRAN INTERFACE FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C                        AUTHOR: C. KATO, MERL, HITACHI, LTD.
C                        DATE FIRST WRITTEN : FEBRUARY 20TH, 1998 
C                        DATE       MODIFIED: APRIL    14TH, 2001
C                            (-PRECEXP OPTION IMPLEMENTED)
C                        DATE LAST  MODIFIED: MARCH     7TH, 2003
C                            (ENTRIES DDCOM1 AND DDCOM2 ADDED)
C
C
      SUBROUTINE DDINIT(NPART,IPART)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
C      INITIALIZE A PARALLEL TASK FOR DOMAIN-DECOMPOSITION PROGRAMMING
C     MODEL
C                            ( MPI VERSION )
C
C
C NOTE 1; THIS SUBROUTINE QUERIES THE TASK NUMBER (I.E. TASK ID) OF THE
C       CALLING TASK, THE NUMBER OF TASKS WHICH ARE SHARING THE PROGRAM
C       RUN. THE NUMBER OF SUB-DOMAINS AND THE SUB-DOMAIN NUMBER
C       THAT THE CALLING TASK SHOULD TAKE CARE OF, WILL BE RETURNED TO
C       THE CALLING TASK, AFTER BEING SET TO THE NUMBER OF TASKS, AND
C       THE TASK NUMBER PLUS ONE, RESPECTIVELY.
C
C NOTE 2; THE NUMBER OF TASKS TO SHARE A PARTICULAR RUN IS DETERMINED AT
C       RUN TIME BY THE PARALLEL ENVIRONMENT, WHILE THE NUMBER OF
C       SUB-DOMAINS IS THE SAME AS THE NUMBER OF SUB-DOMAIN FILES WHICH
C       HAVE BEEN PREPARED BEFORE THE RUN. THEREFORE, IN SOME CASES, 
C       THE NUMBER OF TASKS MIGHT DIFFER FROM THE ACTUAL NUMBER OF
C       SUB-DOMAINS, ALTHOUGH THEY MUST BE THE SAME TO RUN A MEANINGFUL
C       COMPUTATION. NOTE THAT THIS SUBROUTINE DOES NOT CHECK THE 
C       CONSISTENCY OF THESE VALUES.
C
C NOTE 3; A TASK NUMBER (I.E. TASK ID) IS A UNIQUE NUMBER FROM 0 TO ONE
C       MINUS THE TOTAL NUMBER OF TASKS, ASSIGNED BY THE SYSTEM AT RUN
C       TIME. THUS, THE SUB-DOMAIN NUMBER IS ALSO A UNIQUE NUMBER 
C       FROM 1 TO THE NUMBER OF SUB-DOMAINS.
C
C NOTE 4; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          ( NONE )
C
C       (2) OUTPUT
C INT *4   NPART       ; TOTAL NUMBER OF SUB-DOMAINS
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK SHOULD
C                       TAKE CARE OF
C
C
      CALL MPI_INIT(IERR)
      CALL MPI_COMM_SIZE(MPI_COMM_WORLD,NTASK,IERR)
      CALL MPI_COMM_RANK(MPI_COMM_WORLD,ITASK,IERR)
C
      NPART = NTASK
      IPART = ITASK+1
C
C
      RETURN
      END
      SUBROUTINE DDEXIT
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
C
C      EXIT FROM PARALLEL EXECUTIONS
C                            ( MPI VERSION )
C
C
C NOTE ; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          ( NONE )
C
C       (2) OUTPUT
C          ( NONE )
C
C
      CALL MPI_FINALIZE(IERR)
C
C
      RETURN
      END
      SUBROUTINE DDSYNC
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
#ifdef USE_TIMER
      include 'timer.h'

      real*8 ts0, te0

      nddsync = nddsync + 1
      tstart = MPI_WTIME()
#endif      
C
C
C      IMPLEMENT BARRIER SYNCHRONIZATION AMONG THE GROUP OF ALL TASKS
C                            ( MPI VERSION )
C
C
C NOTE ; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          ( NONE )
C
C       (2) OUTPUT
C          ( NONE )
C
C
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
#ifdef USE_TIMER
      tend = MPI_WTIME()
      tddsync = tddsync +(tend - tstart)
#endif      
      RETURN
      END
C
C
      SUBROUTINE DDSTOP(IPART,IUT0)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDSTOP: FATAL      ERROR REPORTED ; STOPPING' /
      CHARACTER*60 EREXP1
     & / ' A SUB-DOMAIN COMPUTATION HAS BEEN ABNORMALLY TERMINATED AT' /
C
C
C      STOP ALL THE RUNNING PARALLEL TASKS FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C                            ( MPI VERSION )
C
C
C NOTE 1; IF AN ERROR CONDITION HAS BEEN DETECTED IN SOME TASK RUNNING
C       IN PARALLEL, ALL THE TASKS SHARING THAT PARTICULAR RUN SHOULD BE
C       APPROPRIATELY STOPPED. THIS SUBROUTINE TERMINATES ALL THE 
C       RUNNING TASKS AND CANCELS THE PARALLEL JOB.
C
C NOTE 2; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C INT *4   IUT0        ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C          ( NONE )
C
C
      WRITE(IUT0,*) ERMSGB
      WRITE(IUT0,*) EREXP1, IPART
      CALL MPI_ABORT(MPI_COMM_WORLD,IPART,IERR)
C
      RETURN
      END
C
C
      SUBROUTINE DDCOM0(LPINT1,LPINT2,LPINT3,NPINT,MDOM,MBPDOM,
     *                  LDOM,NBPDOM,NDOM,IPSLF,IPSND,IUT0,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LPINT1(NPINT),LPINT2(NPINT),LPINT3(NPINT),
     1          LDOM(MDOM),NBPDOM(MDOM),
     2          IPSLF(MBPDOM,MDOM),IPSND(MBPDOM,MDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM0: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF PASSED LIST ARRAYS IS NOT SUFFICIENT    ' /
C
C
C      SET UP NEIGHBORING DOMAIN LISTS FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   LPINT1 (IBP)     ; INTER-CONNECT BOUNDARY NODES
C INT *4   LPINT2 (IBP)     ; NEIGHBORING SUB-DOMAIN NUMBERS
C INT *4   LPINT3 (IBP)     ; NODE NUMBER IN THE NEIGHBORING SUB-DOMAINS
C INT *4   NPINT            ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C
C INT *4   MDOM             ; MAX. NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C
      IERR = 0
C
C
C
C SET INITIAL VALUES
C
C
C
      NDOM = 0
      DO 100 IDOM = 1 , MDOM
          NBPDOM(IDOM) = 0
  100 CONTINUE
C
C
C
C SET NEIGHBORING DOMAIN LISTS
C
C
C
      DO 230 IPINT = 1 , NPINT
          IFNEW = LPINT2(IPINT)
          DO 210 ICHK = 1 , NDOM
              IF(LDOM(ICHK).EQ.IFNEW) THEN
                  IDOM = ICHK
                  GO TO 220
              ENDIF
  210     CONTINUE
          NDOM = NDOM+1
          IDOM = NDOM
C
          IF(NDOM.GT.MDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          LDOM(NDOM) = IFNEW
C
  220     CONTINUE
          NBPDOM(IDOM) = NBPDOM(IDOM)+1
C
          IF(NBPDOM(IDOM).GT.MBPDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          IPSLF(NBPDOM(IDOM),IDOM) = LPINT1(IPINT)
          IPSND(NBPDOM(IDOM),IDOM) = LPINT3(IPINT)
  230 CONTINUE
C
C
      RETURN
      END
C
C
      SUBROUTINE DDCOM1(LPINT1,NPINT,NUMIP,NP,IUT0,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LPINT1(NPINT),NUMIP(NP)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM1: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' SPECIFIED NODE NUMBER IS OUT OF RANGE                     ' /
C
C
C      CALCULATE NUMBER OF NEIGHBORING DOMAINS THAT EACH NODE BELONGS TO
C     FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   LPINT1 (IBP)     ; INTER-CONNECT BOUNDARY NODES
C INT *4   NPINT            ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C INT *4   NP               ; NUMBER OF TOTAL    NODES
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   NUMIP  (IP)      ; NUMBER OF NEIGHBORING DOMAINS THAT NODE
C                            'IP' BELONG TO
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C
      IERR = 0
C
C
C
C SET INITIAL VALUES
C
C
C
      DO 100 IP = 1 , NP
          NUMIP(IP) = 0
  100 CONTINUE
C
C
C
C CALCULATE NUMBER OF NEIGHBORING DOMAINS THAT NODE 'IP' BELONGS TO
C
C
C
      DO 110 IPINT = 1 , NPINT
          IP = LPINT1(IPINT)
C
          IF(IP.LT.1 .OR. IP.GT.NP) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          NUMIP(IP) = NUMIP(IP)+1
  110 CONTINUE
C
C
      RETURN
      END
C
CCTT SUBROUTINE DDALLD BEGIN
C
      SUBROUTINE DDALLD(SEND,RECV,IFLAG,IUT0,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
C
      INCLUDE 'mpif.h'
C
#ifdef cputime
      INTEGER*4 NUMALL
      REAL*4 DTALLA,DTALLR
      COMMON /CPUALL/ NUMALL,DTALLA,DTALLR
      REAL*4 DTCPU,TBUF1,TBUF2
#endif
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDALLD: FATAL   ERROR OCCURENCE; RETURNED ' /
      CHARACTER*60 ERMSG1
     & / ' ILLIGAL OPERATION NUMBER IS GIVEN ' /
C
C
C      SUM UP A SINGLE SCALAR AMONG ALL THE PARTICIPATING TASKS FOR
C     DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C REAL*4   SEND             ; SCALAR VARIABLE TO SUM UP
C INTEGER  IFLAG            ; OPERATION DISCRIMINATER
C                             1: OP=MPI_SUM
C                             2: OP=MPI_MAX
C                             3: OP=MPI_MIN
C
C       (2) OUTPUT
C REAL*4   RECV             ; SCALAR VARIABLE SUMMED UP AMONG ALL TASKS
C
C
#ifdef cputime
      NUMALL=NUMALL+1
      CALL CPU_TIME( TBUF1 )
#endif
C
      IF(IFLAG.EQ.1) THEN
C
#ifdef PRECEXP
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_SUM,
     &                       MPI_COMM_WORLD,IERR)
#else
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_SUM,
     &                       MPI_COMM_WORLD,IERR)
#endif
C
      ELSE IF (IFLAG.EQ.2) THEN
C
#ifdef PRECEXP
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_MAX,
     &                       MPI_COMM_WORLD,IERR)
#else
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_MAX,
     &                       MPI_COMM_WORLD,IERR)
#endif
C          
      ELSE IF (IFLAG.EQ.3) THEN
C
#ifdef PRECEXP
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL8,MPI_MIN,
     &                       MPI_COMM_WORLD,IERR)
#else
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_REAL ,MPI_MIN,
     &                       MPI_COMM_WORLD,IERR)
#endif
C
      ELSE
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) ERMSG1
          IERR=1
          RETURN
      ENDIF
C
#ifdef cputime
      CALL CPU_TIME( TBUF2 )
      DTCPU=TBUF2-TBUF1
      DTALLA=DTALLA+DTCPU
      DTALLR=DTALLR+DTCPU*DTCPU
#endif
C
      RETURN
      END
C
CCTT SUBROUTINE DDALLD END
C
CCTT SUBROUTINE DDCOM3 BEGIN
C
      SUBROUTINE DDCOM3(IPART,IDIM,LDOM,NBPDOM,NDOM,IPSLF,IPSND,MBPDOM,
     *                  FX,FY,FZ,NP,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LDOM(NDOM),NBPDOM(NDOM),IPSLF(MBPDOM,NDOM),
     1          IPSND(MBPDOM,NDOM), FX(NP),FY(NP),FZ(NP),
     2          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM3: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      EXCHANGE X, Y, AND Z RESIDUALS AMONG THE NEIGHBORING SUB-DOMAINS
C     AND SUPERIMPOSE THE EXCHANGED RESIDUALS TO THE CALLING TASK'S
C     RESIDUALS, FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C           NOTES ; ARGUMENT 'IPART' IS NOT CURRENTLY USED. IT IS
C                  RETAINED FOR A POSSIBLE FUTURE USE.
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   NP               ; NUMBER OF THE TOTAL NODES IN THE CALLING
C                            TASK'S SUB-DOMAIN
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                             MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                             NUMBER OF INTER-CONNECT BOUNDARY NODES IN
C                             THE CALLING TASK
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C REAL*4   FX(IP)           ; X-DIRECTION RESIDUAL VECTOR
C REAL*4   FY(IP)           ; Y-DIRECTION RESIDUAL VECTOR
C REAL*4   FZ(IP)           ; Z-DIRECTION RESIDUAL VECTOR
C
C       (4) WORK
C REAL*4   BUFSND(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE NEIGHBORING
C                            SUB-DOMAINS AND THE RESIDUALS OF THE
C                            CALLING TASK'S SUB-DOMAIN WHEN SENDING
C                            THE RESIDUALS
C                         
C REAL*4   BUFRCV(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE CALLING TASK'S
C                            SUB-DOMAIN AND THE RESIDUALS OF THE
C                            NEIGHBORING SUB-DOMAINS AT THE RECEIPT OF
C                            THE RESIDUALS FROM THE NEIGHBORING
C                            SUB-DOMAINS
C
C
      IERR = 0
C
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(2*NDOM.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIVES
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NDOM
          MSGTYP = 1
          IRECV  = LDOM(IDOM)-1
          MSGLEN = 4*NBPDOM(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
#ifdef PRECEXP
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL8,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#else
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL ,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN
  110 CONTINUE
C
!      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP THE SEND BUFFER
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:200-210")
!CDIR PARALLEL DO PRIVATE(NSTART,IP,IPS)
      DO 210 IDOM = 1 , NDOM
          NSTART  = 0
          DO 205 ITMP = 2 , IDOM
              NSTART = NSTART + NBPDOM(ITMP-1)*4
  205     CONTINUE
!CDIR NOINNER
          DO 200 IBP = 1 , NBPDOM(IDOM)
              IP  = IPSLF(IBP,IDOM)
              IPS = IPSND(IBP,IDOM)
              BUFSND(NSTART+1) = IPS
              BUFSND(NSTART+2) = FX(IP)
              BUFSND(NSTART+3) = FY(IP)
              BUFSND(NSTART+4) = FZ(IP)
              NSTART = NSTART + 4
  200     CONTINUE
  210 CONTINUE
CC    CALL FTRACE_REGION_END("ddcom3:200-210")
C
C
C
C SEND THE RESIDUALS
C
C
C
      NSTART = 1
      DO 220 IDOM = 1 , NDOM
          MSGTYP = 1
          ISEND  = LDOM(IDOM)-1
          MSGLEN = 4*NBPDOM(IDOM)

#ifdef PRECEXP
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL8,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#else
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL ,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN 
  220 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(2*NDOM,MSGIDS,MSGSTS,IERR)
C 
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C
C SUPERIMPOSE THE RECEIVED RESIDUALS
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:300-310")
      NSTARTMP = 0
      DO IDOM = 1 , NDOM
!CDIR NOINNER
        DO IBP = 1, NBPDOM(IDOM)
          IP = BUFRCV(NSTARTMP+1)+0.1
          IF(IP.LT.1 .OR. IP.GT.NP) THEN
            IERR = 1
          ENDIF
          NSTARTMP = NSTARTMP + 4
        ENDDO
      ENDDO
C
      IF(IERR .eq. 1) THEN
        WRITE(IUT0,*) ERMSGB
        WRITE(IUT0,*) EREXP3
        RETURN
      ENDIF
C
      IF(IDIM .GE. 3) THEN
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
            FY(IP) = FY(IP)+BUFRCV(NSTART+3)
            FZ(IP) = FZ(IP)+BUFRCV(NSTART+4)
          ENDDO
      ELSE IF(IDIM .GE. 2) THEN
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
            FY(IP) = FY(IP)+BUFRCV(NSTART+3)
          ENDDO
      ELSE
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
          ENDDO
      ENDIF
C
CC    CALL FTRACE_REGION_END("ddcom3:300-310")
C
      IPART = IPART
C
C
      RETURN
      END
C
C
      SUBROUTINE DDSET0(LPSET1,LPSET3,NPSET,MPT,MDOM,IUT0,
     *                  NSND,LSND,NPTSND,IPSET,IPSRC,
     *                  NRCV,LRCV,NPTRCV,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LPSET1(NPSET),LPSET3(NPSET),
     1          LSND(MDOM),NPTSND(MDOM),IPSET(MPT,MDOM),IPSRC(MPT,MDOM),
     2          LRCV(MDOM),NPTRCV(MDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDSET0: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF PASSED LIST ARRAYS IS NOT SUFFICIENT    ' /
C
C
C      SET UP OVERSET SUB-DOMAIN LISTS FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   LPSET1  (IB); OVERSET BOUNDARY NODES/ELEMENTS
C INT *4   LPSET3  (IB); DOMAIN NUMBER TO SEND/RECEIVE OVERSET VALUES
C                   0 --- CALCULATE AND SET OVERSET VALUE WITHIN THE
C                         SELF-DOMAIN
C          (POS. INT.)--- SEND    OVERSET VALUE TO   DOMAIN  LPSET3(IB)
C                         AFTER CALCULATING IT WITHIN THE SELF-DOMAIN
C          (NEG. INT.)--- RECEIVE OVERSET VALUE FROM DOMAIN -LPSET3(IB)
C          NPSET       ; NUMBER OF OVERSET BOUNDARY NODES/ELEMENTS
C
C INT *4   MPT              ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSET'
C                            (I.E. THE MAXIMUM NUMBER OF THE OVERSET
C                             POINTS FOR A SINGLE SUB-DOMAIN)
C INT *4   MDOM             ; MAX. NUMBER OF THE OVERSET SUB-DOMAINS
C
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   NSND             ; NUMBER OF DOMAINS TO SEND OVERSET VALUE
C INT *4   LSND      (IDOM) ; DOMAIN NUMBER     TO SEND OVERSET VALUE
C INT *4   NPTSND    (IDOM) ; NUMBER OF OVERSET POINTS TO SEND TO
C                            SUB-DOMAIN 'LSND(IDOM)'
C INT *4   IPSET (IPT,IDOM) ; OVERSET NODE/ELEMENT NUMBER IN THE
C                            SUB-DOMAIN RECEIVING THE OVERSET VALUES.
C INT *4   IPSRC (IPT,IDOM) ; INDICATES POSITION IN THE OVERSET-VALUES
C                            PASSING ARRAYS WHEN OVERSET CONDITIONS DATA
C                            ARE COMPILED SEQUENTIALLY
C
C INT *4   NRCV             ; NUMBER OF DOMAINS TO RECEIVE OVERSET VALUE
C INT *4   LRCV      (IDOM) ; DOMAIN NUMBER     TO RECEIVE OVERSET VALUE
C INT *4   NPTRCV    (IDOM) ; NUMBER OF OVERSET POINTS TO RECEIVE FROM
C                            SUB-DOMAIN 'LRCV(IDOM)'
C
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C
      IERR = 0
C
C
C
C SET INITIAL VALUES
C
C
C
      NSND = 0
      NRCV = 0
      DO 100 IDOM = 1 , MDOM
          NPTSND(IDOM) = 0
          NPTRCV(IDOM) = 0
  100 CONTINUE
C
C
C
C SET DOMAIN LISTS FOR SEND
C
C
C
      NDUM = 0
      DO 230 IBP = 1 , NPSET
          IF(LPSET3(IBP).LE.0) GO TO 230
C
          NDUM = NDUM+1
C
          IFNEW = LPSET3(IBP)
          DO 210 ICHK = 1 , NSND
              IF(LSND(ICHK).EQ.IFNEW) THEN
                  IDOM = ICHK
                  GO TO 220
              ENDIF
  210     CONTINUE
          NSND = NSND+1
          IDOM = NSND
C
          IF(NSND.GT.MDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          LSND(NSND) = IFNEW
C
  220     CONTINUE
          NPTSND(IDOM) = NPTSND(IDOM)+1
C
          IF(NPTSND(IDOM).GT.MPT) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          IPSET(NPTSND(IDOM),IDOM) = LPSET1(IBP)
          IPSRC(NPTSND(IDOM),IDOM) = NDUM
  230 CONTINUE
C
C
C
C SET DOMAIN LISTS FOR RECEIVE
C
C
C
      DO 330 IBP = 1 , NPSET
          IF(LPSET3(IBP).GE.0) GO TO 330
          IFNEW = -LPSET3(IBP)
          DO 310 ICHK = 1 , NRCV
              IF(LRCV(ICHK).EQ.IFNEW) THEN
                  IDOM = ICHK
                  GO TO 320
              ENDIF
  310     CONTINUE
          NRCV = NRCV+1
          IDOM = NRCV
C
          IF(NRCV.GT.MDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          LRCV(NRCV) = IFNEW
C
  320     CONTINUE
          NPTRCV(IDOM) = NPTRCV(IDOM)+1
  330 CONTINUE
C
C
      RETURN
      END
C
C
      SUBROUTINE DDSET3(NSND,LSND,NPTSND,IPSET,IPSRC,VALX,VALY,VALZ,NB,
     *                  NRCV,LRCV,NPTRCV,FX,FY,FZ,NP,
     *                  IDIM,MPT,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LSND(NSND),NPTSND(NSND),IPSET(MPT,NSND),IPSRC(MPT,NSND),
     1          LRCV(NRCV),NPTRCV(NRCV),
     2          VALX(NB),VALY(NB),VALZ(NB),FX(NP),FY(NP),FZ(NP),
     3          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDSET3: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      OVERSET SOME VALUES OF THE PASSED ARRAY ELEMENTS, 
C     FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   NSND             ; NUMBER OF DOMAINS TO SEND OVERSET VALUE
C INT *4   LSND      (IDOM) ; DOMAIN NUMBER     TO SEND OVERSET VALUE
C INT *4   NPTSND    (IDOM) ; NUMBER OF OVERSET POINTS TO SEND TO
C                            SUB-DOMAIN 'LSND(IDOM)'
C INT *4   IPSET (IPT,IDOM) ; OVERSET NODE/ELEMENT NUMBER IN THE
C                            SUB-DOMAIN RECEIVING THE OVERSET VALUES.
C
C INT *4   IPSRC (IPT,IDOM) ; INDICATES POSITION IN THE OVERSET-VALUES
C                            PASSING ARRAYS
C REAL*4   VALX        (IB) ; X-DIRECTION OVERSET VALUES
C REAL*4   VALY        (IB) ; Y-DIRECTION OVERSET VALUES
C REAL*4   VALZ        (IB) ; Z-DIRECTION OVERSET VALUES
C INT *4   NB               ; TOTAL NUMBER OF OVERSET VALUES TO SEND
C
C INT *4   NRCV             ; NUMBER OF DOMAINS TO RECEIVE OVERSET VALUE
C INT *4   LRCV      (IDOM) ; DOMAIN NUMBER     TO RECEIVE OVERSET VALUE
C INT *4   NPTRCV    (IDOM) ; NUMBER OF OVERSET POINTS TO RECEIVE FROM
C                            SUB-DOMAIN 'LRCV(IDOM)'
C INT *4   NP               ; NUMBER OF THE TOTAL NODES/ELEMENTS IN THE
C                            CALLING TASK'S SUB-DOMAIN
C
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C
C INT *4   MPT              ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSET'
C                            (I.E. THE MAXIMUM NUMBER OF THE OVERSET
C                             POINTS FOR A SINGLE SUB-DOMAIN)
C
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                            MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                            NUMBER OF OVERSET POINTS TO SEND OR RECEIVE
C
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C REAL*4   FX          (IP) ; X-DIRECTION ARRAY TO OVERSET
C REAL*4   FY          (IP) ; Y-DIRECTION ARRAY TO OVERSET
C REAL*4   FZ          (IP) ; Z-DIRECTION ARRAY TO OVERSET
C
C       (4) WORK
C REAL*4   BUFSND(IBUF)     ; HOLDS THE OVERSET VALUES AND OVERSET NODE/
C                            ELEMENT NUMBERS IN THE SUB-DOMAIN RECEIVING
C                            THEM WHEN SENDING OVERSET VALUES
C                         
C REAL*4   BUFRCV(IBUF)     ; HOLDS THE OVERSET VALUES AND OVERSET NODE/
C                            ELEMENT NUMBERS IN THE CALLING TASK'S 
C                            SUB-DOMAIN AT THE RECEIPT OF THE OVERSET
C                            VALUES
C
C
      IERR = 0
C
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(NRCV+NSND.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIPTS
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NRCV
          MSGTYP = 2
          IRECV  = LRCV(IDOM)-1
          MSGLEN = 4*NPTRCV(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
#ifdef PRECEXP
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL8,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#else
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL ,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN 
  110 CONTINUE
C
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP SEND BUFFER AND SEND OVERSET VALUES FOR EACH DOMAIN
C
C
C
      NSTART = 1
      DO 210 IDOM = 1 , NSND
          MSGTYP = 2
          ISEND  = LSND(IDOM)-1
          MSGLEN = 4*NPTSND(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
          DO 200 IPT = 1 , NPTSND(IDOM)
              BUFSND(NSTART+4*(IPT-1)  ) = IPSET(IPT,IDOM)
              BUFSND(NSTART+4*(IPT-1)+1) = VALX(IPSRC(IPT,IDOM))
              BUFSND(NSTART+4*(IPT-1)+2) = VALY(IPSRC(IPT,IDOM))
              BUFSND(NSTART+4*(IPT-1)+3) = VALZ(IPSRC(IPT,IDOM))
  200     CONTINUE
C
#ifdef PRECEXP
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL8,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NRCV+IDOM),IERR)
#else
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL ,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NRCV+IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN 
  210 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(NRCV+NSND,MSGIDS,MSGSTS,IERR)
C
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C 
C OVERSET WITH THE RECEIVED VALUES
C 
C 
C 
      NSTART = 1
      DO 310 IDOM = 1 , NRCV
          DO 300 IPT = 1 , NPTRCV(IDOM)
              IP = BUFRCV(NSTART)+0.1
C
              IF(IP.LT.1 .OR. IP.GT.NP) THEN
                  WRITE(IUT0,*) ERMSGB
                  WRITE(IUT0,*) EREXP3
CC                IERR = 1
CC                RETURN
                  GOTO 300
              ENDIF
C
                            FX(IP) = BUFRCV(NSTART+1)
              IF(IDIM.GE.2) FY(IP) = BUFRCV(NSTART+2)
              IF(IDIM.GE.3) FZ(IP) = BUFRCV(NSTART+3)
              NSTART = NSTART+4
  300     CONTINUE
  310 CONTINUE
C
C
      RETURN
      END
C
CCTT SUBROUTINE DDCMAX BEGIN
C
      SUBROUTINE DDCMAX(IPART,IDIM,LDOM,NBPDOM,NDOM,IPSLF,IPSND,MBPDOM,
     *                  FX,FY,FZ,NP,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LDOM(NDOM),NBPDOM(NDOM),IPSLF(MBPDOM,NDOM),
     1          IPSND(MBPDOM,NDOM), FX(NP),FY(NP),FZ(NP),
     2          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOMX: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      EXCHANGE X, Y, AND Z RESIDUALS AMONG THE NEIGHBORING SUB-DOMAINS
C     AND TAKE THE MAXIMUM VALUE OF THE EXCHANGED RESIDUALS TO THE CALLING 
C     TASK'S RESIDUALS, FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C           NOTES ; ARGUMENT 'IPART' IS NOT CURRENTLY USED. IT IS
C                  RETAINED FOR A POSSIBLE FUTURE USE.
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   NP               ; NUMBER OF THE TOTAL NODES IN THE CALLING
C                            TASK'S SUB-DOMAIN
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                             MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                             NUMBER OF INTER-CONNECT BOUNDARY NODES IN
C                             THE CALLING TASK
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C REAL*4   FX(IP)           ; X-DIRECTION RESIDUAL VECTOR
C REAL*4   FY(IP)           ; Y-DIRECTION RESIDUAL VECTOR
C REAL*4   FZ(IP)           ; Z-DIRECTION RESIDUAL VECTOR
C
C       (4) WORK
C REAL*4   BUFSND(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE NEIGHBORING
C                            SUB-DOMAINS AND THE RESIDUALS OF THE
C                            CALLING TASK'S SUB-DOMAIN WHEN SENDING
C                            THE RESIDUALS
C                         
C REAL*4   BUFRCV(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE CALLING TASK'S
C                            SUB-DOMAIN AND THE RESIDUALS OF THE
C                            NEIGHBORING SUB-DOMAINS AT THE RECEIPT OF
C                            THE RESIDUALS FROM THE NEIGHBORING
C                            SUB-DOMAINS
C
C
      IERR = 0
C
      IF(IDIM.EQ.0) THEN
          NSKIP=1
      ELSE IF(IDIM.EQ.1) THEN
          NSKIP=1
      ELSE IF(IDIM.EQ.2) THEN 
          NSKIP=2
      ELSE IF(IDIM.EQ.3) THEN 
          NSKIP=3
      ELSE
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(2*NDOM.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIVES
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NDOM
          MSGTYP = 1
          IRECV  = LDOM(IDOM)-1
          MSGLEN = NSKIP*NBPDOM(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
#ifdef PRECEXP
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL8,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#else
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL ,IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN
  110 CONTINUE
C
!      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP THE SEND BUFFER
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:200-210")
!CDIR PARALLEL DO PRIVATE(NSTART,IP,IPS)
      DO 210 IDOM = 1 , NDOM
          NSTART  = 0
          DO 205 ITMP = 2 , IDOM
              NSTART = NSTART + NBPDOM(ITMP-1)*NSKIP
  205     CONTINUE
!CDIR NOINNER
          DO 200 IBP = 1 , NBPDOM(IDOM)
              IP  = IPSLF(IBP,IDOM)
              IF(IDIM.EQ.0) THEN
                  IPS = IPSND(IBP,IDOM)
                  BUFSND(NSTART+1) = IPS
              ELSE IF(IDIM.EQ.1) THEN
                  BUFSND(NSTART+1) = FX(IP)
              ELSE IF(IDIM.EQ.2) THEN
                  BUFSND(NSTART+1) = FX(IP)
                  BUFSND(NSTART+2) = FY(IP)
              ELSE IF(IDIM.EQ.3) THEN
                  BUFSND(NSTART+1) = FX(IP)
                  BUFSND(NSTART+2) = FY(IP)
                  BUFSND(NSTART+3) = FZ(IP)
              ENDIF
              NSTART = NSTART + NSKIP
  200     CONTINUE
  210 CONTINUE
C
C
C
C SEND THE RESIDUALS
C
C
C
      NSTART = 1
      DO 220 IDOM = 1 , NDOM
          MSGTYP = 1
          ISEND  = LDOM(IDOM)-1
          MSGLEN = NSKIP*NBPDOM(IDOM)

#ifdef PRECEXP
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL8,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#else
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL ,ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
#endif
C
          NSTART = NSTART+MSGLEN 
  220 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(2*NDOM,MSGIDS,MSGSTS,IERR)
C 
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C
C SUPERIMPOSE THE RECEIVED RESIDUALS
C
C
      NSTART = 0
      DO IDOM = 1 , NDOM
!CDIR NOINNER
        DO IBP = 1, NBPDOM(IDOM)
          IF(IDIM.EQ.0) THEN     
              IPSND(IBP,IDOM)=BUFRCV(NSTART+1)+0.1
          ELSE 
              IP = IPSND(IBP,IDOM)
              IF(IP.LT.1 .OR. IP.GT.NP) THEN
                IERR = 1
              ENDIF
          ENDIF
C
          IF(IDIM.EQ.1) THEN
            FX(IP) = MAX(FX(IP),BUFRCV(NSTART+1))
          ELSE IF(IDIM .EQ. 2) THEN 
            FX(IP) = MAX(FX(IP),BUFRCV(NSTART+1))
            FY(IP) = MAX(FY(IP),BUFRCV(NSTART+2))
          ELSE IF(IDIM .EQ. 3) THEN 
            FX(IP) = MAX(FX(IP),BUFRCV(NSTART+1))
            FY(IP) = MAX(FY(IP),BUFRCV(NSTART+2))
            FZ(IP) = MAX(FZ(IP),BUFRCV(NSTART+3))
          ENDIF
C
          NSTART=NSTART+NSKIP
        ENDDO
      ENDDO
C
      IF(IERR .eq. 1) THEN
        WRITE(IUT0,*) ERMSGB
        WRITE(IUT0,*) EREXP3
        RETURN
      ENDIF
C
C     IPART = IPART
C
      RETURN
      END
C
C
CCTT SUBROUTINE DDCMAX END
