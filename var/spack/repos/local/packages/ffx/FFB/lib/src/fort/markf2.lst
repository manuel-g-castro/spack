
 Fujitsu Fortran Version 4.5.0  Thu May  6 16:54:09 2021

 Compilation information
   Current directory : /vol0004/hp120295/u00324/FFBs/FFB.63.02.02/lib/src/fort
   Source file       : markf2.f

 Option information
   Command line options : -Kident_mpi -f2004 -I/vol0004/hp120295/u00324/FFB/include -I/include/mpi/fujitsu/ -Kvisimpact,ocl,optmsg=2,openmp -Dcputime -DUSE_TIMER -DUSE_BARRIER -Nlst=t -Cpp -Nfjomplib -c -I/opt/FJSVxtclanga/.common/MELI024/include/mpi/fujitsu -I/opt/FJSVxtclanga/.common/MELI024/lib64 -Knointentopt
   Cpp options          : -I/vol0004/hp120295/u00324/FFB/include -I/include/mpi/fujitsu/ -Dcputime -DUSE_TIMER -DUSE_BARRIER -I/opt/FJSVxtclanga/.common/MELI024/include/mpi/fujitsu -I/opt/FJSVxtclanga/.common/MELI024/lib64 -Dunix -Dlinux -D__FUJITSU -D__FRT_major__=4 -D__FRT_minor__=5 -D__FRT_patchlevel__=0 -D__FRT_version__="4.5.0" -D__aarch64__ -D__unix -D_OPENMP=201511 -D__frt_version=800 -D__ARM_ARCH=8 -D__ARM_FEATURE_SVE -D__ELF__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -otmp
   Effective options    : -fi -g0 -AE -Fixed -O3 -X08
                          -x0 -xaccept=nomodule_allocatable
                          -KA64FX -KARMV8_3_A -KSVE -Kalign_commons
                          -Kalign_loops -Karray_declaration_opt
                          -Kassume=noshortloop -Kassume=nomemory_bandwidth
                          -Kassume=notime_saving_compilation -Kauto
                          -Kautoobjstack -Knocalleralloc -Kcmodel=small
                          -Keval -Keval_noconcurrent -Knoextract_stride_store
                          -Knofenv_access -Kfp_contract -Kfp_relaxed
                          -Kfsimple -Kfz -Khpctag -Kilfunc=procedure
                          -Knointentopt -Klargepage -Kloop_blocking
                          -Kloop_fission -Kloop_nofission_stripmining
                          -Kloop_fission_threshold=50 -Kloop_fusion
                          -Kloop_interchange -Kloop_part_parallel
                          -Kloop_part_simd -Kloop_perfect_nest
                          -Kloop_noversioning -Knolto -Kmfunc=1 -Kocl
                          -Komitfp -Knooptlib_string -Koptmsg=2
                          -Knopc_relative_literal_loads -Kplt -Knopreex
                          -Kprefetch_noconditional -Kprefetch_noindirect
                          -Kprefetch_sequential=auto -Kprefetch_nostride
                          -Kprefetch_cache_level=all -Kprefetch_noinfer
                          -Kprefetch_strong -Kprefetch_strong_L2 -Knopreload
                          -Ksch_post_ra -Ksch_pre_ra -Ksibling_calls
                          -Ksimd=auto -Ksimd_packed_promotion
                          -Ksimd_reduction_product -Ksimd_reg_size=512
                          -Ksimd_nouncounted_loop
                          -Ksimd_use_multiple_structures -Knostriping
                          -Knosubscript_opt -Kswp -Kswp_freg_rate=100
                          -Kswp_ireg_rate=100 -Kswp_preg_rate=100
                          -Kswp_policy=auto -Ktemparraystack -Kunroll
                          -Knounroll_and_jam -Knozfill
                          -Kopenmp -Kopenmp_noassume_norecurrence
                          -Kopenmp_nocollapse_except_innermost
                          -Kopenmp_noordered_reduction -Knoopenmp_simd
                          -Kthreadsafe -Kparallel -Kparallel_nofp_precision
                          -Knoarray_private -Knodynamic_iteration -Kreduction
                          -Kregion_extension
                          -Nallextput -Nalloc_assign
                          -Ncancel_overtime_compilation -Nnocheck_global
                          -Nnocoarray -Nnocompdisp -Nnocopyarg -Nnocoverage
                          -Nfjprof -Nfreealloc -Nf90move -Nnohook_func
                          -Nnohook_time -Nfjomplib -Nline -Nlst -Nlst=p
                          -Nlst=t -Nnomallocfree -Nnoobsfun -Nnoprivatealloc
                          -Nquickdbg=noargchk -Nquickdbg=nosubchk
                          -Nquickdbg=noundef -NRnotrap -Nnorecursive
                          -Nnoreordered_variable_stack -Nrt_notune -Nnosave
                          -Nsetvalue=noheap -Nsetvalue=nostack
                          -Nsetvalue=noscalar -Nsetvalue=noarray
                          -Nsetvalue=nostruct -Nuse_rodata

 External subroutine subprogram "MARKF2"
  (line-no.)(nest)(optimize)
          1                     C======================================================================C
          2                     C                                                                      C
          3                     C SOFTWARE NAME : FRONTFLOW_BLUE.1.0                                   C
          4                     C                                                                      C
          5                     C  SUB ROUTINE    MARKF2                                               C
          6                     C                                                                      C
          7                     C                                       WRITTEN BY C.KATO              C
          8                     C                                                                      C
          9                     C                                                                      C
         10                     C Contact address: The University of Tokyo, FSIS project               C
         11                     C                                                                      C
         12                     C======================================================================C
         13                           SUBROUTINE MARKF2(IMODE,JVALID,DT,X,Y,UM,VM,NODE,N,IENE,NEE,MAXEE,
         14                          *                  EX1,EX2,EX3,EY1,EY2,EY3,DET1,DET2,
         15                          *                  XMINMK,YMINMK,XMAXMK,YMAXMK,XM,YM,IEM,NM,
         16                          *                  LOVER,LLOST,MOVER,MLOST,IUT0,IERR)
         17                           IMPLICIT REAL*8(A-H,O-Z)
         18                           DIMENSION X(*),Y(*),UM(NM),VM(NM),NODE(N,*),IENE(MAXEE,*),NEE(*),
         19                          1          EX1 (*),EX2 (*),EX3(*),EY1(*),EY2(*),EY3(*),
         20                          2          DET1(*),DET2(*),XM(NM),YM(NM),IEM(NM),
         21                          3          LOVER(MOVER),LLOST(MLOST)
         22                     C
         23                           CHARACTER*72 ERMSG
         24                          & /' *** SUBROUTINE MARKF2 REPORTS A FATAL ERROR OCCURENCE ***' /
         25                           CHARACTER*72 EREXP1
         26                          & /' TOO MANY PARTICLES HAVE PASSED ELEMENT BOUNDARIES' /
         27                           CHARACTER*72 EREXP2
         28                          & /' TOO MANY PARTICLES HAVE BEEN LOST FROM THE FIELD ' /
         29                     C
         30                           D = 1.D-3
         31                     C
         32                     C
         33                     C      MOVE MARKER AND FIND NEW ELEMENT ; MARKER OPERATION 2
         34                     C         ( 2-D CALCULATION )
         35                     C
         36                     C
         37                     C     ARGUMENT LISTINGS
         38                     C       (1) INPUT
         39                     C          IMODE       ; SPECIFIES LOST MARKER TRANSACTION AS FOLLOWS
         40                     C                   1 --- CONDENSE THE DIMENSIONS     FOR LOST MARKERS
         41                     C                   2 --- CLEAR    THE ELEMENT NUMBER FOR LOST MARKERS
         42                     C                 NOTE   ; ONLY IN MODE 2
         43                     C                         MARKER IDENTIFICATION IS POSSIBLE
         44                     C          JVALID      ; VALIDITY FLAG FOR MARKER TRACING ZONE
         45                     C                   0 --- TRACING ZONE INVALID
         46                     C                   1 --- TRACING ZONE   VALID
         47                     C          DT          ; TIME INCREMENT
         48                     C          X       (IP); X-DIR. COORDINATE         OF NODE
         49                     C          Y       (IP); Y-DIR. COORDINATE         OF NODE
         50                     C          UM      (IM); X-DIR. VELOCITY COMPONENT OF MARKER
         51                     C          VM      (IM); Y-DIR. VELOCITY COMPONENT OF MARKER
         52                     C          NODE  (I,IE); NODE TABLE
         53                     C          N           ; NUMBER OF NODES ASSIGNED TO ONE ELEMENT
         54                     C          IENE(IEE,IE); ADJACENT ELEMENT NUMBER TO ELEMENT IE
         55                     C          NEE     (IE); NUMBER OF ADJACENT ELEMENTS TO ELEMENT IE
         56                     C          MAXEE       ; THE FIRST DIMENSION OF ARRAY IENE
         57                     C          EX1     (IE); ELEMENT VECTOR  X(NODE(2,IE))-X(NODE(1,IE))
         58                     C          EX2     (IE); ELEMENT VECTOR  X(NODE(3,IE))-X(NODE(1,IE))
         59                     C          EX3     (IE); ELEMENT VECTOR  X(NODE(4,IE))-X(NODE(1,IE))
         60                     C          EY1     (IE); ELEMENT VECTOR  Y(NODE(2,IE))-Y(NODE(1,IE))
         61                     C          EY2     (IE); ELEMENT VECTOR  Y(NODE(3,IE))-Y(NODE(1,IE))
         62                     C          EY3     (IE); ELEMENT VECTOR  Y(NODE(4,IE))-Y(NODE(1,IE))
         63                     C          DET1(IE)    ; DETERMINANT ( EX1 , EY1 , EX2 , EY2 )
         64                     C          DET2(IE)    ; DETERMINANT ( EX2 , EY2 , EX3 , EY3 )
         65                     C          XMINMK      ; MIN. X-COOR. OF THE TRACING   ZONE   (JVALID=1)
         66                     C          XMAXMK      ; MAX. X-COOR. OF THE TRACING   ZONE   (JVALID=1)
         67                     C          YMINMK      ; MIN. Y-COOR. OF THE TRACING   ZONE   (JVALID=1)
         68                     C          YMAXMK      ; MAX. Y-COOR. OF THE TRACING   ZONE   (JVALID=1)
         69                     C          MOVER       ; THE DIMENSION OF ARRAY LOVER
         70                     C          MLOST       ; THE DIMENSION OF ARRAY LLOST
         71                     C          IUT0        ; DEVICE NUMBER TO REPORT ERROR OCCURENCE
         72                     C
         73                     C       (2) OUTPUT
         74                     C          IERR        ; RETURN CODE TO REPORT ERROR OCCURENCE
         75                     C                   0 --- NORMAL TERMINATION
         76                     C                   1 --- A FATAL ERROR HAS OCCURED
         77                     C
         78                     C       (3) INPUT-OUTPUT
         79                     C          XM      (IM); LOCATION    OF PARTICLES EXISTING IN THE FIELD
         80                     C          YM      (IM); LOCATION    OF PARTICLES EXISTING IN THE FIELD
         81                     C          IEM     (IM); ELEMENT NO. OF PARTICLES EXISTING IN THE FIELD
         82                     C          NM          ; NUMBER      OF PARTICLES EXISTING IN THE FIELD
         83                     C
         84                     C       (4) WORK
         85                     C          LOVER(IOVER); STORE THE PARTICLE NO.
         86                     C                       WHICH HAVE PASSED ELEMENT BOUNDARIES
         87                     C          LLOST(ILOST); STORE THE PARTICLE NO.
         88                     C                       WHICH HAVE BEEN LOST FROM THE FIELD
         89                     C
         90                     C
         91                           IERR = 0
         92                     C
         93                     C      (1) MOVE ALL THE PARTICLES
         94                     C
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 500
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 8)
                              <<<    SOFTWARE PIPELINING(IPC: 2.66, ITR: 88, MVE: 5, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IEM, UM, XM, VM, YM
                              <<< Loop-information  End >>>
         95     1  pp    v            DO 100 IM = 1 , NM
         96     1   p    v                IF(IEM(IM).EQ.0) GO TO 100
         97     1   p    v                XM(IM) = XM(IM)+DT*UM(IM)
         98     1   p    v                YM(IM) = YM(IM)+DT*VM(IM)
         99     1   p    v        100 CONTINUE
        100                     C
        101                     C      (2) FIND PARTICLES WHICH HAVE PASSED ELEMENT BOUNDARIES
        102                     C
        103                           NOVER = 0
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IEM
                              <<< Loop-information  End >>>
        104     1        s            DO 200 IM = 1 , NM
        105     1        v                IF(IEM(IM).EQ.0) GO TO 200
        106     1        v                IE = IEM(IM)
        107     1        v                XF = XM(IM)-X(NODE(1,IE))
        108     1        v                YF = YM(IM)-Y(NODE(1,IE))
        109     1               C
        110     1        v                A1 = ( EY2(IE)*XF-EX2(IE)*YF)/DET1(IE)
        111     1        v                B1 = (-EY1(IE)*XF+EX1(IE)*YF)/DET1(IE)
        112     1        v                A2 = ( EY3(IE)*XF-EX3(IE)*YF)/DET2(IE)
        113     1        v                B2 = (-EY2(IE)*XF+EX2(IE)*YF)/DET2(IE)
        114     1               C
        115     2        v                IF((A1.LT.-D .OR. B1.LT.-D .OR. A1+B1.GT. 1.D0+D) .AND.
        116     2                    &       (A2.LT.-D .OR. B2.LT.-D .OR. A2+B2.GT. 1.D0+D)) THEN
        117     2        m                    NOVER = NOVER+1
        118     2               C TEMORARY DELETED 88/03/19
        119     2               C             IF(NOVER.LE.MOVER) THEN
        120     2               C TEMORARY DELETED 88/03/19
        121     2        s                        LOVER(NOVER) = IM
        122     2               C TEMORARY DELETED 88/03/19
        123     2               C             ENDIF
        124     2               C TEMORARY DELETED 88/03/19
        125     2        v                ENDIF
        126     1        v        200 CONTINUE
        127                     C
        128     1                     IF(NOVER.GT.MOVER) THEN
        129     1                         WRITE(IUT0,6300) ERMSG
        130     1                         WRITE(IUT0,6300) EREXP1
        131     1                         IERR = 1
        132     1                         RETURN
        133     1                     ENDIF
        134                     C
        135                     C      (3) OVER PARTICLES TRANSACTION
        136                     C
        137     1                     DO 310 IEE = 1 , MAXEE
        138     1               *VOPTION VEC
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOVER
                              <<<    SPILLS :
                              <<<      GENERAL   : SPILL 0  FILL 2
                              <<<      SIMD&FP   : SPILL 0  FILL 0
                              <<<      SCALABLE  : SPILL 0  FILL 0
                              <<<      PREDICATE : SPILL 0  FILL 0
                              <<< Loop-information  End >>>
        139     2   s    s                DO 300 IOVER = 1 , NOVER
        140     2   p    m                    IF(LOVER(IOVER).EQ.0) GO TO 300
        141     2   p    s                    IM = LOVER(IOVER)
        142     2   m    s                    IE = IEM(IM)
        143     2   s    s                    IF(IEE.GT.NEE(IE)) GO TO 300
        144     2   s    s                    IER = IENE(IEE,IE)
        145     2   s    s                    XF = XM(IM)-X(NODE(1,IER))
        146     2   s    s                    YF = YM(IM)-Y(NODE(1,IER))
        147     2   s    s                    A1 = ( EY2(IER)*XF-EX2(IER)*YF)/DET1(IER)
        148     2   s    s                    B1 = (-EY1(IER)*XF+EX1(IER)*YF)/DET1(IER)
        149     2   s    s                    A2 = ( EY3(IER)*XF-EX3(IER)*YF)/DET2(IER)
        150     2   s    s                    B2 = (-EY2(IER)*XF+EX2(IER)*YF)/DET2(IER)
        151     2               C
        152     3   s    s                    IF(A1.GE.-D .AND. B1.GE.-D .AND. A1+B1.LE.1.D0+D  .OR.
        153     3                    &           A2.GE.-D .AND. B2.GE.-D .AND. A2+B2.LE.1.D0+D) THEN
        154     3   s    s                        IEM(IM) = IER
        155     3   p    s                        LOVER(IOVER) = 0
        156     3   p    s                    ENDIF
        157     2   p    v        300     CONTINUE
        158     1                 310 CONTINUE
        159                     C
        160                           NLOST = 0
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOVER
                              <<< Loop-information  End >>>
        161     1       2s            DO 400 IOVER = 1 , NOVER
        162     2       2v                IF(LOVER(IOVER).NE.0) THEN
        163     2       2m                    NLOST = NLOST+1
        164     2               C TEMORARY DELETED 88/03/19
        165     2               C             IF(NLOST.LE.MLOST) THEN
        166     2               C TEMORARY DELETED 88/03/19
        167     2       2s                        LLOST(NLOST) = LOVER(IOVER)
        168     2               C TEMORARY DELETED 88/03/19
        169     2               C             ENDIF
        170     2               C TEMORARY DELETED 88/03/19
        171     2       2v                ENDIF
        172     1       2v        400 CONTINUE
        173                     C
        174     1                     IF(JVALID.EQ.1) THEN
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IEM
                              <<< Loop-information  End >>>
        175     2       2s                DO 450 IM = 1 , NM
        176     2       2v                    IF(IEM(IM).EQ.0) GO TO 450
        177     3       2v                    IF(XM(IM).LT.XMINMK .OR. XM(IM).GT.XMAXMK. OR.
        178     3                    &           YM(IM).LT.YMINMK .OR. YM(IM).GT.YMAXMK) THEN
        179     3       2m                        NLOST = NLOST+1
        180     3               C TEMORARY DELETED 88/03/19
        181     3               C                 IF(NLOST.LE.MLOST) THEN
        182     3               C TEMORARY DELETED 88/03/19
        183     3       2s                            LLOST(NLOST) = IM
        184     3               C TEMORARY DELETED 88/03/19
        185     3               C                 ENDIF
        186     3               C TEMORARY DELETED 88/03/19
        187     3       2v                    ENDIF
        188     2       2v        450     CONTINUE
        189     1                     ENDIF
        190                     C
        191     1                     IF(NLOST.GT.MLOST) THEN
        192     1                         WRITE(IUT0,6300) ERMSG
        193     1                         WRITE(IUT0,6300) EREXP2
        194     1                         IERR = 1
        195     1                         RETURN
        196     1                     ENDIF
        197                     C
        198                     C      (4) LOST PARTICLES TRANSACTION
        199                     C
        200     1                     IF(IMODE.EQ.1) THEN
        201     2                         DO 510 ILOST = NLOST , 1 , -1
        202     2                             NM = NM-1
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 696
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 8)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      XM, YM, IEM
                              <<< Loop-information  End >>>
        203     3  pp   2v                    DO 500 IM = LLOST(ILOST) , NM
        204     3   p   2v                        XM(IM) =  XM(IM+1)
        205     3   p   2v                        YM(IM) =  YM(IM+1)
        206     3   p   2v                        IEM(IM) = IEM(IM+1)
        207     3   p   2v        500         CONTINUE
        208     2                 510     CONTINUE
        209     1                     ELSE
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 1.83, ITR: 320, MVE: 3, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LLOST
                              <<< Loop-information  End >>>
        210     2   s   4v                DO 520 ILOST = 1 , NLOST
        211     2   m   4v                    IEM(LLOST(ILOST)) = 0
        212     2   p   4v        520     CONTINUE
        213     1                     ENDIF
        214                     C
        215                     C
        216                           RETURN
        217                      6300 FORMAT(A72)
        218                           END

 Diagnostic messages: program name(MARKF2)
   jwd8220o-i  "markf2.f", line 13: Optimizations is performed in this program unit with possibility of side effects. See informational messages below to determine which such optimizations have been performed.
   jwd5001p-i  "markf2.f", line 95: DO loop with DO variable 'IM' is parallelized.
   jwd6001s-i  "markf2.f", line 95: SIMD conversion is applied to DO loop with DO variable 'IM'.
   jwd8204o-i  "markf2.f", line 95: This loop is software pipelined.
   jwd8205o-i  "markf2.f", line 95: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 88.
   jwd5228p-i  "markf2.f", line 104: DO loop is not parallelized: data dependency of variable may cause different results from serial execution for loop.
   jwd6229s-i  "markf2.f", line 104: SIMD conversion is not applied to DO loop: there are IF statements in the loop.
   jwd8670o-i  "markf2.f", line 104: This loop cannot be software pipelined because the loop contains a branch instruction.
   jwd8209o-i  "markf2.f", line 111: Evaluation order of polynomial expression is changed according to commutative law of addition and multiplication.
   jwd8209o-i  "markf2.f", line 113: Evaluation order of polynomial expression is changed according to commutative law of addition and multiplication.
   jwd5208p-i  "markf2.f", line 137: DO loop is not parallelized: the assign-refer order of 'LOVER' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd6229s-i  "markf2.f", line 139: SIMD conversion is not applied to DO loop: there are IF statements in the loop.
   jwd8670o-i  "markf2.f", line 139: This loop cannot be software pipelined because the loop contains a branch instruction.
   jwd5228p-i  "markf2.f", line 142: DO loop is not parallelized: data dependency of variable may cause different results from serial execution for loop.
   jwd6228s-i  "markf2.f", line 142: SIMD conversion cannot be applied to DO loop: an assign-refer order of data in a SIMD execution may differ from the assign-refer order in the serial execution.
   jwd8209o-i  "markf2.f", line 148: Evaluation order of polynomial expression is changed according to commutative law of addition and multiplication.
   jwd8209o-i  "markf2.f", line 150: Evaluation order of polynomial expression is changed according to commutative law of addition and multiplication.
   jwd5228p-i  "markf2.f", line 161: DO loop is not parallelized: data dependency of variable may cause different results from serial execution for loop.
   jwd6229s-i  "markf2.f", line 161: SIMD conversion is not applied to DO loop: there are IF statements in the loop.
   jwd8670o-i  "markf2.f", line 161: This loop cannot be software pipelined because the loop contains a branch instruction.
   jwd8202o-i  "markf2.f", line 161: Loop unrolled 2 times.
   jwd5228p-i  "markf2.f", line 175: DO loop is not parallelized: data dependency of variable may cause different results from serial execution for loop.
   jwd6229s-i  "markf2.f", line 175: SIMD conversion is not applied to DO loop: there are IF statements in the loop.
   jwd8670o-i  "markf2.f", line 175: This loop cannot be software pipelined because the loop contains a branch instruction.
   jwd8202o-i  "markf2.f", line 175: Loop unrolled 2 times.
   jwd5202p-i  "markf2.f", line 201: DO loop is not parallelized: data dependency of variable 'NM' may cause different results from serial execution for loop.
   jwd5208p-i  "markf2.f", line 201: DO loop is not parallelized: the assign-refer order of 'YM' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "markf2.f", line 201: DO loop is not parallelized: the assign-refer order of 'XM' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "markf2.f", line 201: DO loop is not parallelized: the assign-refer order of 'IEM' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5001p-i  "markf2.f", line 203: DO loop with DO variable 'IM' is parallelized.
   jwd6001s-i  "markf2.f", line 203: SIMD conversion is applied to DO loop with DO variable 'IM'.
   jwd8663o-i  "markf2.f", line 203: This loop is not software pipelined because the software pipelining does not improve the performance.
   jwd8202o-i  "markf2.f", line 203: Loop unrolled 2 times.
   jwd6001s-i  "markf2.f", line 210: SIMD conversion is applied to DO loop with DO variable 'ILOST'.
   jwd8204o-i  "markf2.f", line 210: This loop is software pipelined.
   jwd8205o-i  "markf2.f", line 210: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 320.
   jwd5228p-i  "markf2.f", line 211: DO loop is not parallelized: data dependency of variable may cause different results from serial execution for loop.

 Procedure information
   Lines      : 218
   Statements : 92
   Stack(byte): 1760
   Prefetch num: 0

 Total information
   Procedures       : 1
   Total lines      : 218
   Total statements : 92
   Total stack(byte): 1760
   Total prefetch num: 0

