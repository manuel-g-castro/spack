C======================================================================C
C                                                                      C
C SOFTWARE NAME : FRONTFLOW/BLUE-ACOUSTICS                             C
C                                                                      C
C  SUB ROUTINE  DDCOM3M1                                               C
C                                                                      C
C                                       WRITTEN BY Y.GUO               C
C                                                                      C
C                                                                      C
C CONTACT ADDRESS: IIS, THE UNIVERSITY OF TOKYO, RSS21 PROJECT         C  
C                                                                      C
C MULTI PHYSICS FLOW SIMULATION SYSTEM                                 C
C                                                                      C
C  PERFORMANCE OPTIMIZATION                                            C
C                                                                      C
C                                       MODIFIED BY RIST               C
C======================================================================C
      SUBROUTINE DDCOM3M(IPART,IDIM,LDOM,NBPDOM,NDOM,IPSLF,IPSND,MBPDOM,
     *                  FX,FY,FZ,NP,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LDOM(NDOM),NBPDOM(NDOM),IPSLF(MBPDOM,NDOM),
     1          IPSND(MBPDOM,NDOM)
      COMPLEX*16 FX(NP),FY(NP),FZ(NP),BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDCOM3: FATAL     ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      EXCHANGE X, Y, AND Z RESIDUALS AMONG THE NEIGHBORING SUB-DOMAINS
C     AND SUPERIMPOSE THE EXCHANGED RESIDUALS TO THE CALLING TASK'S
C     RESIDUALS, FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
C                       TAKING CARE OF
C           NOTES ; ARGUMENT 'IPART' IS NOT CURRENTLY USED. IT IS
C                  RETAINED FOR A POSSIBLE FUTURE USE.
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C                            SHARING WITH THE IDOM'TH NEIGHBORING
C                            SUB-DOMAIN, LDOM(IDOM)
C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                            TASK'S RESIDUALS.
C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
C                            (I.E. THE MAXIMUM NUMBER OF THE
C                             INTER-CONNECT BOUNDARY NODES FOR A
C                             NEIGHBORING SUB-DOMAIN)
C INT *4   NP               ; NUMBER OF THE TOTAL NODES IN THE CALLING
C                            TASK'S SUB-DOMAIN
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                             MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                             NUMBER OF INTER-CONNECT BOUNDARY NODES IN
C                             THE CALLING TASK
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C COMPLEX*16   FX(IP)           ; X-DIRECTION RESIDUAL VECTOR
C COMPLEX*16   FY(IP)           ; Y-DIRECTION RESIDUAL VECTOR
C COMPLEX*16   FZ(IP)           ; Z-DIRECTION RESIDUAL VECTOR
C
C       (4) WORK
C COMPLEX*16   BUFSND(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE NEIGHBORING
C                            SUB-DOMAINS AND THE RESIDUALS OF THE
C                            CALLING TASK'S SUB-DOMAIN WHEN SENDING
C                            THE RESIDUALS
C                         
C COMPLEX*16   BUFRCV(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
C                            BOUNDARY NODE NUMBER IN THE CALLING TASK'S
C                            SUB-DOMAIN AND THE RESIDUALS OF THE
C                            NEIGHBORING SUB-DOMAINS AT THE RECEIPT OF
C                            THE RESIDUALS FROM THE NEIGHBORING
C                            SUB-DOMAINS
C
C
      IERR = 0
C
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(2*NDOM.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIVES
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NDOM
          MSGTYP = 1
          IRECV  = LDOM(IDOM)-1
          MSGLEN = 4*NBPDOM(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_COMPLEX16,
     &                   IRECV,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
C
          NSTART = NSTART+MSGLEN
  110 CONTINUE
C
!      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP THE SEND BUFFER
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:200-210")
!CDIR PARALLEL DO PRIVATE(NSTART,IP,IPS)
      DO 210 IDOM = 1 , NDOM
          NSTART  = 0
          DO 205 ITMP = 2 , IDOM
              NSTART = NSTART + NBPDOM(ITMP-1)*4
  205     CONTINUE
!CDIR NOINNER
          DO 200 IBP = 1 , NBPDOM(IDOM)
              IP  = IPSLF(IBP,IDOM)
              IPS = IPSND(IBP,IDOM)
              BUFSND(NSTART+1) = IPS
              BUFSND(NSTART+2) = FX(IP)
              BUFSND(NSTART+3) = FY(IP)
              BUFSND(NSTART+4) = FZ(IP)
              NSTART = NSTART + 4
  200     CONTINUE
  210 CONTINUE
CC    CALL FTRACE_REGION_END("ddcom3:200-210")
C
C
C
C SEND THE RESIDUALS
C
C
C
      NSTART = 1
      DO 220 IDOM = 1 , NDOM
          MSGTYP = 1
          ISEND  = LDOM(IDOM)-1
          MSGLEN = 4*NBPDOM(IDOM)

          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_COMPLEX16,
     &                   ISEND,MSGTYP,
     &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
C
          NSTART = NSTART+MSGLEN 
  220 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(2*NDOM,MSGIDS,MSGSTS,IERR)
C 
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C
C SUPERIMPOSE THE RECEIVED RESIDUALS
C
C
CC    CALL FTRACE_REGION_BEGIN("ddcom3:300-310")
      NSTARTMP = 0
      DO IDOM = 1 , NDOM
!CDIR NOINNER
        DO IBP = 1, NBPDOM(IDOM)
          IP = BUFRCV(NSTARTMP+1)+0.1
          IF(IP.LT.1 .OR. IP.GT.NP) THEN
            IERR = 1
          ENDIF
          NSTARTMP = NSTARTMP + 4
        ENDDO
      ENDDO
C
      IF(IERR .EQ. 1) THEN
        WRITE(IUT0,*) ERMSGB
        WRITE(IUT0,*) EREXP3
        RETURN
      ENDIF
C
      IF(IDIM .GE. 3) THEN
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
            FY(IP) = FY(IP)+BUFRCV(NSTART+3)
            FZ(IP) = FZ(IP)+BUFRCV(NSTART+4)
          ENDDO
      ELSE IF(IDIM .GE. 2) THEN
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
            FY(IP) = FY(IP)+BUFRCV(NSTART+3)
          ENDDO
      ELSE
!CDIR LISTVEC
          DO NSTART = 0, NSTARTMP-4, 4
            IP = BUFRCV(NSTART+1)+0.1
            FX(IP) = FX(IP)+BUFRCV(NSTART+2)
          ENDDO
      ENDIF
C
CC    CALL FTRACE_REGION_END("ddcom3:300-310")
C
      IPART = IPART
C
C
      RETURN
      END
C
      SUBROUTINE DDCOM2M(SEND,RECV)
      IMPLICIT REAL*4(A-H,O-Z)
      COMPLEX*16 SEND,RECV
C
      INCLUDE 'mpif.h'
C
C
C      SUM UP A SINGLE SCALAR AMONG ALL THE PARTICIPATING TASKS FOR
C     DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C COMPLEX*16   SEND             ; SCALAR VARIABLE TO SUM UP
C
C       (2) OUTPUT
C COMPLEX*16   RECV             ; SCALAR VARIABLE SUMMED UP AMONG ALL TASKS
C
C
          CALL MPI_ALLREDUCE(SEND,RECV,1,MPI_COMPLEX16,MPI_SUM,
     &                       MPI_COMM_WORLD,IERR)
C
C
      RETURN
      END
C
      SUBROUTINE DDCOM2V(SEND,RECV,N)
      IMPLICIT REAL*4(A-H,O-Z)
      COMPLEX*16 SEND(N),RECV(N)
C
      INCLUDE 'mpif.h'
C
C
C      SUM UP A SINGLE SCALAR AMONG ALL THE PARTICIPATING TASKS FOR
C     DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C REAL*4   SEND             ; SCALAR VARIABLE TO SUM UP
C
C       (2) OUTPUT
C REAL*4   RECV             ; SCALAR VARIABLE SUMMED UP AMONG ALL TASKS
C
C
          CALL MPI_ALLREDUCE(SEND,RECV,N,MPI_COMPLEX16,MPI_SUM,
     &                       MPI_COMM_WORLD,IERR)
C
C
      RETURN
      END
C
      SUBROUTINE DDSET3M(NSND,LSND,NPTSND,IPSET,IPSRC,VALX,VALY,VALZ,NB,
     *                   NRCV,LRCV,NPTRCV,FX,FY,FZ,NP,
     *                   IDIM,MPT,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LSND(NSND),NPTSND(NSND),IPSET(MPT,NSND),IPSRC(MPT,NSND),
     1          LRCV(NRCV),NPTRCV(NRCV),
     2          VALX(NB),VALY(NB),VALZ(NB),FX(NP),FY(NP),FZ(NP),
     3          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      COMPLEX*16 VALX,VALY,VALZ,FX,FY,FZ,BUFSND,BUFRCV
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDSET3M: FATAL    ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      OVERSET SOME VALUES OF THE PASSED ARRAY ELEMENTS, 
C     FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   NSND             ; NUMBER OF DOMAINS TO SEND OVERSET VALUE
C INT *4   LSND      (IDOM) ; DOMAIN NUMBER     TO SEND OVERSET VALUE
C INT *4   NPTSND    (IDOM) ; NUMBER OF OVERSET POINTS TO SEND TO
C                            SUB-DOMAIN 'LSND(IDOM)'
C INT *4   IPSET (IPT,IDOM) ; OVERSET NODE/ELEMENT NUMBER IN THE
C                            SUB-DOMAIN RECEIVING THE OVERSET VALUES.
C
C INT *4   IPSRC (IPT,IDOM) ; INDICATES POSITION IN THE OVERSET-VALUES
C                            PASSING ARRAYS
C COMPLEX*16   VALX        (IB) ; X-DIRECTION OVERSET VALUES
C COMPLEX*16   VALY        (IB) ; Y-DIRECTION OVERSET VALUES
C COMPLEX*16   VALZ        (IB) ; Z-DIRECTION OVERSET VALUES
C INT *4   NB               ; TOTAL NUMBER OF OVERSET VALUES TO SEND
C
C INT *4   NRCV             ; NUMBER OF DOMAINS TO RECEIVE OVERSET VALUE
C INT *4   LRCV      (IDOM) ; DOMAIN NUMBER     TO RECEIVE OVERSET VALUE
C INT *4   NPTRCV    (IDOM) ; NUMBER OF OVERSET POINTS TO RECEIVE FROM
C                            SUB-DOMAIN 'LRCV(IDOM)'
C INT *4   NP               ; NUMBER OF THE TOTAL NODES/ELEMENTS IN THE
C                            CALLING TASK'S SUB-DOMAIN
C
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C
C INT *4   MPT              ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSET'
C                            (I.E. THE MAXIMUM NUMBER OF THE OVERSET
C                             POINTS FOR A SINGLE SUB-DOMAIN)
C
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                            MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                            NUMBER OF OVERSET POINTS TO SEND OR RECEIVE
C
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C       (3) INPUT-OUTPUT
C COMPLEX*16   FX          (IP) ; X-DIRECTION ARRAY TO OVERSET
C COMPLEX*16   FY          (IP) ; Y-DIRECTION ARRAY TO OVERSET
C COMPLEX*16   FZ          (IP) ; Z-DIRECTION ARRAY TO OVERSET
C
C       (4) WORK
C COMPLEX*16   BUFSND(IBUF)     ; HOLDS THE OVERSET VALUES AND OVERSET NODE/
C                            ELEMENT NUMBERS IN THE SUB-DOMAIN RECEIVING
C                            THEM WHEN SENDING OVERSET VALUES
C                         
C COMPLEX*16   BUFRCV(IBUF)     ; HOLDS THE OVERSET VALUES AND OVERSET NODE/
C                            ELEMENT NUMBERS IN THE CALLING TASK'S 
C                            SUB-DOMAIN AT THE RECEIPT OF THE OVERSET
C                            VALUES
C
C
      IERR = 0
C
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(NRCV+NSND.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIPTS
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NRCV
          MSGTYP = 2
          IRECV  = LRCV(IDOM)-1
          MSGLEN = 4*NPTRCV(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_COMPLEX16,IRECV,
     &                   MSGTYP,MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
C
          NSTART = NSTART+MSGLEN 
  110 CONTINUE
C
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP SEND BUFFER AND SEND OVERSET VALUES FOR EACH DOMAIN
C
C
C
      NSTART = 1
      DO 210 IDOM = 1 , NSND
          MSGTYP = 2
          ISEND  = LSND(IDOM)-1
          MSGLEN = 4*NPTSND(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
          DO 200 IPT = 1 , NPTSND(IDOM)
              BUFSND(NSTART+4*(IPT-1)  ) = IPSET(IPT,IDOM)
              BUFSND(NSTART+4*(IPT-1)+1) = VALX(IPSRC(IPT,IDOM))
              BUFSND(NSTART+4*(IPT-1)+2) = VALY(IPSRC(IPT,IDOM))
              BUFSND(NSTART+4*(IPT-1)+3) = VALZ(IPSRC(IPT,IDOM))
  200     CONTINUE
C
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_COMPLEX16,ISEND,
     &                   MSGTYP,MPI_COMM_WORLD,MSGIDS(NRCV+IDOM),IERR)
C
          NSTART = NSTART+MSGLEN 
  210 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(NRCV+NSND,MSGIDS,MSGSTS,IERR)
C
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C 
C OVERSET WITH THE RECEIVED VALUES
C 
C 
C 
      NSTART = 1
      DO 310 IDOM = 1 , NRCV
          DO 300 IPT = 1 , NPTRCV(IDOM)
              IP = BUFRCV(NSTART)+0.1
C
              IF(IP.LT.1 .OR. IP.GT.NP) THEN
                  WRITE(IUT0,*) ERMSGB
                  WRITE(IUT0,*) EREXP3
                  IERR = 1
                  RETURN
              ENDIF
C
                            FX(IP) = BUFRCV(NSTART+1)
              IF(IDIM.GE.2) FY(IP) = BUFRCV(NSTART+2)
              IF(IDIM.GE.3) FZ(IP) = BUFRCV(NSTART+3)
              NSTART = NSTART+4
  300     CONTINUE
  310 CONTINUE
C
C
      RETURN
      END
C
      SUBROUTINE DDSET0C(LPSET1,LPSET3,NPSET,MPT,MDOM,IUT0,
     *                   NSND,LSND,NPTSND,IPSET,IPSRC,
     *                   NRCV,LRCV,NPTRCV,LISTS,L1,L2,L3,IERR)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LPSET1(NPSET),LPSET3(NPSET),
     1          LSND(MDOM),NPTSND(MDOM),IPSET(MPT,MDOM),IPSRC(MPT,MDOM),
     2          LRCV(MDOM),NPTRCV(MDOM),LISTS(NPSET),
     3          L1(NPSET),L2(NPSET),L3(NPSET)
C
C
      CHARACTER*60 ERMSGB
C
     & / ' ## SUBROUTINE DDSET0C: FATAL    ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF PASSED LIST ARRAYS IS NOT SUFFICIENT    ' /
C
C
C      SET UP OVERSET SUB-DOMAIN LISTS FOR DOMAIN-DECOMPOSITION
C     PROGRAMMING MODEL
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   LPSET1  (IB); OVERSET BOUNDARY NODES/ELEMENTS
C INT *4   LPSET3  (IB); DOMAIN NUMBER TO SEND/RECEIVE OVERSET VALUES
C                   0 --- CALCULATE AND SET OVERSET VALUE WITHIN THE
C                         SELF-DOMAIN
C          (POS. INT.)--- SEND    OVERSET VALUE TO   DOMAIN  LPSET3(IB)
C                         AFTER CALCULATING IT WITHIN THE SELF-DOMAIN
C          (NEG. INT.)--- RECEIVE OVERSET VALUE FROM DOMAIN -LPSET3(IB)
C          NPSET       ; NUMBER OF OVERSET BOUNDARY NODES/ELEMENTS
C
C INT *4   MPT              ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSET'
C                            (I.E. THE MAXIMUM NUMBER OF THE OVERSET
C                             POINTS FOR A SINGLE SUB-DOMAIN)
C INT *4   MDOM             ; MAX. NUMBER OF THE OVERSET SUB-DOMAINS
C
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   NSND             ; NUMBER OF DOMAINS TO SEND OVERSET VALUE
C INT *4   LSND      (IDOM) ; DOMAIN NUMBER     TO SEND OVERSET VALUE
C INT *4   NPTSND    (IDOM) ; NUMBER OF OVERSET POINTS TO SEND TO
C                            SUB-DOMAIN 'LSND(IDOM)'
C INT *4   IPSET (IPT,IDOM) ; OVERSET NODE/ELEMENT NUMBER IN THE
C                            SUB-DOMAIN RECEIVING THE OVERSET VALUES.
C INT *4   IPSRC (IPT,IDOM) ; INDICATES POSITION IN THE OVERSET-VALUES
C                            PASSING ARRAYS WHEN OVERSET CONDITIONS DATA
C                            ARE COMPILED SEQUENTIALLY
C
C INT *4   NRCV             ; NUMBER OF DOMAINS TO RECEIVE OVERSET VALUE
C INT *4   LRCV      (IDOM) ; DOMAIN NUMBER     TO RECEIVE OVERSET VALUE
C INT *4   NPTRCV    (IDOM) ; NUMBER OF OVERSET POINTS TO RECEIVE FROM
C                            SUB-DOMAIN 'LRCV(IDOM)'
C
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C
      IERR = 0
C
C
C
C SET INITIAL VALUES
C
C
C
      NSND = 0
      NRCV = 0
      DO 100 IDOM = 1 , MDOM
          NPTSND(IDOM) = 0
          NPTRCV(IDOM) = 0
  100 CONTINUE
C
C
C
C SET DOMAIN LISTS FOR SEND
C
C
C
      NDUM = 0
      DO 230 IBP = 1 , NPSET
          IF(LPSET3(IBP).LE.0) GO TO 230
C
          NDUM = NDUM+1
C
          IFNEW = LPSET3(IBP)
          DO 210 ICHK = 1 , NSND
              IF(LSND(ICHK).EQ.IFNEW) THEN
                  IDOM = ICHK
                  GO TO 220
              ENDIF
  210     CONTINUE
          NSND = NSND+1
          IDOM = NSND
C
          IF(NSND.GT.MDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          LSND(NSND) = IFNEW
C
  220     CONTINUE
          NPTSND(IDOM) = NPTSND(IDOM)+1
C
          IF(NPTSND(IDOM).GT.MPT) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          IPSET(NPTSND(IDOM),IDOM) = LPSET1(IBP)
          IPSRC(NPTSND(IDOM),IDOM) = NDUM
  230 CONTINUE
C
C
C
C SET DOMAIN LISTS FOR RECEIVE
C
C
C
      DO 330 IBP = 1 , NPSET
          IF(LPSET3(IBP).GE.0) GO TO 330
          IFNEW = -LPSET3(IBP)
          DO 310 ICHK = 1 , NRCV
              IF(LRCV(ICHK).EQ.IFNEW) THEN
                  IDOM = ICHK
                  GO TO 320
              ENDIF
  310     CONTINUE
          NRCV = NRCV+1
          IDOM = NRCV
C
          IF(NRCV.GT.MDOM) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP1
              IERR = 1
              RETURN
          ENDIF
C
          LRCV(NRCV) = IFNEW
C
  320     CONTINUE
          NPTRCV(IDOM) = NPTRCV(IDOM)+1
C
          L1(IBP) = IDOM
          L2(IBP) = NPTRCV(IDOM) 
  330 CONTINUE
C
      L3(1) = 0
      DO 340 IDOM = 2, NRCV
          L3(IDOM) = L3(IDOM-1) + NPTRCV(IDOM-1) 
  340 CONTINUE 
C
      DO 350 IBP = 1 , NPSET
          IF(LPSET3(IBP).GE.0) GO TO 350
          LISTS(IBP) = L3(L1(IBP))+L2(IBP)
  350 CONTINUE
C
C
      RETURN
      END
C
      SUBROUTINE DDSET3C(NSND,LSND,NPTSND,IPSET,IPSRC,VALX,VALY,VALZ,NB,
     *                   NRCV,LRCV,NPTRCV,FX,FY,FZ,NP,
     *                   IDIM,MPT,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
      IMPLICIT REAL*4(A-H,O-Z)
      DIMENSION LSND(NSND),NPTSND(NSND),IPSET(MPT,NSND),IPSRC(MPT,NSND),
     1          LRCV(NRCV),NPTRCV(NRCV),
     2          VALX(NB),VALY(NB),VALZ(NB),FX(NP),FY(NP),FZ(NP),
     3          BUFSND(MAXBUF),BUFRCV(MAXBUF)
C
      COMPLEX*16 VALX,VALY,VALZ,FX,FY,FZ,BUFSND,BUFRCV
C
      INCLUDE 'mpif.h'
C
      PARAMETER ( MAXDOM = 10000 )
      INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
C
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE DDSET3C: FATAL    ERROR OCCURRENCE; RETURNED' /
      CHARACTER*60 EREXP1
     & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP2
     & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
      CHARACTER*60 EREXP3
     & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
C
C
C      OVERSET SOME VALUES OF THE PASSED ARRAY ELEMENTS, 
C     FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
C
C                            ( MPI VERSION )
C
C
C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
C
C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA 
C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH 
C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
C
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C INT *4   NSND             ; NUMBER OF DOMAINS TO SEND OVERSET VALUE
C INT *4   LSND      (IDOM) ; DOMAIN NUMBER     TO SEND OVERSET VALUE
C INT *4   NPTSND    (IDOM) ; NUMBER OF OVERSET POINTS TO SEND TO
C                            SUB-DOMAIN 'LSND(IDOM)'
C INT *4   IPSET (IPT,IDOM) ; OVERSET NODE/ELEMENT NUMBER IN THE
C                            SUB-DOMAIN RECEIVING THE OVERSET VALUES.
C
C INT *4   IPSRC (IPT,IDOM) ; INDICATES POSITION IN THE OVERSET-VALUES
C                            PASSING ARRAYS
C COMPLEX*16   VALX        (IB) ; X-DIRECTION OVERSET VALUES
C COMPLEX*16   VALY        (IB) ; Y-DIRECTION OVERSET VALUES
C COMPLEX*16   VALZ        (IB) ; Z-DIRECTION OVERSET VALUES
C INT *4   NB               ; TOTAL NUMBER OF OVERSET VALUES TO SEND
C
C INT *4   NRCV             ; NUMBER OF DOMAINS TO RECEIVE OVERSET VALUE
C INT *4   LRCV      (IDOM) ; DOMAIN NUMBER     TO RECEIVE OVERSET VALUE
C INT *4   NPTRCV    (IDOM) ; NUMBER OF OVERSET POINTS TO RECEIVE FROM
C                            SUB-DOMAIN 'LRCV(IDOM)'
C INT *4   NP               ; NUMBER OF THE TOTAL NODES/ELEMENTS IN THE
C                            CALLING TASK'S SUB-DOMAIN
C
C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
C
C INT *4   MPT              ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
C                            OF THE PASSED ARRAYS 'IPSET'
C                            (I.E. THE MAXIMUM NUMBER OF THE OVERSET
C                             POINTS FOR A SINGLE SUB-DOMAIN)
C
C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
C                            MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
C                            NUMBER OF OVERSET POINTS TO SEND OR RECEIVE
C
C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
C
C       (2) OUTPUT
C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
C
C INT *4   LIST             ; INDEX FOR OVERSET ELEMENTS
C
C       (3) INPUT-OUTPUT
C COMPLEX*16   FX          (IP) ; X-DIRECTION ARRAY TO OVERSET
C COMPLEX*16   FY          (IP) ; Y-DIRECTION ARRAY TO OVERSET
C COMPLEX*16   FZ          (IP) ; Z-DIRECTION ARRAY TO OVERSET
C
C       (4) WORK
C COMPLEX*16   BUFSND(IBUF)     ; HOLDS THE OVERSET VALUES AND OVERSET NODE/
C                            ELEMENT NUMBERS IN THE SUB-DOMAIN RECEIVING
C                            THEM WHEN SENDING OVERSET VALUES
C                         
C COMPLEX*16   BUFRCV(IBUF)     ; HOLDS THE OVERSET VALUES AND OVERSET NODE/
C                            ELEMENT NUMBERS IN THE CALLING TASK'S 
C                            SUB-DOMAIN AT THE RECEIPT OF THE OVERSET
C                            VALUES
C
C
      IERR = 0
C
C
C
C CHECK THE INTERNAL ARRAY SIZE
C
C
C
      IF(NRCV+NSND.GT.MAXDOM) THEN
          WRITE(IUT0,*) ERMSGB
          WRITE(IUT0,*) EREXP1
          IERR = 1
          RETURN
      ENDIF
C
C
C
C POST ALL THE EXPECTED RECEIPTS
C
C
C
      NSTART = 1
      DO 110 IDOM = 1 , NRCV
          MSGTYP = 2
          IRECV  = LRCV(IDOM)-1
          MSGLEN = 4*NPTRCV(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
          CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_COMPLEX16,IRECV,
     &                   MSGTYP,MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
C
          NSTART = NSTART+MSGLEN 
  110 CONTINUE
C
      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
C
C
C
C SET UP SEND BUFFER AND SEND OVERSET VALUES FOR EACH DOMAIN
C
C
C
      NSTART = 1
      DO 210 IDOM = 1 , NSND
          MSGTYP = 2
          ISEND  = LSND(IDOM)-1
          MSGLEN = 4*NPTSND(IDOM)
C
          IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
              WRITE(IUT0,*) ERMSGB
              WRITE(IUT0,*) EREXP2
              IERR = 1
              RETURN
          ENDIF
C
          DO 200 IPT = 1 , NPTSND(IDOM)
              BUFSND(NSTART+4*(IPT-1)  ) = IPSET(IPT,IDOM)
              BUFSND(NSTART+4*(IPT-1)+1) = VALX(IPSRC(IPT,IDOM))
              BUFSND(NSTART+4*(IPT-1)+2) = VALY(IPSRC(IPT,IDOM))
              BUFSND(NSTART+4*(IPT-1)+3) = VALZ(IPSRC(IPT,IDOM))
  200     CONTINUE
C
          CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_COMPLEX16,ISEND,
     &                   MSGTYP,MPI_COMM_WORLD,MSGIDS(NRCV+IDOM),IERR)
C
          NSTART = NSTART+MSGLEN 
  210 CONTINUE
C
C
C
C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
C
C
C
      CALL MPI_WAITALL(NRCV+NSND,MSGIDS,MSGSTS,IERR)
C
C 
C IMPORTANT NOTES!
C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
C    COMPLETED.
C
C 
C OVERSET WITH THE RECEIVED VALUES
C 
C 
C 
      NSTART = 1
      NSCT = 0
      DO 310 IDOM = 1 , NRCV
          DO 300 IPT = 1 , NPTRCV(IDOM)
              IP = BUFRCV(NSTART)+0.1
              NSCT = NSCT+1
C
              IF(IP.LT.1 .OR. IP.GT.NP) THEN
                  WRITE(IUT0,*) ERMSGB
                  WRITE(IUT0,*) EREXP3
                  IERR = 1
                  RETURN
              ENDIF
C
C              LIST(IP) = NSCT
                            FX(NSCT) = BUFRCV(NSTART+1)
              IF(IDIM.GE.2) FY(NSCT) = BUFRCV(NSTART+2)
              IF(IDIM.GE.3) FZ(NSCT) = BUFRCV(NSTART+3)
              NSTART = NSTART+4
  300     CONTINUE
  310 CONTINUE
C
C
      RETURN
      END
