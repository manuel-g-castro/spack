
 Fujitsu Fortran Version 4.7.0  Tue Dec 21 10:39:33 2021

 Compilation information
   Current directory : /vol0005/hp120295/u00324/FFBs/FFB.63.02.02/lib/src/dd_mpi
   Source file       : ddcomx.f

 Option information
   Command line options : -Kident_mpi -f2004 -I/vol0005/hp120295/u00324/FFB/include -I/include/mpi/fujitsu/ -Kvisimpact,ocl,optmsg=2,openmp -Dcputime -Nlst=t -Cpp -Cfpp -c -I/opt/FJSVxtclanga/.common/MELI026/include/mpi/fujitsu -I/opt/FJSVxtclanga/.common/MELI026/lib64 -Knointentopt
   Cpp options          : -I/vol0005/hp120295/u00324/FFB/include -I/include/mpi/fujitsu/ -Dcputime -I/opt/FJSVxtclanga/.common/MELI026/include/mpi/fujitsu -I/opt/FJSVxtclanga/.common/MELI026/lib64 -Dunix -Dlinux -D__FUJITSU -D__FRT_major__=4 -D__FRT_minor__=7 -D__FRT_patchlevel__=0 -D__FRT_version__="4.7.0" -D__aarch64__ -D__unix -D_OPENMP=201511 -D__frt_version=800 -D__ARM_ARCH=8 -D__ARM_FEATURE_SVE -D__ELF__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -otmp
   Effective options    : -fi -g0 -AE -Fixed -O3 -X08
                          -x0 -xaccept=nomodule_allocatable
                          -KA64FX -KARMV8_3_A -KSVE -Kalign_commons
                          -Kalign_loops -Knoarray_declaration_opt
                          -Kassume=noshortloop -Kassume=nomemory_bandwidth
                          -Kassume=notime_saving_compilation -Kauto
                          -Kautoobjstack -Knocalleralloc -Kcmodel=small
                          -Keval -Keval_noconcurrent -Knoextract_stride_store
                          -Knofenv_access -Kfp_contract -Kfp_relaxed
                          -Kfsimple -Kfz -Khpctag -Kilfunc=procedure
                          -Knointentopt -Klargepage -Kloop_blocking
                          -Kloop_fission -Kloop_nofission_stripmining
                          -Kloop_fission_threshold=50 -Kloop_fusion
                          -Kloop_interchange -Kloop_part_parallel
                          -Kloop_part_simd -Kloop_perfect_nest
                          -Kloop_noversioning -Knolto -Kmfunc=1 -Kocl
                          -Komitfp -Knooptlib_string -Koptmsg=2
                          -Knopc_relative_literal_loads -Kplt -Knopreex
                          -Kprefetch_noconditional -Kprefetch_noindirect
                          -Kprefetch_sequential=auto -Kprefetch_nostride
                          -Kprefetch_cache_level=all -Kprefetch_noinfer
                          -Kprefetch_strong -Kprefetch_strong_L2 -Knopreload
                          -Ksch_post_ra -Ksch_pre_ra -Ksibling_calls
                          -Ksimd=auto -Ksimd_packed_promotion
                          -Ksimd_reduction_product -Ksimd_reg_size=512
                          -Ksimd_nouncounted_loop
                          -Ksimd_use_multiple_structures -Knostriping
                          -Knosubscript_opt -Kswp -Kswp_freg_rate=100
                          -Kswp_ireg_rate=100 -Kswp_preg_rate=100
                          -Kswp_policy=auto -Ktemparraystack -Kunroll
                          -Knounroll_and_jam -Knozfill
                          -Kopenmp -Kopenmp_noassume_norecurrence
                          -Kopenmp_nocollapse_except_innermost
                          -Kopenmp_noordered_reduction -Knoopenmp_simd
                          -Kthreadsafe -Kparallel -Kparallel_nofp_precision
                          -Knoarray_private -Knodynamic_iteration -Kreduction
                          -Kregion_extension
                          -Nallextput -Nalloc_assign
                          -Ncancel_overtime_compilation -Nnocheck_global
                          -Nnocoarray -Nnocompdisp -Nnocopyarg -Nnocoverage
                          -Nfjprof -Nfreealloc -Nf90move -Nnohook_func
                          -Nnohook_time -Nlibomp -Nline -Nlst -Nlst=p -Nlst=t
                          -Nnomallocfree -Nnoobsfun -Nnoprivatealloc
                          -Nquickdbg=noargchk -Nquickdbg=nosubchk
                          -Nquickdbg=noundef -NRnotrap -Nnorecursive
                          -Nnoreordered_variable_stack -Nrt_notune -Nnosave
                          -Nsetvalue=noheap -Nsetvalue=nostack
                          -Nsetvalue=noscalar -Nsetvalue=noarray
                          -Nsetvalue=nostruct -Nuse_rodata

 External subroutine subprogram "DDCOMX"
  (line-no.)(nest)(optimize)
          1                           SUBROUTINE DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,IPSLF,IPSND,MBPDOM,
          2                          *                  FX,FY,FZ,NP,IUT0,IERR,BUFSND,BUFRCV,MAXBUF)
          3                           IMPLICIT REAL*4(A-H,O-Z)
          4                           DIMENSION LDOM(NDOM),NBPDOM(NDOM),IPSLF(MBPDOM,NDOM),
          5                          1          IPSND(MBPDOM,NDOM), FX(NP),FY(NP),FZ(NP),
          6                          2          BUFSND(MAXBUF),BUFRCV(MAXBUF)
          7                     C
          8                           INCLUDE 'mpif.h'
          9                     C
         10                           PARAMETER ( MAXDOM = 10000 )
         11                           INTEGER*4 MSGIDS(MAXDOM),MSGSTS(MPI_STATUS_SIZE,MAXDOM)
         12                     C
         13                     C
         14                           CHARACTER*60 ERMSGB
         15                          & / ' ## SUBROUTINE DDCOMX: FATAL     ERROR OCCURRENCE; RETURNED' /
         16                           CHARACTER*60 EREXP1
         17                          & / ' DIMENSION SIZE OF INTERNAL      ARRAYS IS NOT SUFFICIENT  ' /
         18                           CHARACTER*60 EREXP2
         19                          & / ' DIMENSION SIZE OF PASSED BUFFER ARRAYS IS NOT SUFFICIENT  ' /
         20                           CHARACTER*60 EREXP3
         21                          & / ' RECEIVED NODE NUMBER IS OUT OF THE GLOBAL NODE NUMBER     ' /
         22                     #ifdef USE_TIMER
         23                           include 'timer.h'
         24                           real*8 :: tstart0
         25                     #endif
         26                     C
         27                     C
         28                     C      EXCHANGE X, Y, AND Z RESIDUALS AMONG THE NEIGHBORING SUB-DOMAINS
         29                     C     AND SUPERIMPOSE THE EXCHANGED RESIDUALS TO THE CALLING TASK'S
         30                     C     RESIDUALS, FOR DOMAIN-DECOMPOSITION PROGRAMMING MODEL
         31                     C
         32                     C                            ( MPI VERSION )
         33                     C
         34                     C
         35                     C NOTE 1; ALL 'MPI' ROUTINES RETURN AN ERROR CODE 'IERR' WHICH INDICATES
         36                     C       THE STATUS OF ITS EXECUTION. THIS SUBROUTINE IGNORES SUCH ERROR
         37                     C       CODE AND RETURNS THE SEQUENCE TO THE CALLING PROGRAM UNIT,
         38                     C       REGARDLESS OF THE VALUE OF THE 'MPI' RETURN CODE.
         39                     C
         40                     C NOTE 2; SOME COMPILERS, SUCH AS OFORT90 IN HI-UXMPP, SUPPORT AUTOMATIC
         41                     C       PRECISION EXPANSION, WHERE ALL THE CONSTANTS, VARIABLES AND
         42                     C       ARRAYS OF 4-BYTE PRECISION (REAL*4) ARE AUTOMATICALLY CONVERTED
         43                     C       TO THOSE OF 8-BYTE PRECISION (REAL*8) WITH UNFORMATTED I/O DATA
         44                     C       BEING KEPT AS THEY ARE (IF SO SPECIFIED). WHEN USING SUCH
         45                     C       FEATURES (FUNCTIONS) OF A COMPILER, SPECIAL CARE IS NEEDED
         46                     C       BECAUSE A COUPLE OF MPI SUBROUTINES CALLED IN THIS SUBPROGRAM
         47                     C       ACCEPT THE DATA TYPE (DATA PRECISION) AS THEIR INPUT AND
         48                     C       PERFORM THE OPERATIONS ACCORDING TO THIS INPUT VALUE. THIS
         49                     C       INTERFACE SUPPORTS THE AUTOMATIC PRECISION EXPANSION MENTIONED
         50                     C       ABOVE. IF YOU WISH TO USE SUCH FEATURE, ADD '-DPRECEXP' OPTION
         51                     C       WHEN INVOKING 'cpp' FOR PRI-PROCESSING THIS SOURCE PROGRAM FILE.
         52                     C
         53                     C
         54                     C     ARGUMENT LISTINGS
         55                     C       (1) INPUT
         56                     C INT *4   IPART       ; SUB-DOMAIN NUMBER THAT THE CALLING TASK IS
         57                     C                       TAKING CARE OF
         58                     C           NOTES ; ARGUMENT 'IPART' IS NOT CURRENTLY USED. IT IS
         59                     C                  RETAINED FOR A POSSIBLE FUTURE USE.
         60                     C INT *4   IDIM             ; SPACE DIMENSION ( 1, 2, OR 3 )
         61                     C INT *4   LDOM      (IDOM) ; NEIGHBORING SUB-DOMAIN NUMBER
         62                     C INT *4   NBPDOM    (IDOM) ; NUMBER OF INTER-CONNECT BOUNDARY NODES
         63                     C                            SHARING WITH THE IDOM'TH NEIGHBORING
         64                     C                            SUB-DOMAIN, LDOM(IDOM)
         65                     C INT *4   NDOM             ; NUMBER OF THE NEIGHBORING SUB-DOMAINS
         66                     C INT *4   IPSLF (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
         67                     C                            CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
         68                     C                            NEIGHBORING SUB-DOMAIN, LDOM(IDOM)
         69                     C INT *4   IPSND (IBP,IDOM) ; INTER-CONNECT BOUNDARY NODE NUMBER IN THE
         70                     C                            SUB-DOMAIN THAT IS RECEIVING THE CALLING
         71                     C                            TASK'S RESIDUALS.
         72                     C INT *4   MBPDOM           ; THE DIMENSION SIZE OF THE FIRST ELEMENTS
         73                     C                            OF THE PASSED ARRAYS 'IPSLF' AND 'IPSND'
         74                     C                            (I.E. THE MAXIMUM NUMBER OF THE
         75                     C                             INTER-CONNECT BOUNDARY NODES FOR A
         76                     C                             NEIGHBORING SUB-DOMAIN)
         77                     C INT *4   NP               ; NUMBER OF THE TOTAL NODES IN THE CALLING
         78                     C                            TASK'S SUB-DOMAIN
         79                     C INT *4   IUT0             ; FILE NUMBER TO WRITE ERROR MESSAGE
         80                     C INT *4   MAXBUF           ; LENGTH OF THE PASSED COMMUNICATION BUFFERS
         81                     C                            'BUFSND' AND 'BUFRCV' IN WORDS. 'MAXBUF'
         82                     C                             MUST BE NO SMALLER THAN 4 TIMES THE TOTAL
         83                     C                             NUMBER OF INTER-CONNECT BOUNDARY NODES IN
         84                     C                             THE CALLING TASK
         85                     C
         86                     C       (2) OUTPUT
         87                     C INT *4   IERR             ; RETURN CODE WHOSE VALUE WILL BE EITHER
         88                     C                   0 --- INDICATING SUCCESSFUL TERMINATION
         89                     C                OR 1 --- INDICATING OCCURRENCE OF SOME ERROR CONDITIONS
         90                     C
         91                     C       (3) INPUT-OUTPUT
         92                     C REAL*4   FX(IP)           ; X-DIRECTION RESIDUAL VECTOR
         93                     C REAL*4   FY(IP)           ; Y-DIRECTION RESIDUAL VECTOR
         94                     C REAL*4   FZ(IP)           ; Z-DIRECTION RESIDUAL VECTOR
         95                     C
         96                     C       (4) WORK
         97                     C REAL*4   BUFSND(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
         98                     C                            BOUNDARY NODE NUMBER IN THE NEIGHBORING
         99                     C                            SUB-DOMAINS AND THE RESIDUALS OF THE
        100                     C                            CALLING TASK'S SUB-DOMAIN WHEN SENDING
        101                     C                            THE RESIDUALS
        102                     C
        103                     C REAL*4   BUFRCV(IBUF)     ; HOLDS THE VALUES OF THE INTER-CONNECT
        104                     C                            BOUNDARY NODE NUMBER IN THE CALLING TASK'S
        105                     C                            SUB-DOMAIN AND THE RESIDUALS OF THE
        106                     C                            NEIGHBORING SUB-DOMAINS AT THE RECEIPT OF
        107                     C                            THE RESIDUALS FROM THE NEIGHBORING
        108                     C                            SUB-DOMAINS
        109                     
        110                     
        111                     
        112                           !-----------------------------------------------------
        113                           ! before barrier
        114                           !-----------------------------------------------------
        115                     #ifdef USE_BARRIER
        116                     #ifdef USE_TIMER
        117                           tstart   = MPI_WTIME()
        118                           tstart0  = tstart
        119                           nddcomxb = nddcomxb + 1
        120                     #endif
        121                           call MPI_BARRIER(MPI_COMM_WORLD, IERR)
        122                     #ifdef USE_TIMER
        123                           tend = MPI_WTIME()
        124                           tddcomxb = tddcomxb + (tend - tstart)
        125                     #endif
        126                     #endif
        127                     
        128                     
        129                     
        130                           !-----------------------------------------------------
        131                           ! ddcomx1 (pre-check part)
        132                           !-----------------------------------------------------
        133                     #ifdef USE_TIMER
        134                           tstart  = MPI_WTIME()
        135                           nddcomx = nddcomx + 1
        136                     #endif
        137                     #ifdef USE_DETAIL
        138                     C     call start_collection('ddcomx1')
        139                     #endif
        140                           IERR = 0
        141                     
        142     1                     IF(IDIM.EQ.0) THEN
        143     1                         NSKIP=1
        144     1                     ELSE IF(IDIM.EQ.1) THEN
        145     1                         NSKIP=1
        146     1                     ELSE IF(IDIM.EQ.2) THEN
        147     1                         NSKIP=2
        148     1                     ELSE IF(IDIM.EQ.3) THEN
        149     1                         NSKIP=3
        150     1                     ELSE
        151     1                         WRITE(IUT0,*) EREXP1
        152     1                         IERR = 1
        153     1                         RETURN
        154     1                     ENDIF
        155                     C
        156                     C
        157                     C CHECK THE INTERNAL ARRAY SIZE
        158                     C
        159                     C
        160                     C
        161     1                     IF(2*NDOM.GT.MAXDOM) THEN
        162     1                         WRITE(IUT0,*) ERMSGB
        163     1                         WRITE(IUT0,*) EREXP1
        164     1                         IERR = 1
        165     1                         RETURN
        166     1                     ENDIF
        167                     
        168                     #ifdef USE_DETAIL
        169                           call stop_collection('ddcomx1')
        170                     #endif
        171                     #ifdef USE_TIMER
        172                           tend = MPI_WTIME()
        173                           tddcomx1 = tddcomx1 + (tend - tstart)
        174                           tstart = tend
        175                     #endif
        176                     
        177                     
        178                     
        179                           !-----------------------------------------------------
        180                           ! ddcomx2 (mpi_irecv)
        181                           !-----------------------------------------------------
        182                     C
        183                     C
        184                     C
        185                     C POST ALL THE EXPECTED RECEIVES
        186                     C
        187                     C
        188                     C
        189                           NSTART = 1
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LDOM, NBPDOM
                              <<<    SPILLS :
                              <<<      GENERAL   : SPILL 1  FILL 6
                              <<<      SIMD&FP   : SPILL 0  FILL 0
                              <<<      SCALABLE  : SPILL 0  FILL 0
                              <<<      PREDICATE : SPILL 0  FILL 0
                              <<< Loop-information  End >>>
        190     1                     DO 110 IDOM = 1 , NDOM
        191     1                         MSGTYP = 1
        192     1                         IRECV  = LDOM(IDOM)-1
        193     1                         MSGLEN = NSKIP*NBPDOM(IDOM)
        194     1               C
        195     2                         IF(NSTART+MSGLEN-1.GT.MAXBUF) THEN
        196     2                             WRITE(IUT0,*) ERMSGB
        197     2                             WRITE(IUT0,*) EREXP2
        198     2                             IERR = 1
        199     2                             RETURN
        200     2                         ENDIF
        201     1               C
        202     1               #ifdef PRECEXP
        203     1                         CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL8,IRECV,MSGTYP,
        204     1                    &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
        205     1               #else
        206     1                         CALL MPI_IRECV(BUFRCV(NSTART),MSGLEN,MPI_REAL ,IRECV,MSGTYP,
        207     1                    &                   MPI_COMM_WORLD,MSGIDS(IDOM),IERR)
        208     1               #endif
        209     1               C
        210     1                         NSTART = NSTART+MSGLEN
        211     1                 110 CONTINUE
        212                     #ifdef USE_TIMER
        213                           tend     = MPI_WTIME()
        214                           tddcomx2 = tddcomx2 + (tend - tstart)
        215                           tstart   = tend
        216                     #endif
        217                     
        218                     
        219                     
        220                           !-----------------------------------------------------
        221                           ! ddcomx3 (packing to send buffer
        222                           !-----------------------------------------------------
        223                     #ifdef USE_DETAIL
        224                     C     call start_collection('ddcomx3')
        225                     #endif
        226                     C
        227                     !      CALL MPI_BARRIER(MPI_COMM_WORLD,IERR)
        228                     C
        229                     C
        230                     C
        231                     C SET UP THE SEND BUFFER
        232                     C
        233                     C
        234                     CC    CALL FTRACE_REGION_BEGIN("ddcom3:200-210")
        235                     !CDIR PARALLEL DO PRIVATE(NSTART,IP,IPS)
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSND, IPSLF
                              <<< Loop-information  End >>>
        236     1                     DO 210 IDOM = 1 , NDOM
        237     1                        NSTART  = 0
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 1600
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<< Loop-information  End >>>
        238     2  pp    v               DO 205 ITMP = 2 , IDOM
        239     2   p    v                  NSTART = NSTART + NBPDOM(ITMP-1)*NSKIP
        240     2   p    v       205     CONTINUE
        241     1               !CDIR NOINNER
        242     2                        IF(IDIM.EQ.0) THEN
        243     2               !ocl norecurrence(BUFSND)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 640
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 3.25, ITR: 320, MVE: 4, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSND
                              <<< Loop-information  End >>>
        244     3  pp   2v                  DO IBP=1,NBPDOM(IDOM)
        245     3   p   2v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        246     3   p   2v                     IP      = IPSLF(IBP,IDOM)
        247     3   p   2v                     IPS     = IPSND(IBP,IDOM)
        248     3   p   2v                     BUFSND(NSTART2+1) = IPS
        249     3   p   2v                  ENDDO
        250     2                        ELSE IF(IDIM.EQ.1) THEN
        251     2               !ocl norecurrence(BUFSND)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 696
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 2.60, ITR: 320, MVE: 4, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSLF
                              <<< Loop-information  End >>>
        252     3  pp   2v                  DO IBP=1,NBPDOM(IDOM)
        253     3   p   2v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        254     3   p   2v                     IP      = IPSLF(IBP,IDOM)
        255     3   p   2v                     BUFSND(NSTART2+1) = FX(IP)
        256     3   p   2v                  ENDDO
        257     2                        ELSE IF(IDIM.EQ.2) THEN
        258     2               !ocl norecurrence(BUFSND)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 552
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 2.62, ITR: 288, MVE: 4, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSLF
                              <<< Loop-information  End >>>
        259     3  pp   2v                  DO IBP=1,NBPDOM(IDOM)
        260     3   p   2v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        261     3   p   2v                     IP      = IPSLF(IBP,IDOM)
        262     3   p   2v                     BUFSND(NSTART2+1) = FX(IP)
        263     3   p   2v                     BUFSND(NSTART2+2) = FY(IP)
        264     3   p   2v                  ENDDO
        265     2                        ELSE IF(IDIM.EQ.3) THEN
        266     2               !ocl norecurrence(BUFSND)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 458
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 2.41, ITR: 192, MVE: 3, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSLF
                              <<< Loop-information  End >>>
        267     3  pp   2v                  DO IBP=1,NBPDOM(IDOM)
        268     3   p   2v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        269     3   p   2v                     IP      = IPSLF(IBP,IDOM)
        270     3   p   2v                     BUFSND(NSTART2+1) = FX(IP)
        271     3   p   2v                     BUFSND(NSTART2+2) = FY(IP)
        272     3   p   2v                     BUFSND(NSTART2+3) = FZ(IP)
        273     3   p   2v                  ENDDO
        274     2                        ENDIF
        275     1                210  CONTINUE
        276                     #ifdef USE_DETAIL
        277                           call stop_collection('ddcomx3')
        278                     #endif
        279                     #ifdef USE_TIMER
        280                           tend     = MPI_WTIME()
        281                           tddcomx3 = tddcomx3 + (tend - tstart)
        282                           tstart   = tend
        283                     #endif
        284                     
        285                     
        286                     
        287                           !-----------------------------------------------------
        288                           ! ddcom4 (MPI_SEND)
        289                           !-----------------------------------------------------
        290                     C
        291                     C
        292                     C
        293                     C SEND THE RESIDUALS
        294                     C
        295                     C
        296                     C
        297                           NSTART = 1
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LDOM, NBPDOM
                              <<<    SPILLS :
                              <<<      GENERAL   : SPILL 1  FILL 4
                              <<<      SIMD&FP   : SPILL 0  FILL 0
                              <<<      SCALABLE  : SPILL 0  FILL 0
                              <<<      PREDICATE : SPILL 0  FILL 0
                              <<< Loop-information  End >>>
        298     1   s    s            DO 220 IDOM = 1 , NDOM
        299     1   s    s                MSGTYP = 1
        300     1   s    s                ISEND  = LDOM(IDOM)-1
        301     1   s    s                MSGLEN = NSKIP*NBPDOM(IDOM)
        302     1               
        303     1               #ifdef PRECEXP
        304     1                         CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL8,ISEND,MSGTYP,
        305     1                    &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
        306     1               #else
        307     1   s    s                CALL MPI_ISEND(BUFSND(NSTART),MSGLEN,MPI_REAL ,ISEND,MSGTYP,
        308     1                    &                   MPI_COMM_WORLD,MSGIDS(NDOM+IDOM),IERR)
        309     1               #endif
        310     1               C
        311     1   s    s                NSTART = NSTART+MSGLEN
        312     1   s    s        220 CONTINUE
        313                     #ifdef USE_TIMER
        314                           tend     = MPI_WTIME()
        315                           tddcomx4 = tddcomx4 + (tend - tstart)
        316                           tstart   = tend
        317                     #endif
        318                     
        319                     
        320                     
        321                           !-----------------------------------------------------
        322                           ! ddcomx5 (MPI_WAITALL)
        323                           !-----------------------------------------------------
        324                     C
        325                     C
        326                     C
        327                     C WAIT FOR THE COMPLETION OF ALL THE REQUESTED COMMUNICATIONS
        328                     C
        329                     C
        330                     C
        331                     #ifdef USE_DETAIL
        332                           call start_collection('ddcomx5')
        333                     #endif
        334                           CALL MPI_WAITALL(2*NDOM,MSGIDS,MSGSTS,IERR)
        335                     #ifdef USE_DETAIL
        336                           call stop_collection('ddcomx5')
        337                     #endif
        338                     #ifdef USE_TIMER
        339                           tend     = MPI_WTIME()
        340                           tddcomx5 = tddcomx5 + (tend - tstart)
        341                           tstart   = tend
        342                     #endif
        343                     
        344                     
        345                     
        346                           !-----------------------------------------------------
        347                           ! ddcomx6 (un-packing from receive buffer)
        348                           !-----------------------------------------------------
        349                     C
        350                     C
        351                     C IMPORTANT NOTES!
        352                     C        AFTER A NON-BLOCKING SEND/RECEIVE ROUTINE, SUCH AS 'MPI_ISEND'
        353                     C    OR 'MPI_IRECV', IS CALLED, THE COMMUNICATION REQUEST CREATED BY
        354                     C    THESE ROUTINES MUST BE FREED EITHER BY EXPLICITLY OR IMPLICITLY.
        355                     C   'MPI_REQUEST_FREE' FREES SUCH REQUEST EXPLICITLY, WHILE A ROUTINE
        356                     C    WHICH IDENTIFIES COMPLETION OF THE REQUEST, SUCH AS 'MPI_WAIT',
        357                     C    'MPI_WAITANY', OR 'MPI_WAITALL' IMPLICITLY FREES THE REQUEST.
        358                     C        THIS INTERFACE PROGRAM USES 'MPI_WAITALL' ROUTINES TO FREE SUCH
        359                     C    REQUESTS. PAY PARTICULAR ATTENTION IF YOU WISH TO, INSTEAD, USE
        360                     C   'MPI_REQUEST_FREE', BECAUSE 'MPI_REQUEST_FREE' FREES THE REQUESTS
        361                     C    REGARDLESS OF THE STATE OF THE PREVIOUSLY CALLED COMMUNICATION
        362                     C    ROUTINES, THUS SOMETIMES FREES REQUESTS WHICH HAVE NOT BEEN
        363                     C    COMPLETED.
        364                     C
        365                     CCTTDEBG
        366                     CCTTDEBG END
        367                     C
        368                     C SUPERIMPOSE THE RECEIVED RESIDUALS
        369                     C
        370                     C
        371                           NSTART = 0
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSND
                              <<< Loop-information  End >>>
        372     1                     DO IDOM = 1 , NDOM
        373     2                        IF(IDIM .EQ. 0) THEN
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 616
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 3.75, ITR: 576, MVE: 6, POL: S)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSND
                              <<< Loop-information  End >>>
        374     3  pp   2v                  DO IBP = 1, NBPDOM(IDOM)
        375     3   p   2v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        376     3   p   2v                     IPSND(IBP,IDOM)=BUFRCV(NSTART2+1)+0.1
        377     3   p   2v                  ENDDO
        378     2                           NSTART = NSTART + NSKIP * NBPDOM(IDOM)
        379     2               
        380     2                        ELSE IF(IDIM .EQ. 1) THEN
        381     2               !ocl norecurrence(FX)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 373
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<< Loop-information  End >>>
        382     3  pp    v                  DO IBP = 1, NBPDOM(IDOM)
        383     3   p    v                     IP = IPSND(IBP,IDOM)
        384     4   p    v                     IF(IP.LT.1 .OR. IP.GT.NP) THEN
        385     4   p    v                        IERR = 1
        386     4   p    v                     ENDIF
        387     3   p    v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        388     3   p    v                     FX(IP) = FX(IP) + BUFRCV(NSTART2+1)
        389     3   p    v                  ENDDO
        390     2                           NSTART = NSTART + NSKIP * NBPDOM(IDOM)
        391     2               
        392     2                        ELSE IF(IDIM .EQ. 2) THEN
        393     2               !ocl norecurrence(FX,FY)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 302
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<< Loop-information  End >>>
        394     3  pp    v                  DO IBP = 1, NBPDOM(IDOM)
        395     3   p    v                     IP = IPSND(IBP,IDOM)
        396     4   p    v                     IF(IP.LT.1 .OR. IP.GT.NP) THEN
        397     4   p    v                        IERR = 1
        398     4   p    v                     ENDIF
        399     3   p    v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        400     3   p    v                     FX(IP) = FX(IP) + BUFRCV(NSTART2+1)
        401     3   p    v                     FY(IP) = FY(IP) + BUFRCV(NSTART2+2)
        402     3   p    v                  ENDDO
        403     2                           NSTART = NSTART + NSKIP * NBPDOM(IDOM)
        404     2               
        405     2                        ELSE IF(IDIM .EQ. 3) THEN
        406     2               #ifdef USE_TIMER
        407     2               C           call start_collection('ddcomx.S.I.3D')
        408     2               #endif
        409     2               !ocl norecurrence(FX,FY,FZ)
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 254
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<< Loop-information  End >>>
        410     3  pp    v                  DO IBP = 1, NBPDOM(IDOM)
        411     3   p    v                     IP = IPSND(IBP,IDOM)
        412     4   p    v                     IF(IP.LT.1 .OR. IP.GT.NP) THEN
        413     4   p    v                        IERR = 1
        414     4   p    v                     ENDIF
        415     3   p    v                     NSTART2 = NSTART + NSKIP * (IBP-1)
        416     3   p    v                     FX(IP) = FX(IP) + BUFRCV(NSTART2+1)
        417     3   p    v                     FY(IP) = FY(IP) + BUFRCV(NSTART2+2)
        418     3   p    v                     FZ(IP) = FZ(IP) + BUFRCV(NSTART2+3)
        419     3   p    v                  ENDDO
        420     2               #ifdef USE_TIMER
        421     2               C           call stop_collection('ddcomx.S.I.3D')
        422     2               #endif
        423     2                           NSTART = NSTART + NSKIP * NBPDOM(IDOM)
        424     2                        ENDIF
        425     1               CCTTDEBG END
        426     1               C
        427     1               C          IF(IDIM.EQ.1) THEN
        428     1               C            FX(IP) = FX(IP)+BUFRCV(NSTART+1)
        429     1               C          ELSE IF(IDIM .EQ. 2) THEN
        430     1               C            FX(IP) = FX(IP)+BUFRCV(NSTART+1)
        431     1               C            FY(IP) = FY(IP)+BUFRCV(NSTART+2)
        432     1               C          ELSE IF(IDIM .EQ. 3) THEN
        433     1               C            FX(IP) = FX(IP)+BUFRCV(NSTART+1)
        434     1               C            FY(IP) = FY(IP)+BUFRCV(NSTART+2)
        435     1               C            FZ(IP) = FZ(IP)+BUFRCV(NSTART+3)
        436     1               C          ENDIF
        437     1                     ENDDO
        438                     C
        439                     #ifdef USE_TIMER
        440                           tend     = MPI_WTIME()
        441                           tddcomx6 = tddcomx6 + (tend - tstart)
        442                           tstart   = tend
        443                     #endif
        444                     
        445                     
        446                     
        447                           !-----------------------------------------------------
        448                           ! after barrier
        449                           !-----------------------------------------------------
        450                     #ifdef USE_BARRIER
        451                     #ifdef USE_TIMER
        452                           tstart   = MPI_WTIME()
        453                           nddcomxa = nddcomxa + 1
        454                     #endif
        455                           call MPI_BARRIER(MPI_COMM_WORLD, IERR)
        456                     #ifdef USE_TIMER
        457                           tend = MPI_WTIME()
        458                           tddcomxa = tddcomxa + (tend - tstart)
        459                     #endif
        460                     #endif
        461                     
        462                     
        463                     
        464     1                     IF(IERR .eq. 1) THEN
        465     1                       WRITE(IUT0,*) ERMSGB
        466     1                       WRITE(IUT0,*) EREXP3
        467     1                       RETURN
        468     1                     ENDIF
        469                     
        470                     #ifdef USE_TIMER
        471                           tend = MPI_WTIME()
        472                           tddcomx0 = tddcomx0 + (tend - tstart0)
        473                     #endif
        474                     C
        475                     C     IPART = IPART
        476                           RETURN
        477                           END

 Diagnostic messages: program name(DDCOMX)
   jwd2008i-i  "ddcomx.f", line 1: Dummy argument 'IPART' not used in this subprogram.
   jwd5131p-i  "ddcomx.f", line 190: DO loop is not parallelized: multiple exits were found in the loop.
   jwd6131s-i  "ddcomx.f", line 190: SIMD conversion cannot be applied to DO loop: multiple exits are found in the loop.
   jwd8664o-i  "ddcomx.f", line 190: This loop cannot be software pipelined because the loop contains an instruction, such as function call, which is not supported by software pipelining.
   jwd5208p-i  "ddcomx.f", line 236: DO loop is not parallelized: the assign-refer order of 'BUFSND' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5004p-i  "ddcomx.f", line 238: DO loop with DO variable 'ITMP' is parallelized. The DO loop contains the reduction operation.
   jwd6004s-i  "ddcomx.f", line 238: SIMD conversion is applied to DO loop with DO variable 'ITMP'. The DO loop contains a reduction operation.
   jwd5001p-i  "ddcomx.f", line 244: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 244: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd8204o-i  "ddcomx.f", line 244: This loop is software pipelined.
   jwd8205o-i  "ddcomx.f", line 244: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 320.
   jwd5001p-i  "ddcomx.f", line 252: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 252: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd8204o-i  "ddcomx.f", line 252: This loop is software pipelined.
   jwd8205o-i  "ddcomx.f", line 252: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 320.
   jwd5001p-i  "ddcomx.f", line 259: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 259: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd8204o-i  "ddcomx.f", line 259: This loop is software pipelined.
   jwd8205o-i  "ddcomx.f", line 259: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 288.
   jwd5001p-i  "ddcomx.f", line 267: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 267: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd8204o-i  "ddcomx.f", line 267: This loop is software pipelined.
   jwd8205o-i  "ddcomx.f", line 267: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 192.
   jwd8664o-i  "ddcomx.f", line 298: This loop cannot be software pipelined because the loop contains an instruction, such as function call, which is not supported by software pipelining.
   jwd5208p-i  "ddcomx.f", line 299: DO loop is not parallelized: the assign-refer order of 'MSGTYP' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd6208s-i  "ddcomx.f", line 299: SIMD conversion cannot be applied to DO loop: the assign-refer order of 'MSGTYP' in a SIMD execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 300: DO loop is not parallelized: the assign-refer order of 'LDOM' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 300: DO loop is not parallelized: the assign-refer order of 'ISEND' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd6208s-i  "ddcomx.f", line 300: SIMD conversion cannot be applied to DO loop: the assign-refer order of 'LDOM' in a SIMD execution may differ from the assign-refer order in the serial execution.
   jwd6208s-i  "ddcomx.f", line 300: SIMD conversion cannot be applied to DO loop: the assign-refer order of 'ISEND' in a SIMD execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 301: DO loop is not parallelized: the assign-refer order of 'NBPDOM' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 301: DO loop is not parallelized: the assign-refer order of 'MSGLEN' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd6208s-i  "ddcomx.f", line 301: SIMD conversion cannot be applied to DO loop: the assign-refer order of 'NBPDOM' in a SIMD execution may differ from the assign-refer order in the serial execution.
   jwd6208s-i  "ddcomx.f", line 301: SIMD conversion cannot be applied to DO loop: the assign-refer order of 'MSGLEN' in a SIMD execution may differ from the assign-refer order in the serial execution.
   jwd5202p-i  "ddcomx.f", line 307: DO loop is not parallelized: data dependency of variable 'NSTART' may cause different results from serial execution for loop.
   jwd5208p-i  "ddcomx.f", line 307: DO loop is not parallelized: the assign-refer order of 'MSGIDS' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 307: DO loop is not parallelized: the assign-refer order of 'IERR' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 307: DO loop is not parallelized: the assign-refer order of 'BUFSND' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5122p-i  "ddcomx.f", line 307: DO loop is not parallelized: a procedure reference was found in the loop.
   jwd6202s-i  "ddcomx.f", line 307: SIMD conversion cannot be applied to DO loop: data dependency of variable 'NSTART' may cause different results from serial execution for loop.
   jwd6122s-i  "ddcomx.f", line 307: SIMD conversion cannot be applied to DO loop: a procedure reference was found in the loop.
   jwd5202p-i  "ddcomx.f", line 372: DO loop is not parallelized: data dependency of variable 'IERR' may cause different results from serial execution for loop.
   jwd5202p-i  "ddcomx.f", line 372: DO loop is not parallelized: data dependency of variable 'NSTART' may cause different results from serial execution for loop.
   jwd5208p-i  "ddcomx.f", line 372: DO loop is not parallelized: the assign-refer order of 'IPSND' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 372: DO loop is not parallelized: the assign-refer order of 'FZ' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 372: DO loop is not parallelized: the assign-refer order of 'FY' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5208p-i  "ddcomx.f", line 372: DO loop is not parallelized: the assign-refer order of 'FX' in a parallel execution may differ from the assign-refer order in the serial execution.
   jwd5001p-i  "ddcomx.f", line 374: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 374: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd8204o-i  "ddcomx.f", line 374: This loop is software pipelined.
   jwd8205o-i  "ddcomx.f", line 374: The software-pipelined loop is chosen at run time when the iteration count is greater than or equal to 576.
   jwd5001p-i  "ddcomx.f", line 382: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 382: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd5001p-i  "ddcomx.f", line 394: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 394: SIMD conversion is applied to DO loop with DO variable 'IBP'.
   jwd5001p-i  "ddcomx.f", line 410: DO loop with DO variable 'IBP' is parallelized.
   jwd6001s-i  "ddcomx.f", line 410: SIMD conversion is applied to DO loop with DO variable 'IBP'.

 Procedure information
   Lines      : 4506
   Statements : 3394
   Stack(byte): 377904
   Prefetch num: 0

 Total information
   Procedures       : 1
   Total lines      : 4506
   Total statements : 3394
   Total stack(byte): 377904
   Total prefetch num: 0

