C======================================================================C
C                                                                      C
C SOFTWARE NAME : FRONTFLOW_BLUE.8.1                                   C
C                                                                      C
C  SUB ROUTINE : LESSFX                                                C
C                                                                      C
C                                       WRITTEN BY Y.YAMADE            C
C                                                                      C
C                                                                      C
C CONTACT ADDRESS : IIS, THE UNIVERSITY OF TOKYO, CISS                 C
C                                                                      C
C THERMO-FLUID ANALYSIS SOLVERS FOR LARGE-SCALE-ASSEMBLY               C
C                                                                      C
C======================================================================C
      SUBROUTINE LESSFX(LOCAL,NODE,MB,NE,NP,N2,NEX,NS,NSP,N2D,
     *                  X,Y,Z,IMODEL,IVOF,
     *                  MPWALL,NPWALL,LPWALL,LEWALL,NEWALL,
     *                  XNWALL,YNWALL,ZNWALL,YP,
     *                  MPINLT,NPINLT,LPINLT,
     *                  NEINLT,LEINLT,XNINLT,YNINLT,ZNINLT,AEINLT,
     *                  NPSYMT,NPSYM2,LPSYMT,XPSYMT,YPSYMT,ZPSYMT,
     *                  MPFREE,NPFREE,LPFREE,XPFREE,YPFREE,ZPFREE,
     *                  NEFREE,LEFREE,XNFREE,YNFREE,ZNFREE,AEFREE,
     *                  NPCCL ,LPCCL1,LPCCL2,   
     *                  IPART ,MPINT ,NPINT ,LPINT1,LPINT2,LPINT3,
     *                  MDOM  ,NDOM  ,LDOM  ,NBPDOM,MBPDOM,IPSLF,IPSND,
     *                  MPBODY,NPBODY,LPBODY,LEBODY,NEBODY,
     *                  XPBODY,YPBODY,ZPBODY,
     *                  XNBODY,YNBODY,ZNBODY,AEBODY,NODEPS, 
     *                  MBESET,NPSET,NBESET,
     *                  LPSET1,LPSET3,LBESET,AESET,XNESET,YNESET,ZNESET,
     *                  MPHEAT,NPHEAT,LPHEAT,LEHEAT,NEHEAT,
     *                  XPS,YPS,ZPS,LPBTOA,IUT0,IUT6,IERR,RX,RY,
     *                  MWRK,WRK1,WRK2,WRK3,WRK4,WRK5,WRK6,
     *                  IWRK,IWRK2,LWRK01)
      IMPLICIT NONE
      INTEGER*4 LOCAL,NODE,MB,NE,NP,N2,NEX,NS,NSP,N2D,NODEPS,
     *          IMODEL,IVOF,
     *          MPWALL,NPWALL,LPWALL,LEWALL,NEWALL,
     *          MPINLT,NPINLT,LPINLT,NEINLT,LEINLT,
     *          MPFREE,NPFREE,LPFREE,NEFREE,LEFREE,
     *          NPSYMT,NPSYM2,LPSYMT,NPCCL ,LPCCL1,LPCCL2,   
     *          IPART ,MPINT ,NPINT ,LPINT1,LPINT2,LPINT3,
     *          MDOM  ,NDOM  ,LDOM  ,NBPDOM,MBPDOM,IPSLF,IPSND,
     *          MPBODY,NPBODY,LPBODY,LEBODY,NEBODY,
     *          MBESET,NPSET,NBESET,LPSET1,LPSET3,LBESET,
     *          MPHEAT,NPHEAT,LPHEAT,LEHEAT,NEHEAT,
     *          LPBTOA,IUT0,IUT6,IERR,MWRK,IWRK,IWRK2,LWRK01
      REAL*8    X,Y,Z
      REAL*4    XNWALL,YNWALL,ZNWALL,YP,XNINLT,YNINLT,ZNINLT,AEINLT,
     *          XPFREE,YPFREE,ZPFREE,XNFREE,YNFREE,ZNFREE,AEFREE,
     *          XPSYMT,YPSYMT,ZPSYMT,
     *          XPBODY,YPBODY,ZPBODY,XNBODY,YNBODY,ZNBODY,AEBODY,
     *          AESET,XNESET,YNESET,ZNESET,
     *          XPS,YPS,ZPS,RX,RY,WRK1,WRK2,WRK3,WRK4,WRK5,WRK6
      DIMENSION LOCAL(NSP,NS,4),NODE(N2,NE),X(NP),Y(NP),Z(NP),
     *          LPWALL(NPWALL),LEWALL(2,MPWALL),YP    (MPWALL),
     *          XNWALL(MPWALL),YNWALL(MPWALL),ZNWALL(MPWALL),
     *          LPINLT(NPWALL),LEINLT(2,MPINLT),
     *          XNINLT(MPINLT),YNINLT(MPINLT),ZNINLT(MPINLT),
     *          AEINLT(MPINLT),LPSYMT(MB),
     *          LPFREE(NPFREE),LEFREE(2,MPFREE),
     *          XPSYMT(MB),YPSYMT(MB),ZPSYMT(MB),
     *          XPFREE(NPFREE),YPFREE(NPFREE),ZPFREE(NPFREE),
     *          XNFREE(MPFREE),YNFREE(MPFREE),ZNFREE(MPFREE),
     *          AEFREE(MPFREE),
     *          LPBODY(NPBODY),LEBODY(2,MPBODY),AEBODY(MPBODY),
     *          XPBODY(NPBODY),YPBODY(NPBODY),ZPBODY(NPBODY),
     *          XNBODY(MPBODY),YNBODY  (MPBODY),ZNBODY(MPBODY),
     *          NODEPS(N2D,MPBODY),
     *          LPCCL1(NPCCL),LPCCL2(NPCCL) ,
     *          LPSET1(NPSET),LPSET3(NPSET),LBESET(2,MBESET),
     *          AESET(NBESET),XNESET(MBESET),
     *          YNESET(MBESET),ZNESET(MBESET),
     *          LPHEAT(MPHEAT),LEHEAT(2,MPHEAT),
     *          XPS(NPBODY),YPS(NPBODY),ZPS(NPBODY),
     *          WRK1(NE),WRK2(NE),WRK3(NE),WRK4(NP),WRK5(NP),WRK6(NP),
     *          IWRK(MWRK),IWRK2(2,MWRK),RX(0:N2,NE),RY(0:N2,NE),
     *          LWRK01(MWRK)
C
      DIMENSION LPINT1(MPINT),LPINT2(MPINT),LPINT3(MPINT),
     1          LDOM  (MDOM) ,NBPDOM(MDOM) ,
     2          IPSLF(MBPDOM,MDOM),IPSND(MBPDOM,MDOM)
C
      DIMENSION NEX(8)
      INTEGER*4 IOPPSN(8)
      DIMENSION LPBTOA(NP)
C
      CHARACTER*60 WRMSG 
     & / ' ## SUBROUTINE LESSFX: ISSUES A WARNING          ; CONTINUE' /
      CHARACTER*60 WREXP1
     & / ' DOUBLE DEFINED OR ISOLATED BODY SURFACE NODES EXIST       ' /
C
      CHARACTER*60 ERMSGB
     & / ' ## SUBROUTINE LESSFX: FATAL      ERROR OCCURENCE; RETURNED' /
C
      CHARACTER*60 EREXP0
     & / ' INVALID NORMAL VECTOR FOR WALL SURFACE                    ' /
      CHARACTER*60 EREXP3
     & / ' APPEARENTLY WRONG SURFACE EXTRACTED; CHECK MESH DATA      ' /
C
      CHARACTER*60 ERMSGC
     & / ' ## SUBROUTINE LESSFX: FATAL      ERROR REPORT   ; RETURNED' /
C
      REAL*4    EPS
      DATA      EPS  /1.0E-10/
C
      INTEGER*4 MAXBUF,IERRA,IDIM,IDOM,IBP,IPCCL,IPINT1,IPINT2,MLST,
     *          IEWALL,IE,IS,IETYPE,NNPE,I,II,NOPPSN,NESYMT,IP,IESYMT,
     *          NNPS,IEFREE,IPFREE,NPDUM,IEBODY,IPSYMT,IPBODY,
     *          NPSETD,IPB,ISEND
      REAL*8    XWG,YWG,ZWG,XFG,YFG,ZFG,DX,DY,DZ,ABSNOR
C
C
C         ( 3-D CALCULATION : SINGLE WORD & MULTI ELEMENT VERSION )
C                                           CODED BASED ON 'LESSRF'
C
C      DO THE FOLLOWING BOUNDARY CONDITION PREPARATIONS FOR 'LES3D'
C
C
C     (1) GENERATE NEIGHBORING DOMAIN LISTS FOR PARALLEL MODE EXECUTION
C
C     (2) EXTRACT WALL BOUNDARY SURFACES, CALCULATE THEIR NORMALS AND
C        DISTANCE BETWEEN WALL SURFACE AND ITS OPPOSING SURFACE, ASSIGN
C        SURFACE NORMALS TO WALL NODES, GENERATE ADJACENT WALL SURFACE
C        LIST, AND MARK (EXTRACT) CORNER WALL NODES
C
C     (3) EXTRACT SYMMETRIC BOUNDARY SURFACES, CALCULATE THEIR NORMALS,
C        AND ASSIGN SURFACE NORMALS TO SYMMETRIC NODES
C
C     (4) EXTRACT CYCLIC  BOUNDARY SURFACES, CALCULATE THEIR NORMALS AND
C        AREAS, AND CYCLIC BOUNDARY PRESSURE DIFFERENCE
C
C     (5) EXTRACT BODY SURFACES, CALCULATE THEIR NORMALS AND AREAS, AND
C        GENERATE BODY SURFACE NODE TABLE
C
C
C     ARGUMENT LISTINGS
C       (1) INPUT
C          LOCAL (I,IS); NODE NUMBER TABLE DEFINING ELEMENT SURFACES
C          NODE  (I,IE); NODE NUMBER TABLE BASED ON ELEMENT
C          NE          ; NUMBER OF TOTAL ELEMENTS
C          MP          ; MAX. NUMBER OF TOTAL NODES
C           NOTES ; MP DEFINES THE UPPER BOUND OF ARRAYS WRK1 AND WRK2
C          NP          ; NUMBER OF TOTAL    NODES
C          N           ; NUMBER OF NODES ASSIGNED TO ONE ELEMENT
C          N2D          ;NUMBER OF SURFACE ELEMENT DEFINING NODES ( =4 )
C          X       (IP); X-COORDINATE OF GLOBAL NODES
C          Y       (IP); Y-COORDINATE OF GLOBAL NODES
C          Z       (IP); Z-COORDINATE OF GLOBAL NODES
C          P       (IE); ELEMENT PRESSURE
C          GI       (I); LOCAL GZAI  COORDINATES OF ELEMENT'S NODES
C          EI       (I); LOCAL EATA  COORDINATES OF ELEMENT'S NODES
C          TI       (I); LOCAL THETA COORDINATES OF ELEMENT'S NODES
C
C          IMODEL      ; WALL SURFACE EXTRACTION AND NORMAL CALCULATIONS
C                       WILL BE DONE IF THIS FLAG IS SET 1 THROUGH 4
C          NPWALL      ; NUMBER      OF WALL BOUNDARY NODES
C          MPWALL      ; MAX. NUMBER OF WALL BOUNDARY NODES
C          LPWALL (IBP); WALL BOUNDARY NODES
C          MEPWL       ; MAX. NUMBER OF ADJACENT WALL SURFACE  ELEMENTS
C
C          NPSYMT      ; NUMBER OF SYMMETRIC BOUNDARY NODES
C          LPSYMT (IBP); SYMMETRIC BOUNDARY NODES
C
C          NPFREE      ; NUMBER OF FREE BOUNDARY NODES
C          LPFREE (IBP); FREE BOUNDARY NODES
C
C          IPART       ; SUB-DOMAIN NUMBER THAT THIS TASK SHOULD TAKE/IS
C                       TAKING CARE OF. IPART BEING SET ZERO MEANS THAT
C                       THE PROGRAM SHOULD RUN/IS RUNNING IN SERIAL 
C                       MODE.
C          NPINT       ; NUMBER OF INTER-CONNECT BOUNDARY NODES
C          LPINT1 (IBP); INTER-CONNECT BOUNDARY NODES
C          LPINT2 (IBP); CORRESPONDING SUB-DOMAIN NUMBERS
C          LPINT3 (IBP); NODE NUMBER IN THE CORRESPONDING SUB-DOMAINS
C          MDOM        ; MAX. NUMBER OF THE NEIBERING SUB-DOMAINS
C          MBPDOM      ; THE MAXIMUM NUMBER OF THE INTER-CONNECT 
C                       BOUNDARY NODES FOR ONE NEIBERING SUB-DOMAIN
C
C          NPBODY      ; NUMBER      OF BODY BOUNDARY NODES
C          MPBODY      ; MAX. NUMBER OF BODY BOUNDARY NODES
C          LPBODY (IBP); BODY BOUNDARY NODES
C
C          IUT0        ; FILE NUMBER TO WRITE  ERROR MESSAGE
C          IUT6        ; FILE NUMBER TO WRITE  CALCULATION SEQUENCE
C
C       (2) OUTPUT
C          NEWALL      ; NUMBER OF WALL BOUNDARY ELEMENTS
C          LEWALL(I,IBE); WALL BOUNDARY ELEMENT AND ITS SURFACE
C          XNWALL (IBE); X NORMAL OF WALL BOUNDARY SURFACE
C          YNWALL (IBE); Y NORMAL OF WALL BOUNDARY SURFACE
C          ZNWALL (IBE); Z NORMAL OF WALL BOUNDARY SURFACE
C          YP     (IBE); DISTANCE BETWEEN WALL AND ITS OPPOSITE SURFACES
C
C          XPSYMT (IBP); X-DIR COMPONENT OF SYMMETRIC NODE NORMAL VECTOR
C          YPSYMT (IBP); Y-DIR COMPONENT OF SYMMETRIC NODE NORMAL VECTOR
C          ZPSYMT (IBP); Z-DIR COMPONENT OF SYMMETRIC NODE NORMAL VECTOR
C
C          NDOM        ; NUMBER OF THE NERIBERING SUB-DOMAINS
C          LDOM  (IDOM); NEIBERING SUB-DOMAIN NUMBER
C          NBPDOM(IDOM); NUMBER OF INTER-CONNECT BOUNDARY NODES
C                       SHARING WITH THE IDOM'TH NEIBERING SUB-DOMAIN,
C                       LDOM(IDOM)
C          IPSLF (IBP,IDOM); INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                           CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
C                           NEIBERING SUB-DOMAIN, LDOM(IDOM)
C          IPSND (IBP,IDOM); INTER-CONNECT BOUNDARY NODE NUMBER IN THE
C                           SUB-DOMAIN THAT IS RECEIVING THE CALLING
C                           TASK'S RESIDUALS.
C
C          NEBODY      ; NUMBER OF BODY BOUNDARY ELEMENTS
C          LEBODY(I,IBE); BODY BOUNDARY ELEMENT AND ITS SURFACE
C          XNBODY (IBE); X NORMAL OF BODY BOUNDARY SURFACE
C          YNBODY (IBE); Y NORMAL OF BODY BOUNDARY SURFACE
C          ZNBODY (IBE); Z NORMAL OF BODY BOUNDARY SURFACE
C          AEBODY (IBE); AREA     OF BODY BOUNDARY SURFACE
C          NODEPS(I,IBE);BODY SURFACE ELEMENT DEFINING TABLE
C          XPS    (IBP);BODY SURFACE ELEMENT DEFINING NODE X-COORD.
C          YPS    (IBP);BODY SURFACE ELEMENT DEFINING NODE Y-COORD.
C          ZPS    (IBP);BODY SURFACE ELEMENT DEFINING NODE Z-COORD.
C           NOTES ; ORDERING OF BODY SURFACE NODES ABOVE IS DIFFERENT
C                  FROM THAT ORIGINALLY GIVEN BY ARGUMENT 'LPBODY'.
C
C          NBESET       ; NUMBER OF OVERSET BOUNDARY FACES
C          LBESET(I,IBE); OVERSET BOUNDARY ELEMENT AND ITS SURFACE
C          XNESET(  IBE); X NORMAL OF OVERSET BOUNDARY SURFACE
C          YNESET(  IBE); Y NORMAL OF OVERSET BOUNDARY SURFACE
C          ZNESET(  IBE); Z NORMAL OF OVERSET BOUNDARY SURFACE
C
C          IERR        ; RETURN CODE WHOSE VALUE WILL BE EITHER
C                   0 --- INDICATING SUCCESSFUL TERMINATION
C                OR 1 --- INDICATING OCCURENCE OF SOME ERROR CONDITIONS
C
C       (4) WORK
C          WRK1  (IWRK); USED IN SURFEX, COSIN3, DDCOMX
C          WRK2  (IWRK); USED IN SURFEX, DDCOMX
C           NOTES ; GUARANTEE THE UPPER BOUND OF MP FOR WRK1 AND WRK2
C          WRK3  (IWRK); USED IN SURFEX
C          IWRK  (IWRK); USED INTERNALLY, AND IN SURFEX
C          IWRK2(2,IWRK);USED INTERNALLY
C          WRK4  (IWRK); USED INTERNALLY
C         -WRK6  (IWRK); USED INTERNALLY
C          RX    (I,IE); USED IN DDCOMX
C          RY    (I,IE); USED IN DDCOMX
C
C
      NEWALL = 0
C
      MAXBUF = NE*(N2+1)
C
C
C
C  GENERATE NEIGHBORING DOMAIN LISTS FOR PARALLEL EXECUTION
C
C
C
      IF(IPART.GE.1) THEN
          WRITE(IUT6,*)
          WRITE(IUT6,*) ' LESSRF: GENERATING NEIGHBORING DOMAIN LIST'
C
          CALL DDCOM0(LPINT1,LPINT2,LPINT3,NPINT,MDOM,MBPDOM,
     *                LDOM,NBPDOM,NDOM,IPSLF,IPSND,IUT0,IERR)
          CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
          IF(IERRA.NE.0) THEN
              WRITE(IUT0,*)
              WRITE(IUT0,*) ERMSGC
              RETURN
          ENDIF
C
          IDIM = 0
          CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
     *                IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
     *                IUT0,IERR,RX,RY,MAXBUF)
          CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
          IF(IERRA.NE.0) THEN
              WRITE(IUT0,*)
              WRITE(IUT0,*) ERMSGC
              RETURN
          ENDIF
C
C         CONVERTE IPSND FROM BEFOR TO AFTER
          DO 10 IDOM=1,NDOM
             DO 15 IBP=1,NBPDOM(IDOM)
                IPSND(IBP,IDOM)=LPBTOA(IPSND(IBP,IDOM))
 15          CONTINUE
 10       CONTINUE
C
      ELSE IF(NPCCL.NE.0) THEN
          NPINT=NPCCL*2
          DO 50 IPCCL=1,NPCCL
              IPINT1= IPCCL
              IPINT2= IPCCL+NPCCL
              LPINT1(IPINT1) = LPCCL1(IPCCL)
              LPINT1(IPINT2) = LPCCL2(IPCCL)
              LPINT2(IPINT1) = IPART
              LPINT2(IPINT2) = IPART
              LPINT3(IPINT1) = LPCCL2(IPCCL)
              LPINT3(IPINT2) = LPCCL1(IPCCL)
   50     CONTINUE
          CALL DDCOM0(LPINT1,LPINT2,LPINT3,NPINT,MDOM,MBPDOM,
     *                LDOM,NBPDOM,NDOM,IPSLF,IPSND,IUT0,IERR)
          IF(IERR.NE.0) THEN
              WRITE(IUT0,*)
              WRITE(IUT0,*) ERMSGC
              RETURN
          ENDIF
      ENDIF
C
C
C
C  PREPARE FOR WALL BOUNDARY CONDITIONS
C
C
C
C NOTES; ALL TURBULENCE COMPUTATIONS, EXCEPT THAT BASED-ON THE DYNAMIC
C       SMAGORINSKY MODEL, (IMODEL=1, 2, 3, 4) NEED WALL SURFACE
C       EXTRACTION AND CALCULATIONS OF WALL SURFACE NORMAL VECTOR AND
C       DISTANCE BEWTEEN WALL SURFACE AND ITS OPPOSING SURFACE.
C       THESE DATA ARE NEEDED FOR CALCULATING WALL SHEAR STRESS WHICH
C       WILL BE USED FOR DAMPING ALL ELEMENTS EDDY VISCOSITY AND, FOR
C       WALL STRESS MODELS (IMODEL=2, 4), GIVING WALL BOUNDARY
C       CONDITIONS IN MOMENTUM EQUATIONS. 
C
C
C EXTRACT WALL SURFACES AND CALCULATE THEIR NORMAL VECTORS AND WALL
C OPPOSING SURFACE DISTANCES
C
C
      IF(IMODEL.EQ.1.OR.IMODEL.EQ.3) THEN
          WRITE(IUT6,*)
          WRITE(IUT6,*) ' LESSRF: EXTRACTING WALL SURFACES AND'
          WRITE(IUT6,*) '        CALCULATING WALL SURFACE NORMALS AND'
          WRITE(IUT6,*) '        WALL-OPPOSING SURFACE DISTANCES'
C
          MLST   = 2
          CALL SRFEXX(MPWALL,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *                LPWALL,NPWALL,LOCAL,NODE,
     *                LEWALL,NEWALL,MWRK,IWRK,IUT0,IERR)
          CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
          IF(IERRA.NE.0) THEN
              WRITE(IUT0,*)
              WRITE(IUT0,*) ERMSGC
              RETURN
          ENDIF
C
          CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *                LEWALL,NEWALL,XNWALL,YNWALL,ZNWALL,WRK1)
C
          DO 100 IEWALL = 1 , NEWALL
              IE  = LEWALL(1,IEWALL)
              IS  = LEWALL(2,IEWALL)
              IF(     NODE(8,IE).GE.1) THEN ! HEX
                 IETYPE = 4
                 NNPE   = 8   
              ELSE IF(NODE(6,IE).GE.1) THEN ! PRS   
                 IETYPE = 3
                 NNPE   = 6
              ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
                 IETYPE = 2
                 NNPE   = 5
              ELSE                          ! TET
                 IETYPE = 1
                 NNPE   = 4
              ENDIF   
              DO 101 I=1,NNPE
                 IOPPSN(I)=1
 101          CONTINUE   
              DO 102 I=1,N2D
                 II=LOCAL(I,IS,IETYPE)
                 IF(II.GE.1) IOPPSN(II)=0
 102          CONTINUE   
              NOPPSN=0
              XWG=0.0D0
              YWG=0.0D0
              ZWG=0.0D0
              DO 103 I=1,NNPE
                 IF(IOPPSN(I).EQ.1) THEN
                    NOPPSN=NOPPSN+1
                    XWG = XWG + X(NODE(I,IE))
                    YWG = YWG + Y(NODE(I,IE))
                    ZWG = ZWG + Z(NODE(I,IE))
                 ENDIF
 103          CONTINUE
              XFG = XWG/DBLE(NOPPSN)
              YFG = YWG/DBLE(NOPPSN)
              ZFG = ZWG/DBLE(NOPPSN)
C
              XWG = X(NODE(LOCAL(1,IS,IETYPE),IE))
              YWG = Y(NODE(LOCAL(1,IS,IETYPE),IE))
              ZWG = Z(NODE(LOCAL(1,IS,IETYPE),IE))
C
              DX  = XFG - XWG
              DY  = YFG - YWG
              DZ  = ZFG - ZWG
C
              YP(IEWALL) = REAL( DX*DBLE(XNWALL(IEWALL))
     &                          +DY*DBLE(YNWALL(IEWALL)) 
     &                          +DZ*DBLE(ZNWALL(IEWALL)) )
C
              IF(YP(IEWALL).LE.0.0E0)THEN
                  IERR=1
                  WRITE(IUT0,*)
                  WRITE(IUT0,*) EREXP0
CC                RETURN
              ENDIF
C
  100     CONTINUE
          CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
          IF(IERRA.NE.0) THEN
              WRITE(IUT0,*)
              WRITE(IUT0,*) ERMSGC
              RETURN
          ENDIF
C
          WRITE(IUT6,*) ' DONE!'
          WRITE(IUT6,*) '   NEWALL=',NEWALL
      ENDIF
C
      WRITE(IUT6,*)
      WRITE(IUT6,*) ' LESSRF: EXTRACTING INLET SURFACES AND'
      WRITE(IUT6,*) '        CALCULATING INLET SURFACE NORMALS AND'
      MLST   = 2
      CALL SRFEXX(MPINLT,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *            LPINLT,NPINLT,LOCAL,NODE,
     *            LEINLT,NEINLT,MWRK,IWRK,IUT0,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *            LEINLT,NEINLT,XNINLT,YNINLT,ZNINLT,AEINLT)

C
C
C  PREPARE FOR SYMMETRIC BOUNDARY CONDITIONS
C
C
C
C NOTES; SYMMETRIC SURFACE EXTRACTION AND THEIR NORMAL CALCULATION ARE
C       TEMPORARILY BE NEEDED FOR CALCULATING SYMMETRIC NODE NORMAL 
C       VECTORS.
C
C
C EXTRACT SYMMETRIC BOUNDARY SURFACES, CALCULATE THEIR NORMAL VECTORS
C AND ASSIGN SURFACE NORMAL VECTORS TO SYMMETRIC NODES
C
C
      WRITE(IUT6,*)
      WRITE(IUT6,*) ' LESSRF: EXTRACTING SYMMETRIC SURFACES,'
      WRITE(IUT6,*) '        CALCULATING SYMMETRIC SURFACE NORMALS AND'
      WRITE(IUT6,*) '        ASSIGNING SURFACE NORMAL TO SYMMETRIC NODE'
C
      MLST   = 2
      IF (IVOF.EQ.0) THEN
         CALL SRFEXX(MWRK,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *               LPSYMT,NPSYMT,LOCAL,NODE,
     *               IWRK2,NESYMT,MWRK,IWRK,IUT0,IERR)
         NPSYM2=NPSYMT
      ELSE
         CALL SRFEX3(MWRK,MLST,MB,NE,NP,N2,NEX,NS,NSP,N2D,
     *               LPSYMT,NPSYMT,LPFREE,NPFREE,LOCAL,NODE,
     *               IWRK2,NESYMT,NPSYM2,MWRK,IWRK,LWRK01,IUT0,IERR)
         WRITE(IUT6,*)
     *   ' NUM. OF SYMMETRIC BOUNDARY NODE ADDED TO ORIGINAL ONE :',
     *   NPSYM2-NPSYMT
      ENDIF
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *            IWRK2,NESYMT,WRK1,WRK2,WRK3,WRK4)
C
      DO 400 IP = 1 , NP
          WRK4(IP) = 0.E0
          WRK5(IP) = 0.E0
          WRK6(IP) = 0.E0
  400 CONTINUE
C
      DO 420 IESYMT = 1 , NESYMT
          IE = IWRK2(1,IESYMT)
          IS = IWRK2(2,IESYMT)
          IF(     NODE(8,IE).GE.1) THEN ! HEX
             IETYPE = 4
          ELSE IF(NODE(6,IE).GE.1) THEN ! PRS  
             IETYPE = 3
          ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
             IETYPE = 2
          ELSE                          ! TET
             IETYPE = 1
          END IF   
          IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUADRILATERAL
             NNPS = 4
          ELSE                             ! TRIANGLE
             NNPS = 3
          ENDIF   
          DO 410 I = 1 , NNPS
              IP = NODE(LOCAL(I,IS,IETYPE),IE)
              WRK4(IP) = WRK4(IP)+WRK1(IESYMT)
              WRK5(IP) = WRK5(IP)+WRK2(IESYMT)
              WRK6(IP) = WRK6(IP)+WRK3(IESYMT)
  410     CONTINUE 
  420 CONTINUE
C
C SUPERIMPOSE NEIGHBORING DOMAIN NORMAL VECTORS
C
C  NOTES; THIS PART MUST BE CALLED FOR ALL THE DOMAINS WHETHER OR NOT
C        THEY HAVE A SYMMETRIC NODE. A DOMAIN WHICH HAS NO SYMMETRIC
C        NODE MUST ALSO SEND ITS ZERO (DUMMY) RESIDUALS TO ITS
C        NEIGHBORING DOMAINS OTHERWISE COMMUNICATION WILL BE LOCKED.
C        IF AT LEAST ONE OF THE NEIGHBORING DOMAIN POSSESSES A SYMMETRIC
C        SURFACE, A DOMAIN MAY ALSO BE ASSIGNED A NORMAL VECTOR TO ITS
C        SYMMETRIC NODE (WHICH IS ISOLATED IN THE DOMAIN) AFTER THE
C        COMMUNICATION.
C
      IDIM = 3
      CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
     *            IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
     *            IUT0,IERR,RX,RY,MAXBUF)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      DO 430 IPSYMT = 1 , NPSYM2
          IP = LPSYMT(IPSYMT)
          ABSNOR = SQRT(WRK4(IP)**2+WRK5(IP)**2+WRK6(IP)**2+EPS)
          XPSYMT(IPSYMT) = WRK4(IP)/ABSNOR
          YPSYMT(IPSYMT) = WRK5(IP)/ABSNOR
          ZPSYMT(IPSYMT) = WRK6(IP)/ABSNOR
  430 CONTINUE
C
      WRITE(IUT6,*) ' DONE!'
      WRITE(IUT6,*) '   NESYMT=',NESYMT
C
C
C
C  PREPARE FOR FREE BOUNDARY CONDITIONS
C
C
C
C NOTES; FREE SURFACE EXTRACTION AND THEIR NORMAL CALCULATION ARE
C       TEMPORARILY BE NEEDED FOR CALCULATING FREE NODE NORMAL 
C       VECTORS.
C
C
C EXTRACT FREE BOUNDARY SURFACES, CALCULATE THEIR NORMAL VECTORS
C AND ASSIGN SURFACE NORMAL VECTORS TO SYMMETRIC NODES
C
C
      WRITE(IUT6,*)
      WRITE(IUT6,*) ' LESSRF: EXTRACTING FREE SURFACES,'
      WRITE(IUT6,*) '        CALCULATING FREE SURFACE NORMALS AND'
      WRITE(IUT6,*) '        ASSIGNING FREE NORMAL TO FREE NODE'
C
      MLST   = 2
      CALL SRFEXX(MPFREE,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *            LPFREE,NPFREE,LOCAL,NODE,
     *            LEFREE,NEFREE,MWRK,IWRK,IUT0,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *            LEFREE,NEFREE,XNFREE,YNFREE,ZNFREE,AEFREE)
C
      DO 500 IP = 1 , NP
          WRK4(IP) = 0.E0
          WRK5(IP) = 0.E0
          WRK6(IP) = 0.E0
  500 CONTINUE
C
      DO 520 IEFREE = 1 , NEFREE
          IE = LEFREE(1,IEFREE)
          IS = LEFREE(2,IEFREE)
          IF(     NODE(8,IE).GE.1) THEN ! HEX
             IETYPE = 4
          ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
             IETYPE = 3
          ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
             IETYPE = 2
          ELSE                          ! TET
             IETYPE = 1
          ENDIF   
          IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUADRILATERAL
             NNPS = 4
          ELSE                             ! TRIANGLE
             NNPS = 3
          ENDIF   
          DO 510 I = 1 , NNPS
              IP = NODE(LOCAL(I,IS,IETYPE),IE)
              WRK4(IP) = WRK4(IP)+XNFREE(IEFREE)
              WRK5(IP) = WRK5(IP)+YNFREE(IEFREE)
              WRK6(IP) = WRK6(IP)+ZNFREE(IEFREE)
  510     CONTINUE 
  520 CONTINUE
C
C SUPERIMPOSE NEIGHBORING DOMAIN NORMAL VECTORS
C
C  NOTES; THIS PART MUST BE CALLED FOR ALL THE DOMAINS WHETHER OR NOT
C        THEY HAVE A FREE NODE. A DOMAIN WHICH HAS NO FREE NODE MUST 
C        ALSO SEND ITS ZERO (DUMMY) RESIDUALS TO ITS NEIGHBORING DOMAINS 
C        OTHERWISE COMMUNICATION WILL BE LOCKED. IF AT LEAST ONE OF 
C        THE NEIGHBORING DOMAIN POSSESSES A FREE SURFACE, A DOMAIN MAY 
C        ALSO BE ASSIGNED A NORMAL VECTOR TO ITS FREE NODE (WHICH IS 
C        ISOLATED IN THE DOMAIN) AFTER THE COMMUNICATION.
C
      IDIM = 3
      CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
     *            IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
     *            IUT0,IERR,RX,RY,MAXBUF)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      DO 530 IPFREE = 1 , NPFREE
          IP = LPFREE(IPFREE)
          ABSNOR = SQRT(WRK4(IP)**2+WRK5(IP)**2+WRK6(IP)**2+EPS)
          XPFREE(IPFREE) = WRK4(IP)/ABSNOR
          YPFREE(IPFREE) = WRK5(IP)/ABSNOR
          ZPFREE(IPFREE) = WRK6(IP)/ABSNOR
  530 CONTINUE
C
      WRITE(IUT6,*) ' DONE!'
      WRITE(IUT6,*) '   NEFREE=',NEFREE
C
C
C
C  PREPARE FOR FLUID FORCE CALCULATION BOUNDARY CONDITIONS
C
C
C
C EXTRACT BODY SURFACES, CALCULATE THEIR NORMAL VECTORS, AND
C GENERATE BODY SURFACE NODES TABLE
C
C
      WRITE(IUT6,*)
      WRITE(IUT6,*) ' LESSRF: EXTRACTING BODY SURFACES, CALCULATING'
      WRITE(IUT6,*) '        THEIR NORMAL VECTORS, AND GENERATING'
      WRITE(IUT6,*) '        BODY SURFACE NODE TABLE'
C
      MLST   = 2
      CALL SRFEXX(MPBODY,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *            LPBODY,NPBODY,LOCAL,NODE,
     *            LEBODY,NEBODY,MWRK,IWRK,IUT0,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *            LEBODY,NEBODY,XNBODY,YNBODY,ZNBODY,AEBODY)
C
      NPDUM = 0 
      DO 610 IP = 1 , NP
          IWRK(IP) = 0
          WRK4(IP) = 0.E0
          WRK5(IP) = 0.E0
          WRK6(IP) = 0.E0
  610 CONTINUE
C
      DO 640 IEBODY = 1 , NEBODY
          IE = LEBODY(1,IEBODY)
          IS = LEBODY(2,IEBODY)
          IF(     NODE(8,IE).GE.1) THEN ! HEX
             IETYPE = 4
          ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
             IETYPE = 3
          ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
             IETYPE = 2
          ELSE                          ! TET
             IETYPE = 1
          ENDIF   
          DO 620 I = 1 , N2D
             IF(LOCAL(I,IS,IETYPE).GE.1) THEN
                IP = NODE(LOCAL(I,IS,IETYPE),IE)
                IF(IWRK(IP).EQ.0) THEN
                   NPDUM = NPDUM+1
C
                   IF(NPDUM.GT.NPBODY) THEN
                      WRITE(IUT0,*)
                      WRITE(IUT0,*) ERMSGB
                      WRITE(IUT0,*) EREXP3
                      IERR = 1
CC                    RETURN
                   ENDIF
C
                   NODEPS(I,IEBODY) = NPDUM
                   XPS(NPDUM)       = REAL(X(IP))
                   YPS(NPDUM)       = REAL(Y(IP))
                   ZPS(NPDUM)       = REAL(Z(IP))
                   IWRK(IP)         = NPDUM
                ELSE
                   NODEPS(I,IEBODY) = IWRK(IP)
                ENDIF
             ENDIF   
C
  620     CONTINUE
C
          IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUADRILATERAL
             NNPS = 4
          ELSE                             ! TRIANGLE
             NNPS = 3
          ENDIF   
          DO 630 I = 1 , NNPS
              IP = NODE(LOCAL(I,IS,IETYPE),IE)
              WRK4(IP) = WRK4(IP)+XNBODY(IEBODY)
              WRK5(IP) = WRK5(IP)+YNBODY(IEBODY)
              WRK6(IP) = WRK6(IP)+ZNBODY(IEBODY)
  630     CONTINUE 
C
  640 CONTINUE
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      IF(NPDUM.NE.NPBODY) THEN
          WRITE(IUT6,*)
          WRITE(IUT6,*) WRMSG
          WRITE(IUT6,*) WREXP1
      ENDIF
      WRITE(IUT6,*) ' DONE!'
      WRITE(IUT6,*) '   NEBODY=',NEBODY
C
C SUPERIMPOSE NEIGHBORING DOMAIN NORMAL VECTORS
C
C  NOTES; THIS PART MUST BE CALLED FOR ALL THE DOMAINS WHETHER OR NOT
C        THEY HAVE A FREE NODE. A DOMAIN WHICH HAS NO FREE NODE MUST 
C        ALSO SEND ITS ZERO (DUMMY) RESIDUALS TO ITS NEIGHBORING DOMAINS 
C        OTHERWISE COMMUNICATION WILL BE LOCKED. IF AT LEAST ONE OF 
C        THE NEIGHBORING DOMAIN POSSESSES A FREE SURFACE, A DOMAIN MAY 
C        ALSO BE ASSIGNED A NORMAL VECTOR TO ITS FREE NODE (WHICH IS 
C        ISOLATED IN THE DOMAIN) AFTER THE COMMUNICATION.
C
      IDIM = 3
      CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
     *            IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
     *            IUT0,IERR,RX,RY,MAXBUF)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      DO 650 IPBODY = 1 , NPBODY
          IP = LPBODY(IPBODY)
          ABSNOR = SQRT(WRK4(IP)**2+WRK5(IP)**2+WRK6(IP)**2+EPS)
          XPBODY(IPBODY) = WRK4(IP)/ABSNOR
          YPBODY(IPBODY) = WRK5(IP)/ABSNOR
          ZPBODY(IPBODY) = WRK6(IP)/ABSNOR
  650 CONTINUE
C
      WRITE(IUT6,*) ' DONE!'
      WRITE(IUT6,*) '   NEBODY=',NEBODY
C
C
C
C  PREPARE FOR OVERSET BOUNDARY CONDITIONS
C
C
C
C EXTRACT OVERSET SURFACES, CALCULATE THEIR NORMAL VECTORS
C
C
      WRITE(IUT6,*)
      WRITE(IUT6,*) ' LESSRF: EXTRACTING OVERSET SURFACES, CALCULATING'
      WRITE(IUT6,*) '        THEIR NORMAL VECTORS '
C
      MLST   = 2
      CALL SRFEXX(MBESET,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *            LPSET1,NPSET,LOCAL,NODE,
     *            LBESET,NBESET,MWRK,IWRK,IUT0,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *            LBESET,NBESET,XNESET,YNESET,ZNESET,AESET)
C
      WRITE(IUT6,*) ' DONE!'
      WRITE(IUT6,*) '   NPSET =',NPSET
      WRITE(IUT6,*) '   NBESET=',NBESET
C
C
C EXTRACT HEAT SURFACES, CALCULATE THEIR NSURFACEAREA, AND
C GENERATE BODY SURFACE NODES TABLE
C
C
      WRITE(IUT6,*)
      WRITE(IUT6,*) ' LESSRF: EXTRACTING HEAT SURFACES, CALCULATING'
      WRITE(IUT6,*) '        THEIR NORMAL VECTORS, AND GENERATING'
      WRITE(IUT6,*) '        HEAT SURFACE NODE TABLE'
C
      MLST   = 2
      CALL SRFEXX(MPHEAT,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
     *            LPHEAT,NPHEAT,LOCAL,NODE,
     *            LEHEAT,NEHEAT,MWRK,IWRK,IUT0,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) THEN
          WRITE(IUT0,*)
          WRITE(IUT0,*) ERMSGC
          RETURN
      ENDIF
C
      CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
     *            LEHEAT,NEHEAT,WRK1,WRK2,WRK3,WRK4)
C
      WRITE(IUT6,*) ' DONE!'
      WRITE(IUT6,*) '   NEHEAT=',NEHEAT
C
      RETURN
      END
