
 Fujitsu Fortran Version 4.1.0  Tue Apr 28 18:53:10 2020

 Compilation information
   Current directory : /vol0001/g9300001/u93021/09.FFB/2020.04.28a_v630202_from_Yamade/FFB.63.02.02/ver.63.02.02
   Source file       : lessfx.f

 Option information
   Command line options : -Kident_mpi -f2004 -I/home/g9300001/u93021/09.FFB/2020.04.28a_v630202_from_Yamade/FFB.63.02.02/include -I/include/mpi/fujitsu/ -Kvisimpact,ocl,optmsg=2,openmp -Dcputime -DUSE_TIMER -DUSE_BARRIER -Nlst=t -Cpp -Nfjomplib -c -I/opt/FJSVxtclanga/.common/MELI014/include/mpi/fujitsu -I/opt/FJSVxtclanga/.common/MELI014/lib64 -Knointentopt
   Cpp options          : -I/home/g9300001/u93021/09.FFB/2020.04.28a_v630202_from_Yamade/FFB.63.02.02/include -I/include/mpi/fujitsu/ -Dcputime -DUSE_TIMER -DUSE_BARRIER -I/opt/FJSVxtclanga/.common/MELI014/include/mpi/fujitsu -I/opt/FJSVxtclanga/.common/MELI014/lib64 -Dunix -Dlinux -D__FUJITSU -D__FRT_major__=4 -D__FRT_minor__=1 -D__FRT_patchlevel__=0 -D__FRT_version__="4.1.0" -D__aarch64__ -D__unix -D_OPENMP=201511 -D__frt_version=800 -D__ARM_ARCH=8 -D__ARM_FEATURE_SVE -D__ELF__ -D__unix__ -D__linux__ -D__linux -Asystem(unix) -otmp
   Effective options    : -fi -g0 -AE -Fixed -O3 -X08
                          -x0 -xaccept=nomodule_allocatable
                          -KA64FX -KARMV8_3_A -KSVE -Kalign_commons
                          -Kalign_loops -Kassume=noshortloop
                          -Kassume=nomemory_bandwidth
                          -Kassume=notime_saving_compilation -Kauto
                          -Kautoobjstack -Knocalleralloc -Kcmodel=small
                          -Keval -Keval_noconcurrent -Knofenv_access
                          -Kfp_contract -Kfp_relaxed -Kfsimple -Kfz -Khpctag
                          -Kilfunc=procedure -Knointentopt -Klargepage
                          -Kloop_blocking -Kloop_fission
                          -Kloop_nofission_stripmining
                          -Kloop_fission_threshold=50 -Kloop_fusion
                          -Kloop_interchange -Kloop_part_parallel
                          -Kloop_part_simd -Kloop_perfect_nest
                          -Kloop_noversioning -Knolto -Kmfunc=1 -Kocl
                          -Komitfp -Knooptlib_string -Koptmsg=2
                          -Knopc_relative_literal_loads -Kplt -Knopreex
                          -Kprefetch_noconditional -Kprefetch_noindirect
                          -Kprefetch_sequential=auto -Kprefetch_nostride
                          -Kprefetch_cache_level=all -Kprefetch_noinfer
                          -Kprefetch_strong -Kprefetch_strong_L2 -Knopreload
                          -Ksch_post_ra -Ksch_pre_ra -Ksibling_calls
                          -Ksimd=auto -Ksimd_packed_promotion
                          -Ksimd_reduction_product -Ksimd_reg_size=512
                          -Ksimd_nouncounted_loop
                          -Ksimd_use_multiple_structures -Knostriping -Kswp
                          -Kswp_freg_rate=100 -Kswp_ireg_rate=100
                          -Kswp_preg_rate=100 -Ktemparraystack -Kunroll
                          -Knounroll_and_jam -Knozfill
                          -Kopenmp -Kopenmp_noassume_norecurrence
                          -Kopenmp_nocollapse_except_innermost
                          -Kopenmp_noordered_reduction -Knoopenmp_simd
                          -Kthreadsafe -Kparallel -Kparallel_nofp_precision
                          -Knoarray_private -Knodynamic_iteration -Kreduction
                          -Kregion_extension
                          -Nallextput -Nnoalloc_assign
                          -Ncancel_overtime_compilation -Nnocheck_global
                          -Nnocoarray -Nnocompdisp -Nnocopyarg -Nnocoverage
                          -Nfjprof -Nfreealloc -Nf90move -Nnohook_func
                          -Nnohook_time -Nfjomplib -Nline -Nlst -Nlst=p
                          -Nlst=t -Nnomallocfree -Nnoobsfun -Nnoprivatealloc
                          -Nquickdbg=noargchk -Nquickdbg=nosubchk
                          -Nquickdbg=noundef -NRnotrap -Nnorecursive
                          -Nnoreordered_variable_stack -Nrt_notune -Nnosave
                          -Nsetvalue=noheap -Nsetvalue=nostack
                          -Nsetvalue=noscalar -Nsetvalue=noarray
                          -Nsetvalue=nostruct -Nuse_rodata

 External subroutine subprogram "LESSFX"
  (line-no.)(nest)(optimize)
          1                     C======================================================================C
          2                     C                                                                      C
          3                     C SOFTWARE NAME : FRONTFLOW_BLUE.8.1                                   C
          4                     C                                                                      C
          5                     C  SUB ROUTINE : LESSFX                                                C
          6                     C                                                                      C
          7                     C                                       WRITTEN BY Y.YAMADE            C
          8                     C                                                                      C
          9                     C                                                                      C
         10                     C CONTACT ADDRESS : IIS, THE UNIVERSITY OF TOKYO, CISS                 C
         11                     C                                                                      C
         12                     C THERMO-FLUID ANALYSIS SOLVERS FOR LARGE-SCALE-ASSEMBLY               C
         13                     C                                                                      C
         14                     C======================================================================C
         15                           SUBROUTINE LESSFX(LOCAL,NODE,MB,NE,NP,N2,NEX,NS,NSP,N2D,
         16                          *                  X,Y,Z,IMODEL,IVOF,
         17                          *                  MPWALL,NPWALL,LPWALL,LEWALL,NEWALL,
         18                          *                  XNWALL,YNWALL,ZNWALL,YP,
         19                          *                  MPINLT,NPINLT,LPINLT,
         20                          *                  NEINLT,LEINLT,XNINLT,YNINLT,ZNINLT,AEINLT,
         21                          *                  NPSYMT,NPSYM2,LPSYMT,XPSYMT,YPSYMT,ZPSYMT,
         22                          *                  MPFREE,NPFREE,LPFREE,XPFREE,YPFREE,ZPFREE,
         23                          *                  NEFREE,LEFREE,XNFREE,YNFREE,ZNFREE,AEFREE,
         24                          *                  NPCCL ,LPCCL1,LPCCL2,
         25                          *                  IPART ,MPINT ,NPINT ,LPINT1,LPINT2,LPINT3,
         26                          *                  MDOM  ,NDOM  ,LDOM  ,NBPDOM,MBPDOM,IPSLF,IPSND,
         27                          *                  MPBODY,NPBODY,LPBODY,LEBODY,NEBODY,
         28                          *                  XPBODY,YPBODY,ZPBODY,
         29                          *                  XNBODY,YNBODY,ZNBODY,AEBODY,NODEPS,
         30                          *                  MBESET,NPSET,NBESET,
         31                          *                  LPSET1,LPSET3,LBESET,AESET,XNESET,YNESET,ZNESET,
         32                          *                  MPHEAT,NPHEAT,LPHEAT,LEHEAT,NEHEAT,
         33                          *                  XPS,YPS,ZPS,LPBTOA,IUT0,IUT6,IERR,RX,RY,
         34                          *                  MWRK,WRK1,WRK2,WRK3,WRK4,WRK5,WRK6,
         35                          *                  IWRK,IWRK2,LWRK01)
         36                           IMPLICIT NONE
         37                           INTEGER*4 LOCAL,NODE,MB,NE,NP,N2,NEX,NS,NSP,N2D,NODEPS,
         38                          *          IMODEL,IVOF,
         39                          *          MPWALL,NPWALL,LPWALL,LEWALL,NEWALL,
         40                          *          MPINLT,NPINLT,LPINLT,NEINLT,LEINLT,
         41                          *          MPFREE,NPFREE,LPFREE,NEFREE,LEFREE,
         42                          *          NPSYMT,NPSYM2,LPSYMT,NPCCL ,LPCCL1,LPCCL2,
         43                          *          IPART ,MPINT ,NPINT ,LPINT1,LPINT2,LPINT3,
         44                          *          MDOM  ,NDOM  ,LDOM  ,NBPDOM,MBPDOM,IPSLF,IPSND,
         45                          *          MPBODY,NPBODY,LPBODY,LEBODY,NEBODY,
         46                          *          MBESET,NPSET,NBESET,LPSET1,LPSET3,LBESET,
         47                          *          MPHEAT,NPHEAT,LPHEAT,LEHEAT,NEHEAT,
         48                          *          LPBTOA,IUT0,IUT6,IERR,MWRK,IWRK,IWRK2,LWRK01
         49                           REAL*8    X,Y,Z
         50                           REAL*4    XNWALL,YNWALL,ZNWALL,YP,XNINLT,YNINLT,ZNINLT,AEINLT,
         51                          *          XPFREE,YPFREE,ZPFREE,XNFREE,YNFREE,ZNFREE,AEFREE,
         52                          *          XPSYMT,YPSYMT,ZPSYMT,
         53                          *          XPBODY,YPBODY,ZPBODY,XNBODY,YNBODY,ZNBODY,AEBODY,
         54                          *          AESET,XNESET,YNESET,ZNESET,
         55                          *          XPS,YPS,ZPS,RX,RY,WRK1,WRK2,WRK3,WRK4,WRK5,WRK6
         56                           DIMENSION LOCAL(NSP,NS,4),NODE(N2,NE),X(NP),Y(NP),Z(NP),
         57                          *          LPWALL(NPWALL),LEWALL(2,MPWALL),YP    (MPWALL),
         58                          *          XNWALL(MPWALL),YNWALL(MPWALL),ZNWALL(MPWALL),
         59                          *          LPINLT(NPWALL),LEINLT(2,MPINLT),
         60                          *          XNINLT(MPINLT),YNINLT(MPINLT),ZNINLT(MPINLT),
         61                          *          AEINLT(MPINLT),LPSYMT(MB),
         62                          *          LPFREE(NPFREE),LEFREE(2,MPFREE),
         63                          *          XPSYMT(MB),YPSYMT(MB),ZPSYMT(MB),
         64                          *          XPFREE(NPFREE),YPFREE(NPFREE),ZPFREE(NPFREE),
         65                          *          XNFREE(MPFREE),YNFREE(MPFREE),ZNFREE(MPFREE),
         66                          *          AEFREE(MPFREE),
         67                          *          LPBODY(NPBODY),LEBODY(2,MPBODY),AEBODY(MPBODY),
         68                          *          XPBODY(NPBODY),YPBODY(NPBODY),ZPBODY(NPBODY),
         69                          *          XNBODY(MPBODY),YNBODY  (MPBODY),ZNBODY(MPBODY),
         70                          *          NODEPS(N2D,MPBODY),
         71                          *          LPCCL1(NPCCL),LPCCL2(NPCCL) ,
         72                          *          LPSET1(NPSET),LPSET3(NPSET),LBESET(2,MBESET),
         73                          *          AESET(NBESET),XNESET(MBESET),
         74                          *          YNESET(MBESET),ZNESET(MBESET),
         75                          *          LPHEAT(MPHEAT),LEHEAT(2,MPHEAT),
         76                          *          XPS(NPBODY),YPS(NPBODY),ZPS(NPBODY),
         77                          *          WRK1(NE),WRK2(NE),WRK3(NE),WRK4(NP),WRK5(NP),WRK6(NP),
         78                          *          IWRK(MWRK),IWRK2(2,MWRK),RX(0:N2,NE),RY(0:N2,NE),
         79                          *          LWRK01(MWRK)
         80                     C
         81                           DIMENSION LPINT1(MPINT),LPINT2(MPINT),LPINT3(MPINT),
         82                          1          LDOM  (MDOM) ,NBPDOM(MDOM) ,
         83                          2          IPSLF(MBPDOM,MDOM),IPSND(MBPDOM,MDOM)
         84                     C
         85                           DIMENSION NEX(8)
         86                           INTEGER*4 IOPPSN(8)
         87                           DIMENSION LPBTOA(NP)
         88                     C
         89                           CHARACTER*60 WRMSG
         90                          & / ' ## SUBROUTINE LESSFX: ISSUES A WARNING          ; CONTINUE' /
         91                           CHARACTER*60 WREXP1
         92                          & / ' DOUBLE DEFINED OR ISOLATED BODY SURFACE NODES EXIST       ' /
         93                     C
         94                           CHARACTER*60 ERMSGB
         95                          & / ' ## SUBROUTINE LESSFX: FATAL      ERROR OCCURENCE; RETURNED' /
         96                     C
         97                           CHARACTER*60 EREXP0
         98                          & / ' INVALID NORMAL VECTOR FOR WALL SURFACE                    ' /
         99                           CHARACTER*60 EREXP3
        100                          & / ' APPEARENTLY WRONG SURFACE EXTRACTED; CHECK MESH DATA      ' /
        101                     C
        102                           CHARACTER*60 ERMSGC
        103                          & / ' ## SUBROUTINE LESSFX: FATAL      ERROR REPORT   ; RETURNED' /
        104                     C
        105                           REAL*4    EPS
        106                           DATA      EPS  /1.0E-10/
        107                     C
        108                           INTEGER*4 MAXBUF,IERRA,IDIM,IDOM,IBP,IPCCL,IPINT1,IPINT2,MLST,
        109                          *          IEWALL,IE,IS,IETYPE,NNPE,I,II,NOPPSN,NESYMT,IP,IESYMT,
        110                          *          NNPS,IEFREE,IPFREE,NPDUM,IEBODY,IPSYMT,IPBODY,
        111                          *          NPSETD,IPB,ISEND
        112                           REAL*8    XWG,YWG,ZWG,XFG,YFG,ZFG,DX,DY,DZ,ABSNOR
        113                     C
        114                     C
        115                     C         ( 3-D CALCULATION : SINGLE WORD & MULTI ELEMENT VERSION )
        116                     C                                           CODED BASED ON 'LESSRF'
        117                     C
        118                     C      DO THE FOLLOWING BOUNDARY CONDITION PREPARATIONS FOR 'LES3D'
        119                     C
        120                     C
        121                     C     (1) GENERATE NEIGHBORING DOMAIN LISTS FOR PARALLEL MODE EXECUTION
        122                     C
        123                     C     (2) EXTRACT WALL BOUNDARY SURFACES, CALCULATE THEIR NORMALS AND
        124                     C        DISTANCE BETWEEN WALL SURFACE AND ITS OPPOSING SURFACE, ASSIGN
        125                     C        SURFACE NORMALS TO WALL NODES, GENERATE ADJACENT WALL SURFACE
        126                     C        LIST, AND MARK (EXTRACT) CORNER WALL NODES
        127                     C
        128                     C     (3) EXTRACT SYMMETRIC BOUNDARY SURFACES, CALCULATE THEIR NORMALS,
        129                     C        AND ASSIGN SURFACE NORMALS TO SYMMETRIC NODES
        130                     C
        131                     C     (4) EXTRACT CYCLIC  BOUNDARY SURFACES, CALCULATE THEIR NORMALS AND
        132                     C        AREAS, AND CYCLIC BOUNDARY PRESSURE DIFFERENCE
        133                     C
        134                     C     (5) EXTRACT BODY SURFACES, CALCULATE THEIR NORMALS AND AREAS, AND
        135                     C        GENERATE BODY SURFACE NODE TABLE
        136                     C
        137                     C
        138                     C     ARGUMENT LISTINGS
        139                     C       (1) INPUT
        140                     C          LOCAL (I,IS); NODE NUMBER TABLE DEFINING ELEMENT SURFACES
        141                     C          NODE  (I,IE); NODE NUMBER TABLE BASED ON ELEMENT
        142                     C          NE          ; NUMBER OF TOTAL ELEMENTS
        143                     C          MP          ; MAX. NUMBER OF TOTAL NODES
        144                     C           NOTES ; MP DEFINES THE UPPER BOUND OF ARRAYS WRK1 AND WRK2
        145                     C          NP          ; NUMBER OF TOTAL    NODES
        146                     C          N           ; NUMBER OF NODES ASSIGNED TO ONE ELEMENT
        147                     C          N2D          ;NUMBER OF SURFACE ELEMENT DEFINING NODES ( =4 )
        148                     C          X       (IP); X-COORDINATE OF GLOBAL NODES
        149                     C          Y       (IP); Y-COORDINATE OF GLOBAL NODES
        150                     C          Z       (IP); Z-COORDINATE OF GLOBAL NODES
        151                     C          P       (IE); ELEMENT PRESSURE
        152                     C          GI       (I); LOCAL GZAI  COORDINATES OF ELEMENT'S NODES
        153                     C          EI       (I); LOCAL EATA  COORDINATES OF ELEMENT'S NODES
        154                     C          TI       (I); LOCAL THETA COORDINATES OF ELEMENT'S NODES
        155                     C
        156                     C          IMODEL      ; WALL SURFACE EXTRACTION AND NORMAL CALCULATIONS
        157                     C                       WILL BE DONE IF THIS FLAG IS SET 1 THROUGH 4
        158                     C          NPWALL      ; NUMBER      OF WALL BOUNDARY NODES
        159                     C          MPWALL      ; MAX. NUMBER OF WALL BOUNDARY NODES
        160                     C          LPWALL (IBP); WALL BOUNDARY NODES
        161                     C          MEPWL       ; MAX. NUMBER OF ADJACENT WALL SURFACE  ELEMENTS
        162                     C
        163                     C          NPSYMT      ; NUMBER OF SYMMETRIC BOUNDARY NODES
        164                     C          LPSYMT (IBP); SYMMETRIC BOUNDARY NODES
        165                     C
        166                     C          NPFREE      ; NUMBER OF FREE BOUNDARY NODES
        167                     C          LPFREE (IBP); FREE BOUNDARY NODES
        168                     C
        169                     C          IPART       ; SUB-DOMAIN NUMBER THAT THIS TASK SHOULD TAKE/IS
        170                     C                       TAKING CARE OF. IPART BEING SET ZERO MEANS THAT
        171                     C                       THE PROGRAM SHOULD RUN/IS RUNNING IN SERIAL
        172                     C                       MODE.
        173                     C          NPINT       ; NUMBER OF INTER-CONNECT BOUNDARY NODES
        174                     C          LPINT1 (IBP); INTER-CONNECT BOUNDARY NODES
        175                     C          LPINT2 (IBP); CORRESPONDING SUB-DOMAIN NUMBERS
        176                     C          LPINT3 (IBP); NODE NUMBER IN THE CORRESPONDING SUB-DOMAINS
        177                     C          MDOM        ; MAX. NUMBER OF THE NEIBERING SUB-DOMAINS
        178                     C          MBPDOM      ; THE MAXIMUM NUMBER OF THE INTER-CONNECT
        179                     C                       BOUNDARY NODES FOR ONE NEIBERING SUB-DOMAIN
        180                     C
        181                     C          NPBODY      ; NUMBER      OF BODY BOUNDARY NODES
        182                     C          MPBODY      ; MAX. NUMBER OF BODY BOUNDARY NODES
        183                     C          LPBODY (IBP); BODY BOUNDARY NODES
        184                     C
        185                     C          IUT0        ; FILE NUMBER TO WRITE  ERROR MESSAGE
        186                     C          IUT6        ; FILE NUMBER TO WRITE  CALCULATION SEQUENCE
        187                     C
        188                     C       (2) OUTPUT
        189                     C          NEWALL      ; NUMBER OF WALL BOUNDARY ELEMENTS
        190                     C          LEWALL(I,IBE); WALL BOUNDARY ELEMENT AND ITS SURFACE
        191                     C          XNWALL (IBE); X NORMAL OF WALL BOUNDARY SURFACE
        192                     C          YNWALL (IBE); Y NORMAL OF WALL BOUNDARY SURFACE
        193                     C          ZNWALL (IBE); Z NORMAL OF WALL BOUNDARY SURFACE
        194                     C          YP     (IBE); DISTANCE BETWEEN WALL AND ITS OPPOSITE SURFACES
        195                     C
        196                     C          XPSYMT (IBP); X-DIR COMPONENT OF SYMMETRIC NODE NORMAL VECTOR
        197                     C          YPSYMT (IBP); Y-DIR COMPONENT OF SYMMETRIC NODE NORMAL VECTOR
        198                     C          ZPSYMT (IBP); Z-DIR COMPONENT OF SYMMETRIC NODE NORMAL VECTOR
        199                     C
        200                     C          NDOM        ; NUMBER OF THE NERIBERING SUB-DOMAINS
        201                     C          LDOM  (IDOM); NEIBERING SUB-DOMAIN NUMBER
        202                     C          NBPDOM(IDOM); NUMBER OF INTER-CONNECT BOUNDARY NODES
        203                     C                       SHARING WITH THE IDOM'TH NEIBERING SUB-DOMAIN,
        204                     C                       LDOM(IDOM)
        205                     C          IPSLF (IBP,IDOM); INTER-CONNECT BOUNDARY NODE NUMBER IN THE
        206                     C                           CALLING TASK'S SUB-DOMAIN, FOR THE IDOM'TH
        207                     C                           NEIBERING SUB-DOMAIN, LDOM(IDOM)
        208                     C          IPSND (IBP,IDOM); INTER-CONNECT BOUNDARY NODE NUMBER IN THE
        209                     C                           SUB-DOMAIN THAT IS RECEIVING THE CALLING
        210                     C                           TASK'S RESIDUALS.
        211                     C
        212                     C          NEBODY      ; NUMBER OF BODY BOUNDARY ELEMENTS
        213                     C          LEBODY(I,IBE); BODY BOUNDARY ELEMENT AND ITS SURFACE
        214                     C          XNBODY (IBE); X NORMAL OF BODY BOUNDARY SURFACE
        215                     C          YNBODY (IBE); Y NORMAL OF BODY BOUNDARY SURFACE
        216                     C          ZNBODY (IBE); Z NORMAL OF BODY BOUNDARY SURFACE
        217                     C          AEBODY (IBE); AREA     OF BODY BOUNDARY SURFACE
        218                     C          NODEPS(I,IBE);BODY SURFACE ELEMENT DEFINING TABLE
        219                     C          XPS    (IBP);BODY SURFACE ELEMENT DEFINING NODE X-COORD.
        220                     C          YPS    (IBP);BODY SURFACE ELEMENT DEFINING NODE Y-COORD.
        221                     C          ZPS    (IBP);BODY SURFACE ELEMENT DEFINING NODE Z-COORD.
        222                     C           NOTES ; ORDERING OF BODY SURFACE NODES ABOVE IS DIFFERENT
        223                     C                  FROM THAT ORIGINALLY GIVEN BY ARGUMENT 'LPBODY'.
        224                     C
        225                     C          NBESET       ; NUMBER OF OVERSET BOUNDARY FACES
        226                     C          LBESET(I,IBE); OVERSET BOUNDARY ELEMENT AND ITS SURFACE
        227                     C          XNESET(  IBE); X NORMAL OF OVERSET BOUNDARY SURFACE
        228                     C          YNESET(  IBE); Y NORMAL OF OVERSET BOUNDARY SURFACE
        229                     C          ZNESET(  IBE); Z NORMAL OF OVERSET BOUNDARY SURFACE
        230                     C
        231                     C          IERR        ; RETURN CODE WHOSE VALUE WILL BE EITHER
        232                     C                   0 --- INDICATING SUCCESSFUL TERMINATION
        233                     C                OR 1 --- INDICATING OCCURENCE OF SOME ERROR CONDITIONS
        234                     C
        235                     C       (4) WORK
        236                     C          WRK1  (IWRK); USED IN SURFEX, COSIN3, DDCOMX
        237                     C          WRK2  (IWRK); USED IN SURFEX, DDCOMX
        238                     C           NOTES ; GUARANTEE THE UPPER BOUND OF MP FOR WRK1 AND WRK2
        239                     C          WRK3  (IWRK); USED IN SURFEX
        240                     C          IWRK  (IWRK); USED INTERNALLY, AND IN SURFEX
        241                     C          IWRK2(2,IWRK);USED INTERNALLY
        242                     C          WRK4  (IWRK); USED INTERNALLY
        243                     C         -WRK6  (IWRK); USED INTERNALLY
        244                     C          RX    (I,IE); USED IN DDCOMX
        245                     C          RY    (I,IE); USED IN DDCOMX
        246                     C
        247                     C
        248                           NEWALL = 0
        249                     C
        250                           MAXBUF = NE*(N2+1)
        251                     C
        252                     C
        253                     C
        254                     C  GENERATE NEIGHBORING DOMAIN LISTS FOR PARALLEL EXECUTION
        255                     C
        256                     C
        257                     C
        258     1                     IF(IPART.GE.1) THEN
        259     1                         WRITE(IUT6,*)
        260     1                         WRITE(IUT6,*) ' LESSRF: GENERATING NEIGHBORING DOMAIN LIST'
        261     1               C
        262     1                         CALL DDCOM0(LPINT1,LPINT2,LPINT3,NPINT,MDOM,MBPDOM,
        263     1                    *                LDOM,NBPDOM,NDOM,IPSLF,IPSND,IUT0,IERR)
        264     1                         CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        265     2                         IF(IERRA.NE.0) THEN
        266     2                             WRITE(IUT0,*)
        267     2                             WRITE(IUT0,*) ERMSGC
        268     2                             RETURN
        269     2                         ENDIF
        270     1               C
        271     1                         IDIM = 0
        272     1                         CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
        273     1                    *                IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
        274     1                    *                IUT0,IERR,RX,RY,MAXBUF)
        275     1                         CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        276     2                         IF(IERRA.NE.0) THEN
        277     2                             WRITE(IUT0,*)
        278     2                             WRITE(IUT0,*) ERMSGC
        279     2                             RETURN
        280     2                         ENDIF
        281     1               C
        282     1               C         CONVERTE IPSND FROM BEFOR TO AFTER
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 4
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSND, (unknown)
                              <<< Loop-information  End >>>
        283     2  pp                     DO 10 IDOM=1,NDOM
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 2.25, ITR: 576, MVE: 10)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      IPSND, (unknown)
                              <<< Loop-information  End >>>
        284     3   p   2v                   DO 15 IBP=1,NBPDOM(IDOM)
        285     3   p   2v                      IPSND(IBP,IDOM)=LPBTOA(IPSND(IBP,IDOM))
        286     3   p   2v       15          CONTINUE
        287     2   p            10       CONTINUE
        288     1               C
        289     1                     ELSE IF(NPCCL.NE.0) THEN
        290     1                         NPINT=NPCCL*2
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 517
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 2.42, ITR: 80, MVE: 3)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LPINT2, LPINT1, LPCCL1, LPCCL2, LPINT3
                              <<<      (unknown)
                              <<< Loop-information  End >>>
        291     2  pp    v                DO 50 IPCCL=1,NPCCL
        292     2   p    v                    IPINT1= IPCCL
        293     2   p    v                    IPINT2= IPCCL+NPCCL
        294     2   p    v                    LPINT1(IPINT1) = LPCCL1(IPCCL)
        295     2   p    v                    LPINT1(IPINT2) = LPCCL2(IPCCL)
        296     2   p    v                    LPINT2(IPINT1) = IPART
        297     2   p    v                    LPINT2(IPINT2) = IPART
        298     2   p    v                    LPINT3(IPINT1) = LPCCL2(IPCCL)
        299     2   p    v                    LPINT3(IPINT2) = LPCCL1(IPCCL)
        300     2   p    v         50     CONTINUE
        301     1                         CALL DDCOM0(LPINT1,LPINT2,LPINT3,NPINT,MDOM,MBPDOM,
        302     1                    *                LDOM,NBPDOM,NDOM,IPSLF,IPSND,IUT0,IERR)
        303     2                         IF(IERR.NE.0) THEN
        304     2                             WRITE(IUT0,*)
        305     2                             WRITE(IUT0,*) ERMSGC
        306     2                             RETURN
        307     2                         ENDIF
        308     1                     ENDIF
        309                     C
        310                     C
        311                     C
        312                     C  PREPARE FOR WALL BOUNDARY CONDITIONS
        313                     C
        314                     C
        315                     C
        316                     C NOTES; ALL TURBULENCE COMPUTATIONS, EXCEPT THAT BASED-ON THE DYNAMIC
        317                     C       SMAGORINSKY MODEL, (IMODEL=1, 2, 3, 4) NEED WALL SURFACE
        318                     C       EXTRACTION AND CALCULATIONS OF WALL SURFACE NORMAL VECTOR AND
        319                     C       DISTANCE BEWTEEN WALL SURFACE AND ITS OPPOSING SURFACE.
        320                     C       THESE DATA ARE NEEDED FOR CALCULATING WALL SHEAR STRESS WHICH
        321                     C       WILL BE USED FOR DAMPING ALL ELEMENTS EDDY VISCOSITY AND, FOR
        322                     C       WALL STRESS MODELS (IMODEL=2, 4), GIVING WALL BOUNDARY
        323                     C       CONDITIONS IN MOMENTUM EQUATIONS.
        324                     C
        325                     C
        326                     C EXTRACT WALL SURFACES AND CALCULATE THEIR NORMAL VECTORS AND WALL
        327                     C OPPOSING SURFACE DISTANCES
        328                     C
        329                     C
        330     1                     IF(IMODEL.EQ.1.OR.IMODEL.EQ.3) THEN
        331     1                         WRITE(IUT6,*)
        332     1                         WRITE(IUT6,*) ' LESSRF: EXTRACTING WALL SURFACES AND'
        333     1                         WRITE(IUT6,*) '        CALCULATING WALL SURFACE NORMALS AND'
        334     1                         WRITE(IUT6,*) '        WALL-OPPOSING SURFACE DISTANCES'
        335     1               C
        336     1                         MLST   = 2
        337     1                         CALL SRFEXX(MPWALL,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        338     1                    *                LPWALL,NPWALL,LOCAL,NODE,
        339     1                    *                LEWALL,NEWALL,MWRK,IWRK,IUT0,IERR)
        340     1                         CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        341     2                         IF(IERRA.NE.0) THEN
        342     2                             WRITE(IUT0,*)
        343     2                             WRITE(IUT0,*) ERMSGC
        344     2                             RETURN
        345     2                         ENDIF
        346     1               C
        347     1                         CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        348     1                    *                LEWALL,NEWALL,XNWALL,YNWALL,ZNWALL,WRK1)
        349     1               C
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL
                              <<< Loop-information  End >>>
        350     2                         DO 100 IEWALL = 1 , NEWALL
        351     2                             IE  = LEWALL(1,IEWALL)
        352     2                             IS  = LEWALL(2,IEWALL)
        353     3                             IF(     NODE(8,IE).GE.1) THEN ! HEX
        354     3                                IETYPE = 4
        355     3                                NNPE   = 8
        356     3                             ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
        357     3                                IETYPE = 3
        358     3                                NNPE   = 6
        359     3                             ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
        360     3                                IETYPE = 2
        361     3                                NNPE   = 5
        362     3                             ELSE                          ! TET
        363     3                                IETYPE = 1
        364     3                                NNPE   = 4
        365     3                             ENDIF
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 2000
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<< Loop-information  End >>>
        366     3   s   4v                    DO 101 I=1,NNPE
        367     3   p   4v                       IOPPSN(I)=1
        368     3   p   4v       101          CONTINUE
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 2.25, ITR: 320, MVE: 5)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown)
                              <<< Loop-information  End >>>
        369     3   s   2v                    DO 102 I=1,N2D
        370     3   p   2v                       II=LOCAL(I,IS,IETYPE)
        371     3   p   2v                       IF(II.GE.1) IOPPSN(II)=0
        372     3   p   2v       102          CONTINUE
        373     2                             NOPPSN=0
        374     2                             XWG=0.0D0
        375     2                             YWG=0.0D0
        376     2                             ZWG=0.0D0
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 471
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 8)
                              <<< Loop-information  End >>>
        377     3  pp    v                    DO 103 I=1,NNPE
        378     4   p    v                       IF(IOPPSN(I).EQ.1) THEN
        379     4   p    v                          NOPPSN=NOPPSN+1
        380     4   p    v                          XWG = XWG + X(NODE(I,IE))
        381     4   p    v                          YWG = YWG + Y(NODE(I,IE))
        382     4   p    v                          ZWG = ZWG + Z(NODE(I,IE))
        383     4   p    v                       ENDIF
        384     3   p    v       103          CONTINUE
        385     2                             XFG = XWG/DBLE(NOPPSN)
        386     2                             YFG = YWG/DBLE(NOPPSN)
        387     2                             ZFG = ZWG/DBLE(NOPPSN)
        388     2               C
        389     2                             XWG = X(NODE(LOCAL(1,IS,IETYPE),IE))
        390     2                             YWG = Y(NODE(LOCAL(1,IS,IETYPE),IE))
        391     2                             ZWG = Z(NODE(LOCAL(1,IS,IETYPE),IE))
        392     2               C
        393     2                             DX  = XFG - XWG
        394     2                             DY  = YFG - YWG
        395     2                             DZ  = ZFG - ZWG
        396     2               C
        397     2                             YP(IEWALL) = REAL( DX*DBLE(XNWALL(IEWALL))
        398     2                    &                          +DY*DBLE(YNWALL(IEWALL))
        399     2                    &                          +DZ*DBLE(ZNWALL(IEWALL)) )
        400     2               C
        401     3                             IF(YP(IEWALL).LE.0.0E0)THEN
        402     3                                 IERR=1
        403     3                                 WRITE(IUT0,*)
        404     3                                 WRITE(IUT0,*) EREXP0
        405     3               CC                RETURN
        406     3                             ENDIF
        407     2               C
        408     2                 100     CONTINUE
        409     1                         CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        410     2                         IF(IERRA.NE.0) THEN
        411     2                             WRITE(IUT0,*)
        412     2                             WRITE(IUT0,*) ERMSGC
        413     2                             RETURN
        414     2                         ENDIF
        415     1               C
        416     1                         WRITE(IUT6,*) ' DONE!'
        417     1                         WRITE(IUT6,*) '   NEWALL=',NEWALL
        418     1                     ENDIF
        419                     C
        420                           WRITE(IUT6,*)
        421                           WRITE(IUT6,*) ' LESSRF: EXTRACTING INLET SURFACES AND'
        422                           WRITE(IUT6,*) '        CALCULATING INLET SURFACE NORMALS AND'
        423                           MLST   = 2
        424                           CALL SRFEXX(MPINLT,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        425                          *            LPINLT,NPINLT,LOCAL,NODE,
        426                          *            LEINLT,NEINLT,MWRK,IWRK,IUT0,IERR)
        427                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        428     1                     IF(IERRA.NE.0) THEN
        429     1                         WRITE(IUT0,*)
        430     1                         WRITE(IUT0,*) ERMSGC
        431     1                         RETURN
        432     1                     ENDIF
        433                     C
        434                           CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        435                          *            LEINLT,NEINLT,XNINLT,YNINLT,ZNINLT,AEINLT)
        436                     
        437                     C
        438                     C
        439                     C  PREPARE FOR SYMMETRIC BOUNDARY CONDITIONS
        440                     C
        441                     C
        442                     C
        443                     C NOTES; SYMMETRIC SURFACE EXTRACTION AND THEIR NORMAL CALCULATION ARE
        444                     C       TEMPORARILY BE NEEDED FOR CALCULATING SYMMETRIC NODE NORMAL
        445                     C       VECTORS.
        446                     C
        447                     C
        448                     C EXTRACT SYMMETRIC BOUNDARY SURFACES, CALCULATE THEIR NORMAL VECTORS
        449                     C AND ASSIGN SURFACE NORMAL VECTORS TO SYMMETRIC NODES
        450                     C
        451                     C
        452                           WRITE(IUT6,*)
        453                           WRITE(IUT6,*) ' LESSRF: EXTRACTING SYMMETRIC SURFACES,'
        454                           WRITE(IUT6,*) '        CALCULATING SYMMETRIC SURFACE NORMALS AND'
        455                           WRITE(IUT6,*) '        ASSIGNING SURFACE NORMAL TO SYMMETRIC NODE'
        456                     C
        457                           MLST   = 2
        458     1                     IF (IVOF.EQ.0) THEN
        459     1                        CALL SRFEXX(MWRK,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        460     1                    *               LPSYMT,NPSYMT,LOCAL,NODE,
        461     1                    *               IWRK2,NESYMT,MWRK,IWRK,IUT0,IERR)
        462     1                        NPSYM2=NPSYMT
        463     1                     ELSE
        464     1                        CALL SRFEX3(MWRK,MLST,MB,NE,NP,N2,NEX,NS,NSP,N2D,
        465     1                    *               LPSYMT,NPSYMT,LPFREE,NPFREE,LOCAL,NODE,
        466     1                    *               IWRK2,NESYMT,NPSYM2,MWRK,IWRK,LWRK01,IUT0,IERR)
        467     1                        WRITE(IUT6,*)
        468     1                    *   ' NUM. OF SYMMETRIC BOUNDARY NODE ADDED TO ORIGINAL ONE :',
        469     1                    *   NPSYM2-NPSYMT
        470     1                     ENDIF
        471                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        472     1                     IF(IERRA.NE.0) THEN
        473     1                         WRITE(IUT0,*)
        474     1                         WRITE(IUT0,*) ERMSGC
        475     1                         RETURN
        476     1                     ENDIF
        477                     C
        478                           CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        479                          *            IWRK2,NESYMT,WRK1,WRK2,WRK3,WRK4)
        480                     C
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 1143
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      WRK6, WRK5, WRK4, (unknown)
                              <<< Loop-information  End >>>
        481     1  pp   2v            DO 400 IP = 1 , NP
        482     1   p   2v                WRK4(IP) = 0.E0
        483     1   p   2v                WRK5(IP) = 0.E0
        484     1   p   2v                WRK6(IP) = 0.E0
        485     1   p   2v        400 CONTINUE
        486                     C
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown), (unknown)
                              <<< Loop-information  End >>>
        487     1                     DO 420 IESYMT = 1 , NESYMT
        488     1                         IE = IWRK2(1,IESYMT)
        489     1                         IS = IWRK2(2,IESYMT)
        490     2                         IF(     NODE(8,IE).GE.1) THEN ! HEX
        491     2                            IETYPE = 4
        492     2                         ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
        493     2                            IETYPE = 3
        494     2                         ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
        495     2                            IETYPE = 2
        496     2                         ELSE                          ! TET
        497     2                            IETYPE = 1
        498     2                         END IF
        499     2                         IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUADRILATERAL
        500     2                            NNPS = 4
        501     2                         ELSE                             ! TRIANGLE
        502     2                            NNPS = 3
        503     2                         ENDIF
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 696
                              <<<  [OPTIMIZATION]
                              <<<    SOFTWARE PIPELINING(IPC: 1.62, ITR: 128, MVE: 3)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown)
                              <<< Loop-information  End >>>
        504     2   m   2s                DO 410 I = 1 , NNPS
        505     2   p   2v                    IP = NODE(LOCAL(I,IS,IETYPE),IE)
        506     2   m   2v                    WRK4(IP) = WRK4(IP)+WRK1(IESYMT)
        507     2   s   2s                    WRK5(IP) = WRK5(IP)+WRK2(IESYMT)
        508     2   s   2s                    WRK6(IP) = WRK6(IP)+WRK3(IESYMT)
        509     2   p   2v        410     CONTINUE
        510     1                 420 CONTINUE
        511                     C
        512                     C SUPERIMPOSE NEIGHBORING DOMAIN NORMAL VECTORS
        513                     C
        514                     C  NOTES; THIS PART MUST BE CALLED FOR ALL THE DOMAINS WHETHER OR NOT
        515                     C        THEY HAVE A SYMMETRIC NODE. A DOMAIN WHICH HAS NO SYMMETRIC
        516                     C        NODE MUST ALSO SEND ITS ZERO (DUMMY) RESIDUALS TO ITS
        517                     C        NEIGHBORING DOMAINS OTHERWISE COMMUNICATION WILL BE LOCKED.
        518                     C        IF AT LEAST ONE OF THE NEIGHBORING DOMAIN POSSESSES A SYMMETRIC
        519                     C        SURFACE, A DOMAIN MAY ALSO BE ASSIGNED A NORMAL VECTOR TO ITS
        520                     C        SYMMETRIC NODE (WHICH IS ISOLATED IN THE DOMAIN) AFTER THE
        521                     C        COMMUNICATION.
        522                     C
        523                           IDIM = 3
        524                           CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
        525                          *            IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
        526                          *            IUT0,IERR,RX,RY,MAXBUF)
        527                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        528     1                     IF(IERRA.NE.0) THEN
        529     1                         WRITE(IUT0,*)
        530     1                         WRITE(IUT0,*) ERMSGC
        531     1                         RETURN
        532     1                     ENDIF
        533                     C
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 276
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 1.19, ITR: 160, MVE: 5)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LPSYMT, ZPSYMT, YPSYMT, XPSYMT
                              <<<      (unknown)
                              <<< Loop-information  End >>>
        534     1  pp    v            DO 430 IPSYMT = 1 , NPSYM2
        535     1   p    v                IP = LPSYMT(IPSYMT)
        536     1   p    v                ABSNOR = SQRT(WRK4(IP)**2+WRK5(IP)**2+WRK6(IP)**2+EPS)
        537     1   p    v                XPSYMT(IPSYMT) = WRK4(IP)/ABSNOR
        538     1   p    v                YPSYMT(IPSYMT) = WRK5(IP)/ABSNOR
        539     1   p    v                ZPSYMT(IPSYMT) = WRK6(IP)/ABSNOR
        540     1   p    v        430 CONTINUE
        541                     C
        542                           WRITE(IUT6,*) ' DONE!'
        543                           WRITE(IUT6,*) '   NESYMT=',NESYMT
        544                     C
        545                     C
        546                     C
        547                     C  PREPARE FOR FREE BOUNDARY CONDITIONS
        548                     C
        549                     C
        550                     C
        551                     C NOTES; FREE SURFACE EXTRACTION AND THEIR NORMAL CALCULATION ARE
        552                     C       TEMPORARILY BE NEEDED FOR CALCULATING FREE NODE NORMAL
        553                     C       VECTORS.
        554                     C
        555                     C
        556                     C EXTRACT FREE BOUNDARY SURFACES, CALCULATE THEIR NORMAL VECTORS
        557                     C AND ASSIGN SURFACE NORMAL VECTORS TO SYMMETRIC NODES
        558                     C
        559                     C
        560                           WRITE(IUT6,*)
        561                           WRITE(IUT6,*) ' LESSRF: EXTRACTING FREE SURFACES,'
        562                           WRITE(IUT6,*) '        CALCULATING FREE SURFACE NORMALS AND'
        563                           WRITE(IUT6,*) '        ASSIGNING FREE NORMAL TO FREE NODE'
        564                     C
        565                           MLST   = 2
        566                           CALL SRFEXX(MPFREE,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        567                          *            LPFREE,NPFREE,LOCAL,NODE,
        568                          *            LEFREE,NEFREE,MWRK,IWRK,IUT0,IERR)
        569                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        570     1                     IF(IERRA.NE.0) THEN
        571     1                         WRITE(IUT0,*)
        572     1                         WRITE(IUT0,*) ERMSGC
        573     1                         RETURN
        574     1                     ENDIF
        575                     C
        576                           CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        577                          *            LEFREE,NEFREE,XNFREE,YNFREE,ZNFREE,AEFREE)
        578                     C
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 1143
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      WRK6, WRK5, WRK4, (unknown)
                              <<< Loop-information  End >>>
        579     1  pp   2v            DO 500 IP = 1 , NP
        580     1   p   2v                WRK4(IP) = 0.E0
        581     1   p   2v                WRK5(IP) = 0.E0
        582     1   p   2v                WRK6(IP) = 0.E0
        583     1   p   2v        500 CONTINUE
        584                     C
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown), (unknown)
                              <<< Loop-information  End >>>
        585     1                     DO 520 IEFREE = 1 , NEFREE
        586     1                         IE = LEFREE(1,IEFREE)
        587     1                         IS = LEFREE(2,IEFREE)
        588     2                         IF(     NODE(8,IE).GE.1) THEN ! HEX
        589     2                            IETYPE = 4
        590     2                         ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
        591     2                            IETYPE = 3
        592     2                         ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
        593     2                            IETYPE = 2
        594     2                         ELSE                          ! TET
        595     2                            IETYPE = 1
        596     2                         ENDIF
        597     2                         IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUADRILATERAL
        598     2                            NNPS = 4
        599     2                         ELSE                             ! TRIANGLE
        600     2                            NNPS = 3
        601     2                         ENDIF
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 696
                              <<<  [OPTIMIZATION]
                              <<<    SOFTWARE PIPELINING(IPC: 1.62, ITR: 128, MVE: 3)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown)
                              <<< Loop-information  End >>>
        602     2   m   2s                DO 510 I = 1 , NNPS
        603     2   p   2v                    IP = NODE(LOCAL(I,IS,IETYPE),IE)
        604     2   m   2v                    WRK4(IP) = WRK4(IP)+XNFREE(IEFREE)
        605     2   s   2s                    WRK5(IP) = WRK5(IP)+YNFREE(IEFREE)
        606     2   s   2s                    WRK6(IP) = WRK6(IP)+ZNFREE(IEFREE)
        607     2   p   2v        510     CONTINUE
        608     1                 520 CONTINUE
        609                     C
        610                     C SUPERIMPOSE NEIGHBORING DOMAIN NORMAL VECTORS
        611                     C
        612                     C  NOTES; THIS PART MUST BE CALLED FOR ALL THE DOMAINS WHETHER OR NOT
        613                     C        THEY HAVE A FREE NODE. A DOMAIN WHICH HAS NO FREE NODE MUST
        614                     C        ALSO SEND ITS ZERO (DUMMY) RESIDUALS TO ITS NEIGHBORING DOMAINS
        615                     C        OTHERWISE COMMUNICATION WILL BE LOCKED. IF AT LEAST ONE OF
        616                     C        THE NEIGHBORING DOMAIN POSSESSES A FREE SURFACE, A DOMAIN MAY
        617                     C        ALSO BE ASSIGNED A NORMAL VECTOR TO ITS FREE NODE (WHICH IS
        618                     C        ISOLATED IN THE DOMAIN) AFTER THE COMMUNICATION.
        619                     C
        620                           IDIM = 3
        621                           CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
        622                          *            IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
        623                          *            IUT0,IERR,RX,RY,MAXBUF)
        624                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        625     1                     IF(IERRA.NE.0) THEN
        626     1                         WRITE(IUT0,*)
        627     1                         WRITE(IUT0,*) ERMSGC
        628     1                         RETURN
        629     1                     ENDIF
        630                     C
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 276
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 1.19, ITR: 160, MVE: 5)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LPFREE, ZPFREE, YPFREE, XPFREE
                              <<<      (unknown)
                              <<< Loop-information  End >>>
        631     1  pp    v            DO 530 IPFREE = 1 , NPFREE
        632     1   p    v                IP = LPFREE(IPFREE)
        633     1   p    v                ABSNOR = SQRT(WRK4(IP)**2+WRK5(IP)**2+WRK6(IP)**2+EPS)
        634     1   p    v                XPFREE(IPFREE) = WRK4(IP)/ABSNOR
        635     1   p    v                YPFREE(IPFREE) = WRK5(IP)/ABSNOR
        636     1   p    v                ZPFREE(IPFREE) = WRK6(IP)/ABSNOR
        637     1   p    v        530 CONTINUE
        638                     C
        639                           WRITE(IUT6,*) ' DONE!'
        640                           WRITE(IUT6,*) '   NEFREE=',NEFREE
        641                     C
        642                     C
        643                     C
        644                     C  PREPARE FOR FLUID FORCE CALCULATION BOUNDARY CONDITIONS
        645                     C
        646                     C
        647                     C
        648                     C EXTRACT BODY SURFACES, CALCULATE THEIR NORMAL VECTORS, AND
        649                     C GENERATE BODY SURFACE NODES TABLE
        650                     C
        651                     C
        652                           WRITE(IUT6,*)
        653                           WRITE(IUT6,*) ' LESSRF: EXTRACTING BODY SURFACES, CALCULATING'
        654                           WRITE(IUT6,*) '        THEIR NORMAL VECTORS, AND GENERATING'
        655                           WRITE(IUT6,*) '        BODY SURFACE NODE TABLE'
        656                     C
        657                           MLST   = 2
        658                           CALL SRFEXX(MPBODY,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        659                          *            LPBODY,NPBODY,LOCAL,NODE,
        660                          *            LEBODY,NEBODY,MWRK,IWRK,IUT0,IERR)
        661                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        662     1                     IF(IERRA.NE.0) THEN
        663     1                         WRITE(IUT0,*)
        664     1                         WRITE(IUT0,*) ERMSGC
        665     1                         RETURN
        666     1                     ENDIF
        667                     C
        668                           CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        669                          *            LEBODY,NEBODY,XNBODY,YNBODY,ZNBODY,AEBODY)
        670                     C
        671                           NPDUM = 0
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 942
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      WRK6, WRK5, WRK4, IWRK, (unknown)
                              <<< Loop-information  End >>>
        672     1  pp   2v            DO 610 IP = 1 , NP
        673     1   p   2v                IWRK(IP) = 0
        674     1   p   2v                WRK4(IP) = 0.E0
        675     1   p   2v                WRK5(IP) = 0.E0
        676     1   p   2v                WRK6(IP) = 0.E0
        677     1   p   2v        610 CONTINUE
        678                     C
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown), (unknown)
                              <<< Loop-information  End >>>
        679     1                     DO 640 IEBODY = 1 , NEBODY
        680     1                         IE = LEBODY(1,IEBODY)
        681     1                         IS = LEBODY(2,IEBODY)
        682     2                         IF(     NODE(8,IE).GE.1) THEN ! HEX
        683     2                            IETYPE = 4
        684     2                         ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
        685     2                            IETYPE = 3
        686     2                         ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
        687     2                            IETYPE = 2
        688     2                         ELSE                          ! TET
        689     2                            IETYPE = 1
        690     2                         ENDIF
                              <<< Loop-information Start >>>
                              <<<  [OPTIMIZATION]
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown)
                              <<<    SPILLS :
                              <<<      GENERAL   : SPILL 3  FILL 11
                              <<<      SIMD&FP   : SPILL 0  FILL 0
                              <<<      SCALABLE  : SPILL 0  FILL 0
                              <<<      PREDICATE : SPILL 0  FILL 0
                              <<< Loop-information  End >>>
        691     2        s                DO 620 I = 1 , N2D
        692     3        m                   IF(LOCAL(I,IS,IETYPE).GE.1) THEN
        693     3        s                      IP = NODE(LOCAL(I,IS,IETYPE),IE)
        694     4        s                      IF(IWRK(IP).EQ.0) THEN
        695     4        s                         NPDUM = NPDUM+1
        696     4               C
        697     5        s                         IF(NPDUM.GT.NPBODY) THEN
        698     5        s                            WRITE(IUT0,*)
        699     5        s                            WRITE(IUT0,*) ERMSGB
        700     5        s                            WRITE(IUT0,*) EREXP3
        701     5        s                            IERR = 1
        702     5               CC                    RETURN
        703     5        s                         ENDIF
        704     4               C
        705     4        s                         NODEPS(I,IEBODY) = NPDUM
        706     4        s                         XPS(NPDUM)       = REAL(X(IP))
        707     4        s                         YPS(NPDUM)       = REAL(Y(IP))
        708     4        s                         ZPS(NPDUM)       = REAL(Z(IP))
        709     4        s                         IWRK(IP)         = NPDUM
        710     4        s                      ELSE
        711     4        s                         NODEPS(I,IEBODY) = IWRK(IP)
        712     4        s                      ENDIF
        713     3        v                   ENDIF
        714     2               C
        715     2        v        620     CONTINUE
        716     1               C
        717     2                         IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUADRILATERAL
        718     2                            NNPS = 4
        719     2                         ELSE                             ! TRIANGLE
        720     2                            NNPS = 3
        721     2                         ENDIF
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 696
                              <<<  [OPTIMIZATION]
                              <<<    SOFTWARE PIPELINING(IPC: 1.62, ITR: 128, MVE: 3)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LOCAL, (unknown)
                              <<< Loop-information  End >>>
        722     2   m   2s                DO 630 I = 1 , NNPS
        723     2   p   2v                    IP = NODE(LOCAL(I,IS,IETYPE),IE)
        724     2   m   2v                    WRK4(IP) = WRK4(IP)+XNBODY(IEBODY)
        725     2   s   2s                    WRK5(IP) = WRK5(IP)+YNBODY(IEBODY)
        726     2   s   2s                    WRK6(IP) = WRK6(IP)+ZNBODY(IEBODY)
        727     2   p   2v        630     CONTINUE
        728     1               C
        729     1                 640 CONTINUE
        730                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        731     1                     IF(IERRA.NE.0) THEN
        732     1                         WRITE(IUT0,*)
        733     1                         WRITE(IUT0,*) ERMSGC
        734     1                         RETURN
        735     1                     ENDIF
        736                     C
        737     1                     IF(NPDUM.NE.NPBODY) THEN
        738     1                         WRITE(IUT6,*)
        739     1                         WRITE(IUT6,*) WRMSG
        740     1                         WRITE(IUT6,*) WREXP1
        741     1                     ENDIF
        742                           WRITE(IUT6,*) ' DONE!'
        743                           WRITE(IUT6,*) '   NEBODY=',NEBODY
        744                     C
        745                     C SUPERIMPOSE NEIGHBORING DOMAIN NORMAL VECTORS
        746                     C
        747                     C  NOTES; THIS PART MUST BE CALLED FOR ALL THE DOMAINS WHETHER OR NOT
        748                     C        THEY HAVE A FREE NODE. A DOMAIN WHICH HAS NO FREE NODE MUST
        749                     C        ALSO SEND ITS ZERO (DUMMY) RESIDUALS TO ITS NEIGHBORING DOMAINS
        750                     C        OTHERWISE COMMUNICATION WILL BE LOCKED. IF AT LEAST ONE OF
        751                     C        THE NEIGHBORING DOMAIN POSSESSES A FREE SURFACE, A DOMAIN MAY
        752                     C        ALSO BE ASSIGNED A NORMAL VECTOR TO ITS FREE NODE (WHICH IS
        753                     C        ISOLATED IN THE DOMAIN) AFTER THE COMMUNICATION.
        754                     C
        755                           IDIM = 3
        756                           CALL DDCOMX(IPART,IDIM,LDOM,NBPDOM,NDOM,
        757                          *            IPSLF,IPSND,MBPDOM,WRK4,WRK5,WRK6,NP,
        758                          *            IUT0,IERR,RX,RY,MAXBUF)
        759                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        760     1                     IF(IERRA.NE.0) THEN
        761     1                         WRITE(IUT0,*)
        762     1                         WRITE(IUT0,*) ERMSGC
        763     1                         RETURN
        764     1                     ENDIF
        765                     C
                              <<< Loop-information Start >>>
                              <<<  [PARALLELIZATION]
                              <<<    Standard iteration count: 276
                              <<<  [OPTIMIZATION]
                              <<<    SIMD(VL: 16)
                              <<<    SOFTWARE PIPELINING(IPC: 1.19, ITR: 160, MVE: 5)
                              <<<    PREFETCH(HARD) Expected by compiler :
                              <<<      LPBODY, ZPBODY, YPBODY, XPBODY
                              <<<      (unknown)
                              <<< Loop-information  End >>>
        766     1  pp    v            DO 650 IPBODY = 1 , NPBODY
        767     1   p    v                IP = LPBODY(IPBODY)
        768     1   p    v                ABSNOR = SQRT(WRK4(IP)**2+WRK5(IP)**2+WRK6(IP)**2+EPS)
        769     1   p    v                XPBODY(IPBODY) = WRK4(IP)/ABSNOR
        770     1   p    v                YPBODY(IPBODY) = WRK5(IP)/ABSNOR
        771     1   p    v                ZPBODY(IPBODY) = WRK6(IP)/ABSNOR
        772     1   p    v        650 CONTINUE
        773                     C
        774                           WRITE(IUT6,*) ' DONE!'
        775                           WRITE(IUT6,*) '   NEBODY=',NEBODY
        776                     C
        777                     C
        778                     C
        779                     C  PREPARE FOR OVERSET BOUNDARY CONDITIONS
        780                     C
        781                     C
        782                     C
        783                     C EXTRACT OVERSET SURFACES, CALCULATE THEIR NORMAL VECTORS
        784                     C
        785                     C
        786                           WRITE(IUT6,*)
        787                           WRITE(IUT6,*) ' LESSRF: EXTRACTING OVERSET SURFACES, CALCULATING'
        788                           WRITE(IUT6,*) '        THEIR NORMAL VECTORS '
        789                     C
        790                           MLST   = 2
        791                           CALL SRFEXX(MBESET,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        792                          *            LPSET1,NPSET,LOCAL,NODE,
        793                          *            LBESET,NBESET,MWRK,IWRK,IUT0,IERR)
        794                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        795     1                     IF(IERRA.NE.0) THEN
        796     1                         WRITE(IUT0,*)
        797     1                         WRITE(IUT0,*) ERMSGC
        798     1                         RETURN
        799     1                     ENDIF
        800                     C
        801                           CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        802                          *            LBESET,NBESET,XNESET,YNESET,ZNESET,AESET)
        803                     C
        804                           WRITE(IUT6,*) ' DONE!'
        805                           WRITE(IUT6,*) '   NPSET =',NPSET
        806                           WRITE(IUT6,*) '   NBESET=',NBESET
        807                     C
        808                     C
        809                     C EXTRACT HEAT SURFACES, CALCULATE THEIR NSURFACEAREA, AND
        810                     C GENERATE BODY SURFACE NODES TABLE
        811                     C
        812                     C
        813                           WRITE(IUT6,*)
        814                           WRITE(IUT6,*) ' LESSRF: EXTRACTING HEAT SURFACES, CALCULATING'
        815                           WRITE(IUT6,*) '        THEIR NORMAL VECTORS, AND GENERATING'
        816                           WRITE(IUT6,*) '        HEAT SURFACE NODE TABLE'
        817                     C
        818                           MLST   = 2
        819                           CALL SRFEXX(MPHEAT,MLST,NE,NP,N2,NEX,NS,NSP,N2D,
        820                          *            LPHEAT,NPHEAT,LOCAL,NODE,
        821                          *            LEHEAT,NEHEAT,MWRK,IWRK,IUT0,IERR)
        822                           CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
        823     1                     IF(IERRA.NE.0) THEN
        824     1                         WRITE(IUT0,*)
        825     1                         WRITE(IUT0,*) ERMSGC
        826     1                         RETURN
        827     1                     ENDIF
        828                     C
        829                           CALL CSIN3X(LOCAL,X,Y,Z,NODE,NE,NP,N2,NEX,NS,NSP,
        830                          *            LEHEAT,NEHEAT,WRK1,WRK2,WRK3,WRK4)
        831                     C
        832                           WRITE(IUT6,*) ' DONE!'
        833                           WRITE(IUT6,*) '   NEHEAT=',NEHEAT
        834                     C
        835                           RETURN
        836                           END

 Diagnostic messages: program name(LESSFX)
   jwd8220o-i  "lessfx.f", line 15: 副作用の可能性のある最適化を行いました。
   jwd2008i-i  "lessfx.f", line 56: この仮引数'LPSET3'は、副プログラム中で使用されていません。
   jwd2006i-i  "lessfx.f", line 108: この名前'ISEND'は、宣言だけされていて引用されていません。
   jwd2006i-i  "lessfx.f", line 108: この名前'IPB'は、宣言だけされていて引用されていません。
   jwd2006i-i  "lessfx.f", line 108: この名前'NPSETD'は、宣言だけされていて引用されていません。
   jwd5001p-i  "lessfx.f", line 283: このDOループを並列化しました。(名前:IDOM)
   jwd6001s-i  "lessfx.f", line 284: このDOループをSIMD化しました。(名前:IBP)
   jwd8204o-i  "lessfx.f", line 284: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 284: ループの繰返し数が576回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd5001p-i  "lessfx.f", line 291: このDOループを並列化しました。(名前:IPCCL)
   jwd6001s-i  "lessfx.f", line 291: このDOループをSIMD化しました。(名前:IPCCL)
   jwd8204o-i  "lessfx.f", line 291: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 291: ループの繰返し数が80回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd5121p-i  "lessfx.f", line 350: DOループ内に、自動並列化の制約となる入出力文が存在します。
   jwd5143p-i  "lessfx.f", line 366: DOループの繰返し数が少ないため、このDOループは並列化できません。
   jwd6001s-i  "lessfx.f", line 366: このDOループをSIMD化しました。(名前:I)
   jwd8674o-i  "lessfx.f", line 366: ループの繰返し数が192回より小さく、最適化の効果を得られないため、ソフトウェアパイプライニングを抑止しました。
   jwd8202o-i  "lessfx.f", line 366: ループを展開数4回でアンローリングしました。
   jwd6001s-i  "lessfx.f", line 369: このDOループをSIMD化しました。(名前:I)
   jwd8204o-i  "lessfx.f", line 369: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 369: ループの繰返し数が320回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 370: 多項式の演算順序を変更しました。
   jwd5209p-i  "lessfx.f", line 371: 配列'IOPPSN'の添字式中の変数'II'をループ中で定義しているため、このDOループは並列化できません。
   jwd5004p-i  "lessfx.f", line 377: リダクション演算を含むDOループを並列化しました。(名前:I)
   jwd6004s-i  "lessfx.f", line 377: リダクション演算を含むDOループをSIMD化しました。(名前:I)
   jwd8206o-i  "lessfx.f", line 385: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 386: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 387: 除算を逆数の乗算に変更しました。
   jwd8209o-i  "lessfx.f", line 397: 多項式の演算順序を変更しました。
   jwd5001p-i  "lessfx.f", line 481: このDOループを並列化しました。(名前:IP)
   jwd6001s-i  "lessfx.f", line 481: このDOループをSIMD化しました。(名前:IP)
   jwd8663o-i  "lessfx.f", line 481: ソフトウェアパイプライニングの効果がないループと判断したため、ソフトウェアパイプライニングを抑止しました。
   jwd8202o-i  "lessfx.f", line 481: ループを展開数2回でアンローリングしました。
   jwd5005p-i  "lessfx.f", line 504: このDOループを部分的に並列化しました。(名前:I)
   jwd6001s-i  "lessfx.f", line 504: このDOループをSIMD化しました。(名前:I)
   jwd8204o-i  "lessfx.f", line 504: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 504: ループの繰返し数が128回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 505: 多項式の演算順序を変更しました。
   jwd5209p-i  "lessfx.f", line 506: 配列'WRK4'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd5209p-i  "lessfx.f", line 507: 配列'WRK5'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd6208s-i  "lessfx.f", line 507: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK4)
   jwd6208s-i  "lessfx.f", line 507: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK5)
   jwd5209p-i  "lessfx.f", line 508: 配列'WRK6'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd6208s-i  "lessfx.f", line 508: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK6)
   jwd5001p-i  "lessfx.f", line 534: このDOループを並列化しました。(名前:IPSYMT)
   jwd6001s-i  "lessfx.f", line 534: このDOループをSIMD化しました。(名前:IPSYMT)
   jwd8204o-i  "lessfx.f", line 534: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 534: ループの繰返し数が160回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 536: 多項式の演算順序を変更しました。
   jwd8206o-i  "lessfx.f", line 537: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 538: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 539: 除算を逆数の乗算に変更しました。
   jwd5001p-i  "lessfx.f", line 579: このDOループを並列化しました。(名前:IP)
   jwd6001s-i  "lessfx.f", line 579: このDOループをSIMD化しました。(名前:IP)
   jwd8663o-i  "lessfx.f", line 579: ソフトウェアパイプライニングの効果がないループと判断したため、ソフトウェアパイプライニングを抑止しました。
   jwd8202o-i  "lessfx.f", line 579: ループを展開数2回でアンローリングしました。
   jwd5005p-i  "lessfx.f", line 602: このDOループを部分的に並列化しました。(名前:I)
   jwd6001s-i  "lessfx.f", line 602: このDOループをSIMD化しました。(名前:I)
   jwd8204o-i  "lessfx.f", line 602: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 602: ループの繰返し数が128回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 603: 多項式の演算順序を変更しました。
   jwd5209p-i  "lessfx.f", line 604: 配列'WRK4'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd5209p-i  "lessfx.f", line 605: 配列'WRK5'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd6208s-i  "lessfx.f", line 605: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK4)
   jwd6208s-i  "lessfx.f", line 605: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK5)
   jwd5209p-i  "lessfx.f", line 606: 配列'WRK6'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd6208s-i  "lessfx.f", line 606: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK6)
   jwd5001p-i  "lessfx.f", line 631: このDOループを並列化しました。(名前:IPFREE)
   jwd6001s-i  "lessfx.f", line 631: このDOループをSIMD化しました。(名前:IPFREE)
   jwd8204o-i  "lessfx.f", line 631: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 631: ループの繰返し数が160回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 633: 多項式の演算順序を変更しました。
   jwd8206o-i  "lessfx.f", line 634: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 635: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 636: 除算を逆数の乗算に変更しました。
   jwd5001p-i  "lessfx.f", line 672: このDOループを並列化しました。(名前:IP)
   jwd6001s-i  "lessfx.f", line 672: このDOループをSIMD化しました。(名前:IP)
   jwd8663o-i  "lessfx.f", line 672: ソフトウェアパイプライニングの効果がないループと判断したため、ソフトウェアパイプライニングを抑止しました。
   jwd8202o-i  "lessfx.f", line 672: ループを展開数2回でアンローリングしました。
   jwd5121p-i  "lessfx.f", line 679: DOループ内に、自動並列化の制約となる入出力文が存在します。
   jwd5228p-i  "lessfx.f", line 691: データの定義引用の順序が逐次実行と異なるため、このDOループは並列化できません。
   jwd5208p-i  "lessfx.f", line 691: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループは並列化できません。(名前:NPDUM)
   jwd6229s-i  "lessfx.f", line 691: IF文が存在するため、このDOループのSIMD化を抑止しました。
   jwd8664o-i  "lessfx.f", line 691: ループ内に関数呼出しなどの最適化対象外の命令があるため、ソフトウェアパイプライニングを適用できません。
   jwd6209s-i  "lessfx.f", line 694: 配列'IWRK'の添字式中の変数'IP'をループ中で定義しているため、このDOループはSIMD化できません。
   jwd6228s-i  "lessfx.f", line 695: データの定義引用の順序が逐次実行と異なる可能性があるため、このDOループはSIMD化できません。
   jwd6202s-i  "lessfx.f", line 695: データの定義引用の順序が逐次実行と異なるため、このDOループはSIMD化できません。(名前:NPDUM)
   jwd5121p-i  "lessfx.f", line 698: DOループ内に、自動並列化の制約となる入出力文が存在します。
   jwd6121s-i  "lessfx.f", line 698: DOループ内に、SIMD化の制約となる入出力文が存在します。
   jwd5121p-i  "lessfx.f", line 699: DOループ内に、自動並列化の制約となる入出力文が存在します。
   jwd6121s-i  "lessfx.f", line 699: DOループ内に、SIMD化の制約となる入出力文が存在します。
   jwd5121p-i  "lessfx.f", line 700: DOループ内に、自動並列化の制約となる入出力文が存在します。
   jwd6121s-i  "lessfx.f", line 700: DOループ内に、SIMD化の制約となる入出力文が存在します。
   jwd5005p-i  "lessfx.f", line 722: このDOループを部分的に並列化しました。(名前:I)
   jwd6001s-i  "lessfx.f", line 722: このDOループをSIMD化しました。(名前:I)
   jwd8204o-i  "lessfx.f", line 722: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 722: ループの繰返し数が128回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 723: 多項式の演算順序を変更しました。
   jwd5209p-i  "lessfx.f", line 724: 配列'WRK4'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd5209p-i  "lessfx.f", line 725: 配列'WRK5'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd6208s-i  "lessfx.f", line 725: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK4)
   jwd6208s-i  "lessfx.f", line 725: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK5)
   jwd5209p-i  "lessfx.f", line 726: 配列'WRK6'の添字式中の変数'IP'をループ中で定義しているため、このDOループは並列化できません。
   jwd6208s-i  "lessfx.f", line 726: 定義引用の順序が分からないため、定義引用順序が逐次実行と異なる可能性があり、このDOループはSIMD化できません。(名前:WRK6)
   jwd5001p-i  "lessfx.f", line 766: このDOループを並列化しました。(名前:IPBODY)
   jwd6001s-i  "lessfx.f", line 766: このDOループをSIMD化しました。(名前:IPBODY)
   jwd8204o-i  "lessfx.f", line 766: ループにソフトウェアパイプライニングを適用しました。
   jwd8205o-i  "lessfx.f", line 766: ループの繰返し数が160回以上の時、ソフトウェアパイプライニングを適用したループが実行時に選択されます。
   jwd8209o-i  "lessfx.f", line 768: 多項式の演算順序を変更しました。
   jwd8206o-i  "lessfx.f", line 769: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 770: 除算を逆数の乗算に変更しました。
   jwd8206o-i  "lessfx.f", line 771: 除算を逆数の乗算に変更しました。

 Procedure information
   Lines      : 836
   Statements : 401
   Stack(byte): 67040
   Prefetch num: 0

 Total information
   Procedures       : 1
   Total lines      : 836
   Total statements : 401
   Total stack(byte): 67040
   Total prefetch num: 0

