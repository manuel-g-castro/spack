CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CC
CC    SUBROUTINE FOR COUNTING MAXMUM NUMBER OF INTER-CONNECT BOUNDARY FACE    
CC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE SIZF01(IPART,NE,NP,N2,NSP,NS,NODE,LOCAL,
     *                  MDOM,NDOM,MBPDOM,LDOM,NBPDOM,IPSLF,
     *                  MBFDOM,LWRK01,IUT6,IUT0,IERR)
C
      IMPLICIT NONE
C
C     [INPUT]
      INTEGER*4 IPART,NE,NP,N2,NSP,NS
      INTEGER*4 NODE(N2,NE),LOCAL(NSP,NS,4)
      INTEGER*4 MDOM,NDOM,MBPDOM
      INTEGER*4 LDOM(MDOM),NBPDOM(MDOM),IPSLF(MBPDOM,MDOM)
C
C     [IN-OUTPUT]
      INTEGER*4 MBFDOM
      INTEGER*4 IUT6,IUT0,IERR
C
C     [WORK]
      INTEGER*4 LWRK01(NP)
C
C     [LOCAL]
      INTEGER*4 NFSND,IBUF
      INTEGER*4 IP,IP1,IP2,IP3,IP4,JBC
      INTEGER*4 IE,IETYPE,NLS,IS
      INTEGER*4 IBP,IDOM,NUM1,IERRA,LERR(2)
      DATA NFSND /0/
      DATA NUM1  /1/
C
      CHARACTER*60 ERMSGC
     * / ' ## SUBROUTINE SIZF01: ERROR OCCURED            ; RETURNED' /
C
CC
CCHY [1] COUNT MAXMUM NUMBER OF INTER-CONNECT BOUNDARY FACE
CC
      MBFDOM=0
      DO 1000 IDOM=1,NDOM
C
         DO 1100 IP=1,NP
            LWRK01(IP)=0
 1100    CONTINUE
C            
         DO 1200 IBP=1,NBPDOM(IDOM)
            IP=IPSLF(IBP,IDOM)
            LWRK01(IP)=IBP
 1200    CONTINUE
C
         NFSND=0
         DO 1300 IE=1,NE
            IF(     NODE(8,IE).GE.1) THEN ! HEX
               IETYPE=4
               NLS=6
            ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
               IETYPE=3
               NLS=5
            ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
               IETYPE=2
               NLS=5
            ELSE                          ! TET
               IETYPE=1
               NLS=4
            ENDIF
            DO 1400 IS=1,NLS
C
               IP1=NODE(LOCAL(1,IS,IETYPE),IE)
               IP2=NODE(LOCAL(2,IS,IETYPE),IE)
               IP3=NODE(LOCAL(3,IS,IETYPE),IE)
C
               IF ((IETYPE.EQ.1            ).OR. ! TRI
     *             (IETYPE.EQ.2.AND.IS.LE.4).OR.
     *             (IETYPE.EQ.3.AND.IS.LE.2)) THEN
                  IP4=0
                  JBC=LWRK01(IP1)*LWRK01(IP2)*LWRK01(IP3)
               ELSE                             ! QUAD
                  IP4=NODE(LOCAL(4,IS,IETYPE),IE)
                  JBC=LWRK01(IP1)*LWRK01(IP2)*LWRK01(IP3)*LWRK01(IP4)
               ENDIF
C
               IF (JBC.EQ.0) GOTO 1400
C
               NFSND=NFSND+1
C
 1400       CONTINUE
 1300    CONTINUE
         MBFDOM=MAX(MBFDOM,NFSND)
C
 1000 CONTINUE
C
      DO 1500 IDOM=1,NDOM
         LWRK01(IDOM)=1
 1500 CONTINUE
C
      CALL DDMAXI(MBFDOM,IBUF,IERR)
      CALL ERRCHK(IUT6,IPART,1,IERR,IERRA)
      IF(IERRA.NE.0) GOTO 9999
      MBFDOM=IBUF
C
      RETURN
C
 9999 CONTINUE
      WRITE(IUT0,*)
      WRITE(IUT0,*) ERMSGC
      IERR=1
C
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CC
CC    SUBROUTINE FOR CALCULATING AREA VECTOR
CC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CALAVC(IE,IS,NE,NP,N2,NSP,NS,NODE,LOCAL,X,Y,Z,AVEC)
C
      IMPLICIT NONE
C
C     [INPUT]
      INTEGER*4 IE,IS,NE,NP,N2,NSP,NS
      INTEGER*4 NODE(N2,NE),LOCAL(NSP,NS,4)
      REAL*8    X(NP),Y(NP),Z(NP)
C
C     [OUTPUT]
      REAL*4 AVEC(4)
C
C     [LOCAL]
      INTEGER*4 IETYPE,IA0,IA1,IB0,IB1
      REAL*8    AX,AY,AZ,BX,BY,BZ,CX,CY,CZ,CABS
C
      IF(     NODE(8,IE).GE.1) THEN ! HEX
         IETYPE=4
      ELSE IF(NODE(6,IE).GE.1) THEN ! PRS
         IETYPE=3
      ELSE IF(NODE(5,IE).GE.1) THEN ! PYR
         IETYPE=2
      ELSE                          ! TET
         IETYPE=1
      ENDIF   
      IF(LOCAL(4,IS,IETYPE).GE.1) THEN ! QUAD
         IA1=NODE(LOCAL(3,IS,IETYPE),IE)
         IA0=NODE(LOCAL(1,IS,IETYPE),IE)
         IB1=NODE(LOCAL(4,IS,IETYPE),IE)
         IB0=NODE(LOCAL(2,IS,IETYPE),IE)
      ELSE                             ! TRI
         IA1=NODE(LOCAL(2,IS,IETYPE),IE)
         IA0=NODE(LOCAL(1,IS,IETYPE),IE)
         IB1=NODE(LOCAL(3,IS,IETYPE),IE)
         IB0=NODE(LOCAL(1,IS,IETYPE),IE)
      ENDIF   
C
      AX=X(IA1)-X(IA0)
      AY=Y(IA1)-Y(IA0)
      AZ=Z(IA1)-Z(IA0)
C
      BX=X(IB1)-X(IB0)
      BY=Y(IB1)-Y(IB0)
      BZ=Z(IB1)-Z(IB0)
C
      CX   = AY*BZ-AZ*BY
      CY   = AZ*BX-AX*BZ
      CZ   = AX*BY-AY*BX
      CABS = SQRT(CX*CX+CY*CY+CZ*CZ)
C
      AVEC(1)=REAL(CX/CABS   )
      AVEC(2)=REAL(CY/CABS   )
      AVEC(3)=REAL(CZ/CABS   )
      AVEC(4)=REAL(0.5D0*CABS)
C
      RETURN
      END
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
CC
CC    SUBROUTINE FOR CALCULATING DIRECTION VECTOR FROM DONNOR TO ACCEPTOR
CC
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
      SUBROUTINE CALDVC(IE1,IE2,NE,NP,N2,NODE,X,Y,Z,DVEC)
C
      IMPLICIT NONE
C
C     [INPUT]
      INTEGER*4 IE1,IE2,NE,NP,N2
      INTEGER*4 NODE(N2,NE)
      REAL*8    X(NP),Y(NP),Z(NP)
C
C     [OUTPUT]
      REAL*4 DVEC(3)
C
C     [LOCAL]
      INTEGER*4 NNP,IP,I
      REAL*8    AX,AY,AZ,BX,BY,BZ,CX,CY,CZ,CABS
C
      NNP=0
      AX=0.0D0
      AY=0.0D0
      AZ=0.0D0
      DO 1000 I=1,8
         IP=NODE(I,IE1)
         IF (IP.EQ.0) GOTO 1000
         AX=AX+X(IP)
         AY=AY+Y(IP)
         AZ=AZ+Z(IP)
         NNP=NNP+1
 1000 CONTINUE
      AX=AX/DBLE(NNP)
      AY=AY/DBLE(NNP)
      AZ=AZ/DBLE(NNP)
C
      NNP=0
      BX=0.0D0
      BY=0.0D0
      BZ=0.0D0
      DO 1100 I=1,8
         IP=NODE(I,IE2)
         IF (IP.EQ.0) GOTO 1100
         BX=BX+X(IP)
         BY=BY+Y(IP)
         BZ=BZ+Z(IP)
         NNP=NNP+1
 1100 CONTINUE
      BX=BX/DBLE(NNP)
      BY=BY/DBLE(NNP)
      BZ=BZ/DBLE(NNP)
C
      CX=BX-AX
      CY=BY-AY
      CZ=BZ-AZ
      CABS=SQRT(CX*CX+CY*CY+CZ*CZ)
C
      DVEC(1)=REAL(CX/CABS)
      DVEC(2)=REAL(CY/CABS)
      DVEC(3)=REAL(CZ/CABS)
C
      RETURN
      END
